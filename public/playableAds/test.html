<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Project</title>
  <script type="module">/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const sr="164",qt={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},$t={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Ic=0,Tr=1,vc=2,va=1,Ea=2,at=3,ht=0,Te=1,Ze=2,St=0,In=1,yr=2,Dr=3,Sr=4,Ec=5,Vt=100,xc=101,Tc=102,yc=103,Dc=104,Sc=200,bc=201,Bc=202,Rc=203,Zs=204,Xs=205,zc=206,_c=207,Uc=208,Nc=209,Lc=210,Oc=211,Fc=212,Qc=213,jc=214,Hc=0,kc=1,Vc=2,Hi=3,Gc=4,Wc=5,Zc=6,Xc=7,xa=0,Yc=1,Jc=2,bt=0,Kc=1,qc=2,$c=3,Al=4,el=5,tl=6,nl=7,br="attached",il="detached",Ta=300,Tn=301,yn=302,Ys=303,Js=304,qi=306,Dn=1e3,yt=1001,ki=1002,ve=1003,ya=1004,Kn=1005,be=1006,Qi=1007,ct=1008,Bt=1009,sl=1010,rl=1011,Da=1012,Sa=1013,Sn=1014,Ye=1015,$i=1016,ba=1017,Ba=1018,si=1020,ol=35902,al=1021,cl=1022,je=1023,ll=1024,hl=1025,vn=1026,ti=1027,Ra=1028,za=1029,ul=1030,_a=1031,Ua=1033,os=33776,as=33777,cs=33778,ls=33779,Br=35840,Rr=35841,zr=35842,_r=35843,Ur=36196,Nr=37492,Lr=37496,Or=37808,Fr=37809,Qr=37810,jr=37811,Hr=37812,kr=37813,Vr=37814,Gr=37815,Wr=37816,Zr=37817,Xr=37818,Yr=37819,Jr=37820,Kr=37821,hs=36492,qr=36494,$r=36495,dl=36283,Ao=36284,eo=36285,to=36286,fl=2200,pl=2201,gl=2202,ni=2300,bn=2301,us=2302,Mn=2400,Pn=2401,Vi=2402,rr=2500,ml=2501,Cl=0,Na=1,Ks=2,Ml=3200,Pl=3201,or=0,wl=1,Tt="",Me="srgb",fe="srgb-linear",ar="display-p3",As="display-p3-linear",Gi="linear",Ae="srgb",Wi="rec709",Zi="p3",An=7680,no=519,Il=512,vl=513,El=514,La=515,xl=516,Tl=517,yl=518,Dl=519,qs=35044,io="300 es",lt=2e3,Xi=2001;class _t{addEventListener(A,e){this._listeners===void 0&&(this._listeners={});const t=this._listeners;t[A]===void 0&&(t[A]=[]),t[A].indexOf(e)===-1&&t[A].push(e)}hasEventListener(A,e){if(this._listeners===void 0)return!1;const t=this._listeners;return t[A]!==void 0&&t[A].indexOf(e)!==-1}removeEventListener(A,e){if(this._listeners===void 0)return;const n=this._listeners[A];if(n!==void 0){const s=n.indexOf(e);s!==-1&&n.splice(s,1)}}dispatchEvent(A){if(this._listeners===void 0)return;const t=this._listeners[A.type];if(t!==void 0){A.target=this;const n=t.slice(0);for(let s=0,r=n.length;s<r;s++)n[s].call(this,A);A.target=null}}}const me=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let so=1234567;const $n=Math.PI/180,Bn=180/Math.PI;function He(){const i=Math.random()*4294967295|0,A=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0;return(me[i&255]+me[i>>8&255]+me[i>>16&255]+me[i>>24&255]+"-"+me[A&255]+me[A>>8&255]+"-"+me[A>>16&15|64]+me[A>>24&255]+"-"+me[e&63|128]+me[e>>8&255]+"-"+me[e>>16&255]+me[e>>24&255]+me[t&255]+me[t>>8&255]+me[t>>16&255]+me[t>>24&255]).toLowerCase()}function de(i,A,e){return Math.max(A,Math.min(e,i))}function cr(i,A){return(i%A+A)%A}function Sl(i,A,e,t,n){return t+(i-A)*(n-t)/(e-A)}function bl(i,A,e){return i!==A?(e-i)/(A-i):0}function Ai(i,A,e){return(1-e)*i+e*A}function Bl(i,A,e,t){return Ai(i,A,1-Math.exp(-e*t))}function Rl(i,A=1){return A-Math.abs(cr(i,A*2)-A)}function zl(i,A,e){return i<=A?0:i>=e?1:(i=(i-A)/(e-A),i*i*(3-2*i))}function _l(i,A,e){return i<=A?0:i>=e?1:(i=(i-A)/(e-A),i*i*i*(i*(i*6-15)+10))}function Ul(i,A){return i+Math.floor(Math.random()*(A-i+1))}function Nl(i,A){return i+Math.random()*(A-i)}function Ll(i){return i*(.5-Math.random())}function Ol(i){i!==void 0&&(so=i);let A=so+=1831565813;return A=Math.imul(A^A>>>15,A|1),A^=A+Math.imul(A^A>>>7,A|61),((A^A>>>14)>>>0)/4294967296}function Fl(i){return i*$n}function Ql(i){return i*Bn}function jl(i){return(i&i-1)===0&&i!==0}function Hl(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))}function kl(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function Vl(i,A,e,t,n){const s=Math.cos,r=Math.sin,o=s(e/2),a=r(e/2),c=s((A+t)/2),l=r((A+t)/2),h=s((A-t)/2),u=r((A-t)/2),d=s((t-A)/2),g=r((t-A)/2);switch(n){case"XYX":i.set(o*l,a*h,a*u,o*c);break;case"YZY":i.set(a*u,o*l,a*h,o*c);break;case"ZXZ":i.set(a*h,a*u,o*l,o*c);break;case"XZX":i.set(o*l,a*g,a*d,o*c);break;case"YXY":i.set(a*d,o*l,a*g,o*c);break;case"ZYZ":i.set(a*g,a*d,o*l,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}}function Qe(i,A){switch(A.constructor){case Float32Array:return i;case Uint32Array:return i/4294967295;case Uint16Array:return i/65535;case Uint8Array:return i/255;case Int32Array:return Math.max(i/2147483647,-1);case Int16Array:return Math.max(i/32767,-1);case Int8Array:return Math.max(i/127,-1);default:throw new Error("Invalid component type.")}}function XA(i,A){switch(A.constructor){case Float32Array:return i;case Uint32Array:return Math.round(i*4294967295);case Uint16Array:return Math.round(i*65535);case Uint8Array:return Math.round(i*255);case Int32Array:return Math.round(i*2147483647);case Int16Array:return Math.round(i*32767);case Int8Array:return Math.round(i*127);default:throw new Error("Invalid component type.")}}const Oa={DEG2RAD:$n,RAD2DEG:Bn,generateUUID:He,clamp:de,euclideanModulo:cr,mapLinear:Sl,inverseLerp:bl,lerp:Ai,damp:Bl,pingpong:Rl,smoothstep:zl,smootherstep:_l,randInt:Ul,randFloat:Nl,randFloatSpread:Ll,seededRandom:Ol,degToRad:Fl,radToDeg:Ql,isPowerOfTwo:jl,ceilPowerOfTwo:Hl,floorPowerOfTwo:kl,setQuaternionFromProperEuler:Vl,normalize:XA,denormalize:Qe};class MA{constructor(A=0,e=0){MA.prototype.isVector2=!0,this.x=A,this.y=e}get width(){return this.x}set width(A){this.x=A}get height(){return this.y}set height(A){this.y=A}set(A,e){return this.x=A,this.y=e,this}setScalar(A){return this.x=A,this.y=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setComponent(A,e){switch(A){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y)}copy(A){return this.x=A.x,this.y=A.y,this}add(A){return this.x+=A.x,this.y+=A.y,this}addScalar(A){return this.x+=A,this.y+=A,this}addVectors(A,e){return this.x=A.x+e.x,this.y=A.y+e.y,this}addScaledVector(A,e){return this.x+=A.x*e,this.y+=A.y*e,this}sub(A){return this.x-=A.x,this.y-=A.y,this}subScalar(A){return this.x-=A,this.y-=A,this}subVectors(A,e){return this.x=A.x-e.x,this.y=A.y-e.y,this}multiply(A){return this.x*=A.x,this.y*=A.y,this}multiplyScalar(A){return this.x*=A,this.y*=A,this}divide(A){return this.x/=A.x,this.y/=A.y,this}divideScalar(A){return this.multiplyScalar(1/A)}applyMatrix3(A){const e=this.x,t=this.y,n=A.elements;return this.x=n[0]*e+n[3]*t+n[6],this.y=n[1]*e+n[4]*t+n[7],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this}clamp(A,e){return this.x=Math.max(A.x,Math.min(e.x,this.x)),this.y=Math.max(A.y,Math.min(e.y,this.y)),this}clampScalar(A,e){return this.x=Math.max(A,Math.min(e,this.x)),this.y=Math.max(A,Math.min(e,this.y)),this}clampLength(A,e){const t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(A,Math.min(e,t)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(A){return this.x*A.x+this.y*A.y}cross(A){return this.x*A.y-this.y*A.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(A){const e=Math.sqrt(this.lengthSq()*A.lengthSq());if(e===0)return Math.PI/2;const t=this.dot(A)/e;return Math.acos(de(t,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const e=this.x-A.x,t=this.y-A.y;return e*e+t*t}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,e){return this.x+=(A.x-this.x)*e,this.y+=(A.y-this.y)*e,this}lerpVectors(A,e,t){return this.x=A.x+(e.x-A.x)*t,this.y=A.y+(e.y-A.y)*t,this}equals(A){return A.x===this.x&&A.y===this.y}fromArray(A,e=0){return this.x=A[e],this.y=A[e+1],this}toArray(A=[],e=0){return A[e]=this.x,A[e+1]=this.y,A}fromBufferAttribute(A,e){return this.x=A.getX(e),this.y=A.getY(e),this}rotateAround(A,e){const t=Math.cos(e),n=Math.sin(e),s=this.x-A.x,r=this.y-A.y;return this.x=s*t-r*n+A.x,this.y=s*n+r*t+A.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class BA{constructor(A,e,t,n,s,r,o,a,c){BA.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],A!==void 0&&this.set(A,e,t,n,s,r,o,a,c)}set(A,e,t,n,s,r,o,a,c){const l=this.elements;return l[0]=A,l[1]=n,l[2]=o,l[3]=e,l[4]=s,l[5]=a,l[6]=t,l[7]=r,l[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const e=this.elements,t=A.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],this}extractBasis(A,e,t){return A.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),t.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const e=A.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,e){const t=A.elements,n=e.elements,s=this.elements,r=t[0],o=t[3],a=t[6],c=t[1],l=t[4],h=t[7],u=t[2],d=t[5],g=t[8],C=n[0],p=n[3],f=n[6],E=n[1],I=n[4],x=n[7],z=n[2],D=n[5],y=n[8];return s[0]=r*C+o*E+a*z,s[3]=r*p+o*I+a*D,s[6]=r*f+o*x+a*y,s[1]=c*C+l*E+h*z,s[4]=c*p+l*I+h*D,s[7]=c*f+l*x+h*y,s[2]=u*C+d*E+g*z,s[5]=u*p+d*I+g*D,s[8]=u*f+d*x+g*y,this}multiplyScalar(A){const e=this.elements;return e[0]*=A,e[3]*=A,e[6]*=A,e[1]*=A,e[4]*=A,e[7]*=A,e[2]*=A,e[5]*=A,e[8]*=A,this}determinant(){const A=this.elements,e=A[0],t=A[1],n=A[2],s=A[3],r=A[4],o=A[5],a=A[6],c=A[7],l=A[8];return e*r*l-e*o*c-t*s*l+t*o*a+n*s*c-n*r*a}invert(){const A=this.elements,e=A[0],t=A[1],n=A[2],s=A[3],r=A[4],o=A[5],a=A[6],c=A[7],l=A[8],h=l*r-o*c,u=o*a-l*s,d=c*s-r*a,g=e*h+t*u+n*d;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const C=1/g;return A[0]=h*C,A[1]=(n*c-l*t)*C,A[2]=(o*t-n*r)*C,A[3]=u*C,A[4]=(l*e-n*a)*C,A[5]=(n*s-o*e)*C,A[6]=d*C,A[7]=(t*a-c*e)*C,A[8]=(r*e-t*s)*C,this}transpose(){let A;const e=this.elements;return A=e[1],e[1]=e[3],e[3]=A,A=e[2],e[2]=e[6],e[6]=A,A=e[5],e[5]=e[7],e[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const e=this.elements;return A[0]=e[0],A[1]=e[3],A[2]=e[6],A[3]=e[1],A[4]=e[4],A[5]=e[7],A[6]=e[2],A[7]=e[5],A[8]=e[8],this}setUvTransform(A,e,t,n,s,r,o){const a=Math.cos(s),c=Math.sin(s);return this.set(t*a,t*c,-t*(a*r+c*o)+r+A,-n*c,n*a,-n*(-c*r+a*o)+o+e,0,0,1),this}scale(A,e){return this.premultiply(ds.makeScale(A,e)),this}rotate(A){return this.premultiply(ds.makeRotation(-A)),this}translate(A,e){return this.premultiply(ds.makeTranslation(A,e)),this}makeTranslation(A,e){return A.isVector2?this.set(1,0,A.x,0,1,A.y,0,0,1):this.set(1,0,A,0,1,e,0,0,1),this}makeRotation(A){const e=Math.cos(A),t=Math.sin(A);return this.set(e,-t,0,t,e,0,0,0,1),this}makeScale(A,e){return this.set(A,0,0,0,e,0,0,0,1),this}equals(A){const e=this.elements,t=A.elements;for(let n=0;n<9;n++)if(e[n]!==t[n])return!1;return!0}fromArray(A,e=0){for(let t=0;t<9;t++)this.elements[t]=A[t+e];return this}toArray(A=[],e=0){const t=this.elements;return A[e]=t[0],A[e+1]=t[1],A[e+2]=t[2],A[e+3]=t[3],A[e+4]=t[4],A[e+5]=t[5],A[e+6]=t[6],A[e+7]=t[7],A[e+8]=t[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const ds=new BA;function Fa(i){for(let A=i.length-1;A>=0;--A)if(i[A]>=65535)return!0;return!1}function ii(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}function Gl(){const i=ii("canvas");return i.style.display="block",i}const ro={};function Qa(i){i in ro||(ro[i]=!0,console.warn(i))}const oo=new BA().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),ao=new BA().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),hi={[fe]:{transfer:Gi,primaries:Wi,toReference:i=>i,fromReference:i=>i},[Me]:{transfer:Ae,primaries:Wi,toReference:i=>i.convertSRGBToLinear(),fromReference:i=>i.convertLinearToSRGB()},[As]:{transfer:Gi,primaries:Zi,toReference:i=>i.applyMatrix3(ao),fromReference:i=>i.applyMatrix3(oo)},[ar]:{transfer:Ae,primaries:Zi,toReference:i=>i.convertSRGBToLinear().applyMatrix3(ao),fromReference:i=>i.applyMatrix3(oo).convertLinearToSRGB()}},Wl=new Set([fe,As]),WA={enabled:!0,_workingColorSpace:fe,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(i){if(!Wl.has(i))throw new Error(`Unsupported working color space, "${i}".`);this._workingColorSpace=i},convert:function(i,A,e){if(this.enabled===!1||A===e||!A||!e)return i;const t=hi[A].toReference,n=hi[e].fromReference;return n(t(i))},fromWorkingColorSpace:function(i,A){return this.convert(i,this._workingColorSpace,A)},toWorkingColorSpace:function(i,A){return this.convert(i,A,this._workingColorSpace)},getPrimaries:function(i){return hi[i].primaries},getTransfer:function(i){return i===Tt?Gi:hi[i].transfer}};function En(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function fs(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}let en;class Zl{static getDataURL(A){if(/^data:/i.test(A.src)||typeof HTMLCanvasElement>"u")return A.src;let e;if(A instanceof HTMLCanvasElement)e=A;else{en===void 0&&(en=ii("canvas")),en.width=A.width,en.height=A.height;const t=en.getContext("2d");A instanceof ImageData?t.putImageData(A,0,0):t.drawImage(A,0,0,A.width,A.height),e=en}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",A),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(A){if(typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&A instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&A instanceof ImageBitmap){const e=ii("canvas");e.width=A.width,e.height=A.height;const t=e.getContext("2d");t.drawImage(A,0,0,A.width,A.height);const n=t.getImageData(0,0,A.width,A.height),s=n.data;for(let r=0;r<s.length;r++)s[r]=En(s[r]/255)*255;return t.putImageData(n,0,0),e}else if(A.data){const e=A.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(En(e[t]/255)*255):e[t]=En(e[t]);return{data:e,width:A.width,height:A.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),A}}let Xl=0;class ja{constructor(A=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Xl++}),this.uuid=He(),this.data=A,this.dataReady=!0,this.version=0}set needsUpdate(A){A===!0&&this.version++}toJSON(A){const e=A===void 0||typeof A=="string";if(!e&&A.images[this.uuid]!==void 0)return A.images[this.uuid];const t={uuid:this.uuid,url:""},n=this.data;if(n!==null){let s;if(Array.isArray(n)){s=[];for(let r=0,o=n.length;r<o;r++)n[r].isDataTexture?s.push(ps(n[r].image)):s.push(ps(n[r]))}else s=ps(n);t.url=s}return e||(A.images[this.uuid]=t),t}}function ps(i){return typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&i instanceof ImageBitmap?Zl.getDataURL(i):i.data?{data:Array.from(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Yl=0;class ue extends _t{constructor(A=ue.DEFAULT_IMAGE,e=ue.DEFAULT_MAPPING,t=yt,n=yt,s=be,r=ct,o=je,a=Bt,c=ue.DEFAULT_ANISOTROPY,l=Tt){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Yl++}),this.uuid=He(),this.name="",this.source=new ja(A),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=t,this.wrapT=n,this.magFilter=s,this.minFilter=r,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=a,this.offset=new MA(0,0),this.repeat=new MA(1,1),this.center=new MA(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new BA,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=l,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(A=null){this.source.data=A}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(A){return this.name=A.name,this.source=A.source,this.mipmaps=A.mipmaps.slice(0),this.mapping=A.mapping,this.channel=A.channel,this.wrapS=A.wrapS,this.wrapT=A.wrapT,this.magFilter=A.magFilter,this.minFilter=A.minFilter,this.anisotropy=A.anisotropy,this.format=A.format,this.internalFormat=A.internalFormat,this.type=A.type,this.offset.copy(A.offset),this.repeat.copy(A.repeat),this.center.copy(A.center),this.rotation=A.rotation,this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrix.copy(A.matrix),this.generateMipmaps=A.generateMipmaps,this.premultiplyAlpha=A.premultiplyAlpha,this.flipY=A.flipY,this.unpackAlignment=A.unpackAlignment,this.colorSpace=A.colorSpace,this.userData=JSON.parse(JSON.stringify(A.userData)),this.needsUpdate=!0,this}toJSON(A){const e=A===void 0||typeof A=="string";if(!e&&A.textures[this.uuid]!==void 0)return A.textures[this.uuid];const t={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(A).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(t.userData=this.userData),e||(A.textures[this.uuid]=t),t}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(A){if(this.mapping!==Ta)return A;if(A.applyMatrix3(this.matrix),A.x<0||A.x>1)switch(this.wrapS){case Dn:A.x=A.x-Math.floor(A.x);break;case yt:A.x=A.x<0?0:1;break;case ki:Math.abs(Math.floor(A.x)%2)===1?A.x=Math.ceil(A.x)-A.x:A.x=A.x-Math.floor(A.x);break}if(A.y<0||A.y>1)switch(this.wrapT){case Dn:A.y=A.y-Math.floor(A.y);break;case yt:A.y=A.y<0?0:1;break;case ki:Math.abs(Math.floor(A.y)%2)===1?A.y=Math.ceil(A.y)-A.y:A.y=A.y-Math.floor(A.y);break}return this.flipY&&(A.y=1-A.y),A}set needsUpdate(A){A===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(A){A===!0&&this.pmremVersion++}}ue.DEFAULT_IMAGE=null;ue.DEFAULT_MAPPING=Ta;ue.DEFAULT_ANISOTROPY=1;class qA{constructor(A=0,e=0,t=0,n=1){qA.prototype.isVector4=!0,this.x=A,this.y=e,this.z=t,this.w=n}get width(){return this.z}set width(A){this.z=A}get height(){return this.w}set height(A){this.w=A}set(A,e,t,n){return this.x=A,this.y=e,this.z=t,this.w=n,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this.w=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setW(A){return this.w=A,this}setComponent(A,e){switch(A){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this.w=A.w!==void 0?A.w:1,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this.w+=A.w,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this.w+=A,this}addVectors(A,e){return this.x=A.x+e.x,this.y=A.y+e.y,this.z=A.z+e.z,this.w=A.w+e.w,this}addScaledVector(A,e){return this.x+=A.x*e,this.y+=A.y*e,this.z+=A.z*e,this.w+=A.w*e,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this.w-=A.w,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this.w-=A,this}subVectors(A,e){return this.x=A.x-e.x,this.y=A.y-e.y,this.z=A.z-e.z,this.w=A.w-e.w,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this.w*=A.w,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this.w*=A,this}applyMatrix4(A){const e=this.x,t=this.y,n=this.z,s=this.w,r=A.elements;return this.x=r[0]*e+r[4]*t+r[8]*n+r[12]*s,this.y=r[1]*e+r[5]*t+r[9]*n+r[13]*s,this.z=r[2]*e+r[6]*t+r[10]*n+r[14]*s,this.w=r[3]*e+r[7]*t+r[11]*n+r[15]*s,this}divideScalar(A){return this.multiplyScalar(1/A)}setAxisAngleFromQuaternion(A){this.w=2*Math.acos(A.w);const e=Math.sqrt(1-A.w*A.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=A.x/e,this.y=A.y/e,this.z=A.z/e),this}setAxisAngleFromRotationMatrix(A){let e,t,n,s;const a=A.elements,c=a[0],l=a[4],h=a[8],u=a[1],d=a[5],g=a[9],C=a[2],p=a[6],f=a[10];if(Math.abs(l-u)<.01&&Math.abs(h-C)<.01&&Math.abs(g-p)<.01){if(Math.abs(l+u)<.1&&Math.abs(h+C)<.1&&Math.abs(g+p)<.1&&Math.abs(c+d+f-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const I=(c+1)/2,x=(d+1)/2,z=(f+1)/2,D=(l+u)/4,y=(h+C)/4,F=(g+p)/4;return I>x&&I>z?I<.01?(t=0,n=.707106781,s=.707106781):(t=Math.sqrt(I),n=D/t,s=y/t):x>z?x<.01?(t=.707106781,n=0,s=.707106781):(n=Math.sqrt(x),t=D/n,s=F/n):z<.01?(t=.707106781,n=.707106781,s=0):(s=Math.sqrt(z),t=y/s,n=F/s),this.set(t,n,s,e),this}let E=Math.sqrt((p-g)*(p-g)+(h-C)*(h-C)+(u-l)*(u-l));return Math.abs(E)<.001&&(E=1),this.x=(p-g)/E,this.y=(h-C)/E,this.z=(u-l)/E,this.w=Math.acos((c+d+f-1)/2),this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this.w=Math.min(this.w,A.w),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this.w=Math.max(this.w,A.w),this}clamp(A,e){return this.x=Math.max(A.x,Math.min(e.x,this.x)),this.y=Math.max(A.y,Math.min(e.y,this.y)),this.z=Math.max(A.z,Math.min(e.z,this.z)),this.w=Math.max(A.w,Math.min(e.w,this.w)),this}clampScalar(A,e){return this.x=Math.max(A,Math.min(e,this.x)),this.y=Math.max(A,Math.min(e,this.y)),this.z=Math.max(A,Math.min(e,this.z)),this.w=Math.max(A,Math.min(e,this.w)),this}clampLength(A,e){const t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(A,Math.min(e,t)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z+this.w*A.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,e){return this.x+=(A.x-this.x)*e,this.y+=(A.y-this.y)*e,this.z+=(A.z-this.z)*e,this.w+=(A.w-this.w)*e,this}lerpVectors(A,e,t){return this.x=A.x+(e.x-A.x)*t,this.y=A.y+(e.y-A.y)*t,this.z=A.z+(e.z-A.z)*t,this.w=A.w+(e.w-A.w)*t,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z&&A.w===this.w}fromArray(A,e=0){return this.x=A[e],this.y=A[e+1],this.z=A[e+2],this.w=A[e+3],this}toArray(A=[],e=0){return A[e]=this.x,A[e+1]=this.y,A[e+2]=this.z,A[e+3]=this.w,A}fromBufferAttribute(A,e){return this.x=A.getX(e),this.y=A.getY(e),this.z=A.getZ(e),this.w=A.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Jl extends _t{constructor(A=1,e=1,t={}){super(),this.isRenderTarget=!0,this.width=A,this.height=e,this.depth=1,this.scissor=new qA(0,0,A,e),this.scissorTest=!1,this.viewport=new qA(0,0,A,e);const n={width:A,height:e,depth:1};t=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:be,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},t);const s=new ue(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace);s.flipY=!1,s.generateMipmaps=t.generateMipmaps,s.internalFormat=t.internalFormat,this.textures=[];const r=t.count;for(let o=0;o<r;o++)this.textures[o]=s.clone(),this.textures[o].isRenderTargetTexture=!0;this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,this.depthTexture=t.depthTexture,this.samples=t.samples}get texture(){return this.textures[0]}set texture(A){this.textures[0]=A}setSize(A,e,t=1){if(this.width!==A||this.height!==e||this.depth!==t){this.width=A,this.height=e,this.depth=t;for(let n=0,s=this.textures.length;n<s;n++)this.textures[n].image.width=A,this.textures[n].image.height=e,this.textures[n].image.depth=t;this.dispose()}this.viewport.set(0,0,A,e),this.scissor.set(0,0,A,e)}clone(){return new this.constructor().copy(this)}copy(A){this.width=A.width,this.height=A.height,this.depth=A.depth,this.scissor.copy(A.scissor),this.scissorTest=A.scissorTest,this.viewport.copy(A.viewport),this.textures.length=0;for(let t=0,n=A.textures.length;t<n;t++)this.textures[t]=A.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0;const e=Object.assign({},A.texture.image);return this.texture.source=new ja(e),this.depthBuffer=A.depthBuffer,this.stencilBuffer=A.stencilBuffer,this.resolveDepthBuffer=A.resolveDepthBuffer,this.resolveStencilBuffer=A.resolveStencilBuffer,A.depthTexture!==null&&(this.depthTexture=A.depthTexture.clone()),this.samples=A.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Xt extends Jl{constructor(A=1,e=1,t={}){super(A,e,t),this.isWebGLRenderTarget=!0}}class Ha extends ue{constructor(A=null,e=1,t=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:A,width:e,height:t,depth:n},this.magFilter=ve,this.minFilter=ve,this.wrapR=yt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Kl extends ue{constructor(A=null,e=1,t=1,n=1){super(null),this.isData3DTexture=!0,this.image={data:A,width:e,height:t,depth:n},this.magFilter=ve,this.minFilter=ve,this.wrapR=yt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Be{constructor(A=0,e=0,t=0,n=1){this.isQuaternion=!0,this._x=A,this._y=e,this._z=t,this._w=n}static slerpFlat(A,e,t,n,s,r,o){let a=t[n+0],c=t[n+1],l=t[n+2],h=t[n+3];const u=s[r+0],d=s[r+1],g=s[r+2],C=s[r+3];if(o===0){A[e+0]=a,A[e+1]=c,A[e+2]=l,A[e+3]=h;return}if(o===1){A[e+0]=u,A[e+1]=d,A[e+2]=g,A[e+3]=C;return}if(h!==C||a!==u||c!==d||l!==g){let p=1-o;const f=a*u+c*d+l*g+h*C,E=f>=0?1:-1,I=1-f*f;if(I>Number.EPSILON){const z=Math.sqrt(I),D=Math.atan2(z,f*E);p=Math.sin(p*D)/z,o=Math.sin(o*D)/z}const x=o*E;if(a=a*p+u*x,c=c*p+d*x,l=l*p+g*x,h=h*p+C*x,p===1-o){const z=1/Math.sqrt(a*a+c*c+l*l+h*h);a*=z,c*=z,l*=z,h*=z}}A[e]=a,A[e+1]=c,A[e+2]=l,A[e+3]=h}static multiplyQuaternionsFlat(A,e,t,n,s,r){const o=t[n],a=t[n+1],c=t[n+2],l=t[n+3],h=s[r],u=s[r+1],d=s[r+2],g=s[r+3];return A[e]=o*g+l*h+a*d-c*u,A[e+1]=a*g+l*u+c*h-o*d,A[e+2]=c*g+l*d+o*u-a*h,A[e+3]=l*g-o*h-a*u-c*d,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,e,t,n){return this._x=A,this._y=e,this._z=t,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,e=!0){const t=A._x,n=A._y,s=A._z,r=A._order,o=Math.cos,a=Math.sin,c=o(t/2),l=o(n/2),h=o(s/2),u=a(t/2),d=a(n/2),g=a(s/2);switch(r){case"XYZ":this._x=u*l*h+c*d*g,this._y=c*d*h-u*l*g,this._z=c*l*g+u*d*h,this._w=c*l*h-u*d*g;break;case"YXZ":this._x=u*l*h+c*d*g,this._y=c*d*h-u*l*g,this._z=c*l*g-u*d*h,this._w=c*l*h+u*d*g;break;case"ZXY":this._x=u*l*h-c*d*g,this._y=c*d*h+u*l*g,this._z=c*l*g+u*d*h,this._w=c*l*h-u*d*g;break;case"ZYX":this._x=u*l*h-c*d*g,this._y=c*d*h+u*l*g,this._z=c*l*g-u*d*h,this._w=c*l*h+u*d*g;break;case"YZX":this._x=u*l*h+c*d*g,this._y=c*d*h+u*l*g,this._z=c*l*g-u*d*h,this._w=c*l*h-u*d*g;break;case"XZY":this._x=u*l*h-c*d*g,this._y=c*d*h-u*l*g,this._z=c*l*g+u*d*h,this._w=c*l*h+u*d*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(A,e){const t=e/2,n=Math.sin(t);return this._x=A.x*n,this._y=A.y*n,this._z=A.z*n,this._w=Math.cos(t),this._onChangeCallback(),this}setFromRotationMatrix(A){const e=A.elements,t=e[0],n=e[4],s=e[8],r=e[1],o=e[5],a=e[9],c=e[2],l=e[6],h=e[10],u=t+o+h;if(u>0){const d=.5/Math.sqrt(u+1);this._w=.25/d,this._x=(l-a)*d,this._y=(s-c)*d,this._z=(r-n)*d}else if(t>o&&t>h){const d=2*Math.sqrt(1+t-o-h);this._w=(l-a)/d,this._x=.25*d,this._y=(n+r)/d,this._z=(s+c)/d}else if(o>h){const d=2*Math.sqrt(1+o-t-h);this._w=(s-c)/d,this._x=(n+r)/d,this._y=.25*d,this._z=(a+l)/d}else{const d=2*Math.sqrt(1+h-t-o);this._w=(r-n)/d,this._x=(s+c)/d,this._y=(a+l)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(A,e){let t=A.dot(e)+1;return t<Number.EPSILON?(t=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=t):(this._x=0,this._y=-A.z,this._z=A.y,this._w=t)):(this._x=A.y*e.z-A.z*e.y,this._y=A.z*e.x-A.x*e.z,this._z=A.x*e.y-A.y*e.x,this._w=t),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(de(this.dot(A),-1,1)))}rotateTowards(A,e){const t=this.angleTo(A);if(t===0)return this;const n=Math.min(1,e/t);return this.slerp(A,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,e){const t=A._x,n=A._y,s=A._z,r=A._w,o=e._x,a=e._y,c=e._z,l=e._w;return this._x=t*l+r*o+n*c-s*a,this._y=n*l+r*a+s*o-t*c,this._z=s*l+r*c+t*a-n*o,this._w=r*l-t*o-n*a-s*c,this._onChangeCallback(),this}slerp(A,e){if(e===0)return this;if(e===1)return this.copy(A);const t=this._x,n=this._y,s=this._z,r=this._w;let o=r*A._w+t*A._x+n*A._y+s*A._z;if(o<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,o=-o):this.copy(A),o>=1)return this._w=r,this._x=t,this._y=n,this._z=s,this;const a=1-o*o;if(a<=Number.EPSILON){const d=1-e;return this._w=d*r+e*this._w,this._x=d*t+e*this._x,this._y=d*n+e*this._y,this._z=d*s+e*this._z,this.normalize(),this}const c=Math.sqrt(a),l=Math.atan2(c,o),h=Math.sin((1-e)*l)/c,u=Math.sin(e*l)/c;return this._w=r*h+this._w*u,this._x=t*h+this._x*u,this._y=n*h+this._y*u,this._z=s*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(A,e,t){return this.copy(A).slerp(e,t)}random(){const A=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),t=Math.random(),n=Math.sqrt(1-t),s=Math.sqrt(t);return this.set(n*Math.sin(A),n*Math.cos(A),s*Math.sin(e),s*Math.cos(e))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,e=0){return this._x=A[e],this._y=A[e+1],this._z=A[e+2],this._w=A[e+3],this._onChangeCallback(),this}toArray(A=[],e=0){return A[e]=this._x,A[e+1]=this._y,A[e+2]=this._z,A[e+3]=this._w,A}fromBufferAttribute(A,e){return this._x=A.getX(e),this._y=A.getY(e),this._z=A.getZ(e),this._w=A.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class S{constructor(A=0,e=0,t=0){S.prototype.isVector3=!0,this.x=A,this.y=e,this.z=t}set(A,e,t){return t===void 0&&(t=this.z),this.x=A,this.y=e,this.z=t,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,e){switch(A){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,e){return this.x=A.x+e.x,this.y=A.y+e.y,this.z=A.z+e.z,this}addScaledVector(A,e){return this.x+=A.x*e,this.y+=A.y*e,this.z+=A.z*e,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,e){return this.x=A.x-e.x,this.y=A.y-e.y,this.z=A.z-e.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,e){return this.x=A.x*e.x,this.y=A.y*e.y,this.z=A.z*e.z,this}applyEuler(A){return this.applyQuaternion(co.setFromEuler(A))}applyAxisAngle(A,e){return this.applyQuaternion(co.setFromAxisAngle(A,e))}applyMatrix3(A){const e=this.x,t=this.y,n=this.z,s=A.elements;return this.x=s[0]*e+s[3]*t+s[6]*n,this.y=s[1]*e+s[4]*t+s[7]*n,this.z=s[2]*e+s[5]*t+s[8]*n,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const e=this.x,t=this.y,n=this.z,s=A.elements,r=1/(s[3]*e+s[7]*t+s[11]*n+s[15]);return this.x=(s[0]*e+s[4]*t+s[8]*n+s[12])*r,this.y=(s[1]*e+s[5]*t+s[9]*n+s[13])*r,this.z=(s[2]*e+s[6]*t+s[10]*n+s[14])*r,this}applyQuaternion(A){const e=this.x,t=this.y,n=this.z,s=A.x,r=A.y,o=A.z,a=A.w,c=2*(r*n-o*t),l=2*(o*e-s*n),h=2*(s*t-r*e);return this.x=e+a*c+r*h-o*l,this.y=t+a*l+o*c-s*h,this.z=n+a*h+s*l-r*c,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const e=this.x,t=this.y,n=this.z,s=A.elements;return this.x=s[0]*e+s[4]*t+s[8]*n,this.y=s[1]*e+s[5]*t+s[9]*n,this.z=s[2]*e+s[6]*t+s[10]*n,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,e){return this.x=Math.max(A.x,Math.min(e.x,this.x)),this.y=Math.max(A.y,Math.min(e.y,this.y)),this.z=Math.max(A.z,Math.min(e.z,this.z)),this}clampScalar(A,e){return this.x=Math.max(A,Math.min(e,this.x)),this.y=Math.max(A,Math.min(e,this.y)),this.z=Math.max(A,Math.min(e,this.z)),this}clampLength(A,e){const t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(A,Math.min(e,t)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,e){return this.x+=(A.x-this.x)*e,this.y+=(A.y-this.y)*e,this.z+=(A.z-this.z)*e,this}lerpVectors(A,e,t){return this.x=A.x+(e.x-A.x)*t,this.y=A.y+(e.y-A.y)*t,this.z=A.z+(e.z-A.z)*t,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,e){const t=A.x,n=A.y,s=A.z,r=e.x,o=e.y,a=e.z;return this.x=n*a-s*o,this.y=s*r-t*a,this.z=t*o-n*r,this}projectOnVector(A){const e=A.lengthSq();if(e===0)return this.set(0,0,0);const t=A.dot(this)/e;return this.copy(A).multiplyScalar(t)}projectOnPlane(A){return gs.copy(this).projectOnVector(A),this.sub(gs)}reflect(A){return this.sub(gs.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const e=Math.sqrt(this.lengthSq()*A.lengthSq());if(e===0)return Math.PI/2;const t=this.dot(A)/e;return Math.acos(de(t,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const e=this.x-A.x,t=this.y-A.y,n=this.z-A.z;return e*e+t*t+n*n}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,e,t){const n=Math.sin(e)*A;return this.x=n*Math.sin(t),this.y=Math.cos(e)*A,this.z=n*Math.cos(t),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,e,t){return this.x=A*Math.sin(e),this.y=t,this.z=A*Math.cos(e),this}setFromMatrixPosition(A){const e=A.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(A){const e=this.setFromMatrixColumn(A,0).length(),t=this.setFromMatrixColumn(A,1).length(),n=this.setFromMatrixColumn(A,2).length();return this.x=e,this.y=t,this.z=n,this}setFromMatrixColumn(A,e){return this.fromArray(A.elements,e*4)}setFromMatrix3Column(A,e){return this.fromArray(A.elements,e*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}setFromColor(A){return this.x=A.r,this.y=A.g,this.z=A.b,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,e=0){return this.x=A[e],this.y=A[e+1],this.z=A[e+2],this}toArray(A=[],e=0){return A[e]=this.x,A[e+1]=this.y,A[e+2]=this.z,A}fromBufferAttribute(A,e){return this.x=A.getX(e),this.y=A.getY(e),this.z=A.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=Math.random()*Math.PI*2,e=Math.random()*2-1,t=Math.sqrt(1-e*e);return this.x=t*Math.cos(A),this.y=e,this.z=t*Math.sin(A),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const gs=new S,co=new Be;class ut{constructor(A=new S(1/0,1/0,1/0),e=new S(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=e}set(A,e){return this.min.copy(A),this.max.copy(e),this}setFromArray(A){this.makeEmpty();for(let e=0,t=A.length;e<t;e+=3)this.expandByPoint(Le.fromArray(A,e));return this}setFromBufferAttribute(A){this.makeEmpty();for(let e=0,t=A.count;e<t;e++)this.expandByPoint(Le.fromBufferAttribute(A,e));return this}setFromPoints(A){this.makeEmpty();for(let e=0,t=A.length;e<t;e++)this.expandByPoint(A[e]);return this}setFromCenterAndSize(A,e){const t=Le.copy(e).multiplyScalar(.5);return this.min.copy(A).sub(t),this.max.copy(A).add(t),this}setFromObject(A,e=!1){return this.makeEmpty(),this.expandByObject(A,e)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,e=!1){A.updateWorldMatrix(!1,!1);const t=A.geometry;if(t!==void 0){const s=t.getAttribute("position");if(e===!0&&s!==void 0&&A.isInstancedMesh!==!0)for(let r=0,o=s.count;r<o;r++)A.isMesh===!0?A.getVertexPosition(r,Le):Le.fromBufferAttribute(s,r),Le.applyMatrix4(A.matrixWorld),this.expandByPoint(Le);else A.boundingBox!==void 0?(A.boundingBox===null&&A.computeBoundingBox(),ui.copy(A.boundingBox)):(t.boundingBox===null&&t.computeBoundingBox(),ui.copy(t.boundingBox)),ui.applyMatrix4(A.matrixWorld),this.union(ui)}const n=A.children;for(let s=0,r=n.length;s<r;s++)this.expandByObject(n[s],e);return this}containsPoint(A){return!(A.x<this.min.x||A.x>this.max.x||A.y<this.min.y||A.y>this.max.y||A.z<this.min.z||A.z>this.max.z)}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,e){return e.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return!(A.max.x<this.min.x||A.min.x>this.max.x||A.max.y<this.min.y||A.min.y>this.max.y||A.max.z<this.min.z||A.min.z>this.max.z)}intersectsSphere(A){return this.clampPoint(A.center,Le),Le.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let e,t;return A.normal.x>0?(e=A.normal.x*this.min.x,t=A.normal.x*this.max.x):(e=A.normal.x*this.max.x,t=A.normal.x*this.min.x),A.normal.y>0?(e+=A.normal.y*this.min.y,t+=A.normal.y*this.max.y):(e+=A.normal.y*this.max.y,t+=A.normal.y*this.min.y),A.normal.z>0?(e+=A.normal.z*this.min.z,t+=A.normal.z*this.max.z):(e+=A.normal.z*this.max.z,t+=A.normal.z*this.min.z),e<=-A.constant&&t>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(Hn),di.subVectors(this.max,Hn),tn.subVectors(A.a,Hn),nn.subVectors(A.b,Hn),sn.subVectors(A.c,Hn),mt.subVectors(nn,tn),Ct.subVectors(sn,nn),Nt.subVectors(tn,sn);let e=[0,-mt.z,mt.y,0,-Ct.z,Ct.y,0,-Nt.z,Nt.y,mt.z,0,-mt.x,Ct.z,0,-Ct.x,Nt.z,0,-Nt.x,-mt.y,mt.x,0,-Ct.y,Ct.x,0,-Nt.y,Nt.x,0];return!ms(e,tn,nn,sn,di)||(e=[1,0,0,0,1,0,0,0,1],!ms(e,tn,nn,sn,di))?!1:(fi.crossVectors(mt,Ct),e=[fi.x,fi.y,fi.z],ms(e,tn,nn,sn,di))}clampPoint(A,e){return e.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,Le).distanceTo(A)}getBoundingSphere(A){return this.isEmpty()?A.makeEmpty():(this.getCenter(A.center),A.radius=this.getSize(Le).length()*.5),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(tt[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),tt[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),tt[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),tt[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),tt[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),tt[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),tt[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),tt[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(tt),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const tt=[new S,new S,new S,new S,new S,new S,new S,new S],Le=new S,ui=new ut,tn=new S,nn=new S,sn=new S,mt=new S,Ct=new S,Nt=new S,Hn=new S,di=new S,fi=new S,Lt=new S;function ms(i,A,e,t,n){for(let s=0,r=i.length-3;s<=r;s+=3){Lt.fromArray(i,s);const o=n.x*Math.abs(Lt.x)+n.y*Math.abs(Lt.y)+n.z*Math.abs(Lt.z),a=A.dot(Lt),c=e.dot(Lt),l=t.dot(Lt);if(Math.max(-Math.max(a,c,l),Math.min(a,c,l))>o)return!1}return!0}const ql=new ut,kn=new S,Cs=new S;class Ke{constructor(A=new S,e=-1){this.isSphere=!0,this.center=A,this.radius=e}set(A,e){return this.center.copy(A),this.radius=e,this}setFromPoints(A,e){const t=this.center;e!==void 0?t.copy(e):ql.setFromPoints(A).getCenter(t);let n=0;for(let s=0,r=A.length;s<r;s++)n=Math.max(n,t.distanceToSquared(A[s]));return this.radius=Math.sqrt(n),this}copy(A){return this.center.copy(A.center),this.radius=A.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(A){return A.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(A){return A.distanceTo(this.center)-this.radius}intersectsSphere(A){const e=this.radius+A.radius;return A.center.distanceToSquared(this.center)<=e*e}intersectsBox(A){return A.intersectsSphere(this)}intersectsPlane(A){return Math.abs(A.distanceToPoint(this.center))<=this.radius}clampPoint(A,e){const t=this.center.distanceToSquared(A);return e.copy(A),t>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(A){return this.isEmpty()?(A.makeEmpty(),A):(A.set(this.center,this.center),A.expandByScalar(this.radius),A)}applyMatrix4(A){return this.center.applyMatrix4(A),this.radius=this.radius*A.getMaxScaleOnAxis(),this}translate(A){return this.center.add(A),this}expandByPoint(A){if(this.isEmpty())return this.center.copy(A),this.radius=0,this;kn.subVectors(A,this.center);const e=kn.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=(t-this.radius)*.5;this.center.addScaledVector(kn,n/t),this.radius+=n}return this}union(A){return A.isEmpty()?this:this.isEmpty()?(this.copy(A),this):(this.center.equals(A.center)===!0?this.radius=Math.max(this.radius,A.radius):(Cs.subVectors(A.center,this.center).setLength(A.radius),this.expandByPoint(kn.copy(A.center).add(Cs)),this.expandByPoint(kn.copy(A.center).sub(Cs))),this)}equals(A){return A.center.equals(this.center)&&A.radius===this.radius}clone(){return new this.constructor().copy(this)}}const nt=new S,Ms=new S,pi=new S,Mt=new S,Ps=new S,gi=new S,ws=new S;class ri{constructor(A=new S,e=new S(0,0,-1)){this.origin=A,this.direction=e}set(A,e){return this.origin.copy(A),this.direction.copy(e),this}copy(A){return this.origin.copy(A.origin),this.direction.copy(A.direction),this}at(A,e){return e.copy(this.origin).addScaledVector(this.direction,A)}lookAt(A){return this.direction.copy(A).sub(this.origin).normalize(),this}recast(A){return this.origin.copy(this.at(A,nt)),this}closestPointToPoint(A,e){e.subVectors(A,this.origin);const t=e.dot(this.direction);return t<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,t)}distanceToPoint(A){return Math.sqrt(this.distanceSqToPoint(A))}distanceSqToPoint(A){const e=nt.subVectors(A,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(A):(nt.copy(this.origin).addScaledVector(this.direction,e),nt.distanceToSquared(A))}distanceSqToSegment(A,e,t,n){Ms.copy(A).add(e).multiplyScalar(.5),pi.copy(e).sub(A).normalize(),Mt.copy(this.origin).sub(Ms);const s=A.distanceTo(e)*.5,r=-this.direction.dot(pi),o=Mt.dot(this.direction),a=-Mt.dot(pi),c=Mt.lengthSq(),l=Math.abs(1-r*r);let h,u,d,g;if(l>0)if(h=r*a-o,u=r*o-a,g=s*l,h>=0)if(u>=-g)if(u<=g){const C=1/l;h*=C,u*=C,d=h*(h+r*u+2*o)+u*(r*h+u+2*a)+c}else u=s,h=Math.max(0,-(r*u+o)),d=-h*h+u*(u+2*a)+c;else u=-s,h=Math.max(0,-(r*u+o)),d=-h*h+u*(u+2*a)+c;else u<=-g?(h=Math.max(0,-(-r*s+o)),u=h>0?-s:Math.min(Math.max(-s,-a),s),d=-h*h+u*(u+2*a)+c):u<=g?(h=0,u=Math.min(Math.max(-s,-a),s),d=u*(u+2*a)+c):(h=Math.max(0,-(r*s+o)),u=h>0?s:Math.min(Math.max(-s,-a),s),d=-h*h+u*(u+2*a)+c);else u=r>0?-s:s,h=Math.max(0,-(r*u+o)),d=-h*h+u*(u+2*a)+c;return t&&t.copy(this.origin).addScaledVector(this.direction,h),n&&n.copy(Ms).addScaledVector(pi,u),d}intersectSphere(A,e){nt.subVectors(A.center,this.origin);const t=nt.dot(this.direction),n=nt.dot(nt)-t*t,s=A.radius*A.radius;if(n>s)return null;const r=Math.sqrt(s-n),o=t-r,a=t+r;return a<0?null:o<0?this.at(a,e):this.at(o,e)}intersectsSphere(A){return this.distanceSqToPoint(A.center)<=A.radius*A.radius}distanceToPlane(A){const e=A.normal.dot(this.direction);if(e===0)return A.distanceToPoint(this.origin)===0?0:null;const t=-(this.origin.dot(A.normal)+A.constant)/e;return t>=0?t:null}intersectPlane(A,e){const t=this.distanceToPlane(A);return t===null?null:this.at(t,e)}intersectsPlane(A){const e=A.distanceToPoint(this.origin);return e===0||A.normal.dot(this.direction)*e<0}intersectBox(A,e){let t,n,s,r,o,a;const c=1/this.direction.x,l=1/this.direction.y,h=1/this.direction.z,u=this.origin;return c>=0?(t=(A.min.x-u.x)*c,n=(A.max.x-u.x)*c):(t=(A.max.x-u.x)*c,n=(A.min.x-u.x)*c),l>=0?(s=(A.min.y-u.y)*l,r=(A.max.y-u.y)*l):(s=(A.max.y-u.y)*l,r=(A.min.y-u.y)*l),t>r||s>n||((s>t||isNaN(t))&&(t=s),(r<n||isNaN(n))&&(n=r),h>=0?(o=(A.min.z-u.z)*h,a=(A.max.z-u.z)*h):(o=(A.max.z-u.z)*h,a=(A.min.z-u.z)*h),t>a||o>n)||((o>t||t!==t)&&(t=o),(a<n||n!==n)&&(n=a),n<0)?null:this.at(t>=0?t:n,e)}intersectsBox(A){return this.intersectBox(A,nt)!==null}intersectTriangle(A,e,t,n,s){Ps.subVectors(e,A),gi.subVectors(t,A),ws.crossVectors(Ps,gi);let r=this.direction.dot(ws),o;if(r>0){if(n)return null;o=1}else if(r<0)o=-1,r=-r;else return null;Mt.subVectors(this.origin,A);const a=o*this.direction.dot(gi.crossVectors(Mt,gi));if(a<0)return null;const c=o*this.direction.dot(Ps.cross(Mt));if(c<0||a+c>r)return null;const l=-o*Mt.dot(ws);return l<0?null:this.at(l/r,s)}applyMatrix4(A){return this.origin.applyMatrix4(A),this.direction.transformDirection(A),this}equals(A){return A.origin.equals(this.origin)&&A.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class RA{constructor(A,e,t,n,s,r,o,a,c,l,h,u,d,g,C,p){RA.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],A!==void 0&&this.set(A,e,t,n,s,r,o,a,c,l,h,u,d,g,C,p)}set(A,e,t,n,s,r,o,a,c,l,h,u,d,g,C,p){const f=this.elements;return f[0]=A,f[4]=e,f[8]=t,f[12]=n,f[1]=s,f[5]=r,f[9]=o,f[13]=a,f[2]=c,f[6]=l,f[10]=h,f[14]=u,f[3]=d,f[7]=g,f[11]=C,f[15]=p,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new RA().fromArray(this.elements)}copy(A){const e=this.elements,t=A.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],this}copyPosition(A){const e=this.elements,t=A.elements;return e[12]=t[12],e[13]=t[13],e[14]=t[14],this}setFromMatrix3(A){const e=A.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(A,e,t){return A.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),t.setFromMatrixColumn(this,2),this}makeBasis(A,e,t){return this.set(A.x,e.x,t.x,0,A.y,e.y,t.y,0,A.z,e.z,t.z,0,0,0,0,1),this}extractRotation(A){const e=this.elements,t=A.elements,n=1/rn.setFromMatrixColumn(A,0).length(),s=1/rn.setFromMatrixColumn(A,1).length(),r=1/rn.setFromMatrixColumn(A,2).length();return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=0,e[4]=t[4]*s,e[5]=t[5]*s,e[6]=t[6]*s,e[7]=0,e[8]=t[8]*r,e[9]=t[9]*r,e[10]=t[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(A){const e=this.elements,t=A.x,n=A.y,s=A.z,r=Math.cos(t),o=Math.sin(t),a=Math.cos(n),c=Math.sin(n),l=Math.cos(s),h=Math.sin(s);if(A.order==="XYZ"){const u=r*l,d=r*h,g=o*l,C=o*h;e[0]=a*l,e[4]=-a*h,e[8]=c,e[1]=d+g*c,e[5]=u-C*c,e[9]=-o*a,e[2]=C-u*c,e[6]=g+d*c,e[10]=r*a}else if(A.order==="YXZ"){const u=a*l,d=a*h,g=c*l,C=c*h;e[0]=u+C*o,e[4]=g*o-d,e[8]=r*c,e[1]=r*h,e[5]=r*l,e[9]=-o,e[2]=d*o-g,e[6]=C+u*o,e[10]=r*a}else if(A.order==="ZXY"){const u=a*l,d=a*h,g=c*l,C=c*h;e[0]=u-C*o,e[4]=-r*h,e[8]=g+d*o,e[1]=d+g*o,e[5]=r*l,e[9]=C-u*o,e[2]=-r*c,e[6]=o,e[10]=r*a}else if(A.order==="ZYX"){const u=r*l,d=r*h,g=o*l,C=o*h;e[0]=a*l,e[4]=g*c-d,e[8]=u*c+C,e[1]=a*h,e[5]=C*c+u,e[9]=d*c-g,e[2]=-c,e[6]=o*a,e[10]=r*a}else if(A.order==="YZX"){const u=r*a,d=r*c,g=o*a,C=o*c;e[0]=a*l,e[4]=C-u*h,e[8]=g*h+d,e[1]=h,e[5]=r*l,e[9]=-o*l,e[2]=-c*l,e[6]=d*h+g,e[10]=u-C*h}else if(A.order==="XZY"){const u=r*a,d=r*c,g=o*a,C=o*c;e[0]=a*l,e[4]=-h,e[8]=c*l,e[1]=u*h+C,e[5]=r*l,e[9]=d*h-g,e[2]=g*h-d,e[6]=o*l,e[10]=C*h+u}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(A){return this.compose($l,A,Ah)}lookAt(A,e,t){const n=this.elements;return De.subVectors(A,e),De.lengthSq()===0&&(De.z=1),De.normalize(),Pt.crossVectors(t,De),Pt.lengthSq()===0&&(Math.abs(t.z)===1?De.x+=1e-4:De.z+=1e-4,De.normalize(),Pt.crossVectors(t,De)),Pt.normalize(),mi.crossVectors(De,Pt),n[0]=Pt.x,n[4]=mi.x,n[8]=De.x,n[1]=Pt.y,n[5]=mi.y,n[9]=De.y,n[2]=Pt.z,n[6]=mi.z,n[10]=De.z,this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,e){const t=A.elements,n=e.elements,s=this.elements,r=t[0],o=t[4],a=t[8],c=t[12],l=t[1],h=t[5],u=t[9],d=t[13],g=t[2],C=t[6],p=t[10],f=t[14],E=t[3],I=t[7],x=t[11],z=t[15],D=n[0],y=n[4],F=n[8],v=n[12],P=n[1],N=n[5],V=n[9],b=n[13],W=n[2],G=n[6],K=n[10],q=n[14],H=n[3],AA=n[7],$=n[11],uA=n[15];return s[0]=r*D+o*P+a*W+c*H,s[4]=r*y+o*N+a*G+c*AA,s[8]=r*F+o*V+a*K+c*$,s[12]=r*v+o*b+a*q+c*uA,s[1]=l*D+h*P+u*W+d*H,s[5]=l*y+h*N+u*G+d*AA,s[9]=l*F+h*V+u*K+d*$,s[13]=l*v+h*b+u*q+d*uA,s[2]=g*D+C*P+p*W+f*H,s[6]=g*y+C*N+p*G+f*AA,s[10]=g*F+C*V+p*K+f*$,s[14]=g*v+C*b+p*q+f*uA,s[3]=E*D+I*P+x*W+z*H,s[7]=E*y+I*N+x*G+z*AA,s[11]=E*F+I*V+x*K+z*$,s[15]=E*v+I*b+x*q+z*uA,this}multiplyScalar(A){const e=this.elements;return e[0]*=A,e[4]*=A,e[8]*=A,e[12]*=A,e[1]*=A,e[5]*=A,e[9]*=A,e[13]*=A,e[2]*=A,e[6]*=A,e[10]*=A,e[14]*=A,e[3]*=A,e[7]*=A,e[11]*=A,e[15]*=A,this}determinant(){const A=this.elements,e=A[0],t=A[4],n=A[8],s=A[12],r=A[1],o=A[5],a=A[9],c=A[13],l=A[2],h=A[6],u=A[10],d=A[14],g=A[3],C=A[7],p=A[11],f=A[15];return g*(+s*a*h-n*c*h-s*o*u+t*c*u+n*o*d-t*a*d)+C*(+e*a*d-e*c*u+s*r*u-n*r*d+n*c*l-s*a*l)+p*(+e*c*h-e*o*d-s*r*h+t*r*d+s*o*l-t*c*l)+f*(-n*o*l-e*a*h+e*o*u+n*r*h-t*r*u+t*a*l)}transpose(){const A=this.elements;let e;return e=A[1],A[1]=A[4],A[4]=e,e=A[2],A[2]=A[8],A[8]=e,e=A[6],A[6]=A[9],A[9]=e,e=A[3],A[3]=A[12],A[12]=e,e=A[7],A[7]=A[13],A[13]=e,e=A[11],A[11]=A[14],A[14]=e,this}setPosition(A,e,t){const n=this.elements;return A.isVector3?(n[12]=A.x,n[13]=A.y,n[14]=A.z):(n[12]=A,n[13]=e,n[14]=t),this}invert(){const A=this.elements,e=A[0],t=A[1],n=A[2],s=A[3],r=A[4],o=A[5],a=A[6],c=A[7],l=A[8],h=A[9],u=A[10],d=A[11],g=A[12],C=A[13],p=A[14],f=A[15],E=h*p*c-C*u*c+C*a*d-o*p*d-h*a*f+o*u*f,I=g*u*c-l*p*c-g*a*d+r*p*d+l*a*f-r*u*f,x=l*C*c-g*h*c+g*o*d-r*C*d-l*o*f+r*h*f,z=g*h*a-l*C*a-g*o*u+r*C*u+l*o*p-r*h*p,D=e*E+t*I+n*x+s*z;if(D===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const y=1/D;return A[0]=E*y,A[1]=(C*u*s-h*p*s-C*n*d+t*p*d+h*n*f-t*u*f)*y,A[2]=(o*p*s-C*a*s+C*n*c-t*p*c-o*n*f+t*a*f)*y,A[3]=(h*a*s-o*u*s-h*n*c+t*u*c+o*n*d-t*a*d)*y,A[4]=I*y,A[5]=(l*p*s-g*u*s+g*n*d-e*p*d-l*n*f+e*u*f)*y,A[6]=(g*a*s-r*p*s-g*n*c+e*p*c+r*n*f-e*a*f)*y,A[7]=(r*u*s-l*a*s+l*n*c-e*u*c-r*n*d+e*a*d)*y,A[8]=x*y,A[9]=(g*h*s-l*C*s-g*t*d+e*C*d+l*t*f-e*h*f)*y,A[10]=(r*C*s-g*o*s+g*t*c-e*C*c-r*t*f+e*o*f)*y,A[11]=(l*o*s-r*h*s-l*t*c+e*h*c+r*t*d-e*o*d)*y,A[12]=z*y,A[13]=(l*C*n-g*h*n+g*t*u-e*C*u-l*t*p+e*h*p)*y,A[14]=(g*o*n-r*C*n-g*t*a+e*C*a+r*t*p-e*o*p)*y,A[15]=(r*h*n-l*o*n+l*t*a-e*h*a-r*t*u+e*o*u)*y,this}scale(A){const e=this.elements,t=A.x,n=A.y,s=A.z;return e[0]*=t,e[4]*=n,e[8]*=s,e[1]*=t,e[5]*=n,e[9]*=s,e[2]*=t,e[6]*=n,e[10]*=s,e[3]*=t,e[7]*=n,e[11]*=s,this}getMaxScaleOnAxis(){const A=this.elements,e=A[0]*A[0]+A[1]*A[1]+A[2]*A[2],t=A[4]*A[4]+A[5]*A[5]+A[6]*A[6],n=A[8]*A[8]+A[9]*A[9]+A[10]*A[10];return Math.sqrt(Math.max(e,t,n))}makeTranslation(A,e,t){return A.isVector3?this.set(1,0,0,A.x,0,1,0,A.y,0,0,1,A.z,0,0,0,1):this.set(1,0,0,A,0,1,0,e,0,0,1,t,0,0,0,1),this}makeRotationX(A){const e=Math.cos(A),t=Math.sin(A);return this.set(1,0,0,0,0,e,-t,0,0,t,e,0,0,0,0,1),this}makeRotationY(A){const e=Math.cos(A),t=Math.sin(A);return this.set(e,0,t,0,0,1,0,0,-t,0,e,0,0,0,0,1),this}makeRotationZ(A){const e=Math.cos(A),t=Math.sin(A);return this.set(e,-t,0,0,t,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(A,e){const t=Math.cos(e),n=Math.sin(e),s=1-t,r=A.x,o=A.y,a=A.z,c=s*r,l=s*o;return this.set(c*r+t,c*o-n*a,c*a+n*o,0,c*o+n*a,l*o+t,l*a-n*r,0,c*a-n*o,l*a+n*r,s*a*a+t,0,0,0,0,1),this}makeScale(A,e,t){return this.set(A,0,0,0,0,e,0,0,0,0,t,0,0,0,0,1),this}makeShear(A,e,t,n,s,r){return this.set(1,t,s,0,A,1,r,0,e,n,1,0,0,0,0,1),this}compose(A,e,t){const n=this.elements,s=e._x,r=e._y,o=e._z,a=e._w,c=s+s,l=r+r,h=o+o,u=s*c,d=s*l,g=s*h,C=r*l,p=r*h,f=o*h,E=a*c,I=a*l,x=a*h,z=t.x,D=t.y,y=t.z;return n[0]=(1-(C+f))*z,n[1]=(d+x)*z,n[2]=(g-I)*z,n[3]=0,n[4]=(d-x)*D,n[5]=(1-(u+f))*D,n[6]=(p+E)*D,n[7]=0,n[8]=(g+I)*y,n[9]=(p-E)*y,n[10]=(1-(u+C))*y,n[11]=0,n[12]=A.x,n[13]=A.y,n[14]=A.z,n[15]=1,this}decompose(A,e,t){const n=this.elements;let s=rn.set(n[0],n[1],n[2]).length();const r=rn.set(n[4],n[5],n[6]).length(),o=rn.set(n[8],n[9],n[10]).length();this.determinant()<0&&(s=-s),A.x=n[12],A.y=n[13],A.z=n[14],Oe.copy(this);const c=1/s,l=1/r,h=1/o;return Oe.elements[0]*=c,Oe.elements[1]*=c,Oe.elements[2]*=c,Oe.elements[4]*=l,Oe.elements[5]*=l,Oe.elements[6]*=l,Oe.elements[8]*=h,Oe.elements[9]*=h,Oe.elements[10]*=h,e.setFromRotationMatrix(Oe),t.x=s,t.y=r,t.z=o,this}makePerspective(A,e,t,n,s,r,o=lt){const a=this.elements,c=2*s/(e-A),l=2*s/(t-n),h=(e+A)/(e-A),u=(t+n)/(t-n);let d,g;if(o===lt)d=-(r+s)/(r-s),g=-2*r*s/(r-s);else if(o===Xi)d=-r/(r-s),g=-r*s/(r-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return a[0]=c,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=l,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=g,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(A,e,t,n,s,r,o=lt){const a=this.elements,c=1/(e-A),l=1/(t-n),h=1/(r-s),u=(e+A)*c,d=(t+n)*l;let g,C;if(o===lt)g=(r+s)*h,C=-2*h;else if(o===Xi)g=s*h,C=-1*h;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return a[0]=2*c,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=C,a[14]=-g,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(A){const e=this.elements,t=A.elements;for(let n=0;n<16;n++)if(e[n]!==t[n])return!1;return!0}fromArray(A,e=0){for(let t=0;t<16;t++)this.elements[t]=A[t+e];return this}toArray(A=[],e=0){const t=this.elements;return A[e]=t[0],A[e+1]=t[1],A[e+2]=t[2],A[e+3]=t[3],A[e+4]=t[4],A[e+5]=t[5],A[e+6]=t[6],A[e+7]=t[7],A[e+8]=t[8],A[e+9]=t[9],A[e+10]=t[10],A[e+11]=t[11],A[e+12]=t[12],A[e+13]=t[13],A[e+14]=t[14],A[e+15]=t[15],A}}const rn=new S,Oe=new RA,$l=new S(0,0,0),Ah=new S(1,1,1),Pt=new S,mi=new S,De=new S,lo=new RA,ho=new Be;class Je{constructor(A=0,e=0,t=0,n=Je.DEFAULT_ORDER){this.isEuler=!0,this._x=A,this._y=e,this._z=t,this._order=n}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get order(){return this._order}set order(A){this._order=A,this._onChangeCallback()}set(A,e,t,n=this._order){return this._x=A,this._y=e,this._z=t,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(A){return this._x=A._x,this._y=A._y,this._z=A._z,this._order=A._order,this._onChangeCallback(),this}setFromRotationMatrix(A,e=this._order,t=!0){const n=A.elements,s=n[0],r=n[4],o=n[8],a=n[1],c=n[5],l=n[9],h=n[2],u=n[6],d=n[10];switch(e){case"XYZ":this._y=Math.asin(de(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-l,d),this._z=Math.atan2(-r,s)):(this._x=Math.atan2(u,c),this._z=0);break;case"YXZ":this._x=Math.asin(-de(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(o,d),this._z=Math.atan2(a,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(de(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-r,c)):(this._y=0,this._z=Math.atan2(a,s));break;case"ZYX":this._y=Math.asin(-de(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(a,s)):(this._x=0,this._z=Math.atan2(-r,c));break;case"YZX":this._z=Math.asin(de(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-l,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-de(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(u,c),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-l,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,t===!0&&this._onChangeCallback(),this}setFromQuaternion(A,e,t){return lo.makeRotationFromQuaternion(A),this.setFromRotationMatrix(lo,e,t)}setFromVector3(A,e=this._order){return this.set(A.x,A.y,A.z,e)}reorder(A){return ho.setFromEuler(this),this.setFromQuaternion(ho,A)}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._order===this._order}fromArray(A){return this._x=A[0],this._y=A[1],this._z=A[2],A[3]!==void 0&&(this._order=A[3]),this._onChangeCallback(),this}toArray(A=[],e=0){return A[e]=this._x,A[e+1]=this._y,A[e+2]=this._z,A[e+3]=this._order,A}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Je.DEFAULT_ORDER="XYZ";class ka{constructor(){this.mask=1}set(A){this.mask=(1<<A|0)>>>0}enable(A){this.mask|=1<<A|0}enableAll(){this.mask=-1}toggle(A){this.mask^=1<<A|0}disable(A){this.mask&=~(1<<A|0)}disableAll(){this.mask=0}test(A){return(this.mask&A.mask)!==0}isEnabled(A){return(this.mask&(1<<A|0))!==0}}let eh=0;const uo=new S,on=new Be,it=new RA,Ci=new S,Vn=new S,th=new S,nh=new Be,fo=new S(1,0,0),po=new S(0,1,0),go=new S(0,0,1),mo={type:"added"},ih={type:"removed"},an={type:"childadded",child:null},Is={type:"childremoved",child:null};class ie extends _t{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:eh++}),this.uuid=He(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=ie.DEFAULT_UP.clone();const A=new S,e=new Je,t=new Be,n=new S(1,1,1);function s(){t.setFromEuler(e,!1)}function r(){e.setFromQuaternion(t,void 0,!1)}e._onChange(s),t._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:A},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:t},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new RA},normalMatrix:{value:new BA}}),this.matrix=new RA,this.matrixWorld=new RA,this.matrixAutoUpdate=ie.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=ie.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new ka,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(A){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(A),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(A){return this.quaternion.premultiply(A),this}setRotationFromAxisAngle(A,e){this.quaternion.setFromAxisAngle(A,e)}setRotationFromEuler(A){this.quaternion.setFromEuler(A,!0)}setRotationFromMatrix(A){this.quaternion.setFromRotationMatrix(A)}setRotationFromQuaternion(A){this.quaternion.copy(A)}rotateOnAxis(A,e){return on.setFromAxisAngle(A,e),this.quaternion.multiply(on),this}rotateOnWorldAxis(A,e){return on.setFromAxisAngle(A,e),this.quaternion.premultiply(on),this}rotateX(A){return this.rotateOnAxis(fo,A)}rotateY(A){return this.rotateOnAxis(po,A)}rotateZ(A){return this.rotateOnAxis(go,A)}translateOnAxis(A,e){return uo.copy(A).applyQuaternion(this.quaternion),this.position.add(uo.multiplyScalar(e)),this}translateX(A){return this.translateOnAxis(fo,A)}translateY(A){return this.translateOnAxis(po,A)}translateZ(A){return this.translateOnAxis(go,A)}localToWorld(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(this.matrixWorld)}worldToLocal(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(it.copy(this.matrixWorld).invert())}lookAt(A,e,t){A.isVector3?Ci.copy(A):Ci.set(A,e,t);const n=this.parent;this.updateWorldMatrix(!0,!1),Vn.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?it.lookAt(Vn,Ci,this.up):it.lookAt(Ci,Vn,this.up),this.quaternion.setFromRotationMatrix(it),n&&(it.extractRotation(n.matrixWorld),on.setFromRotationMatrix(it),this.quaternion.premultiply(on.invert()))}add(A){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return A===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",A),this):(A&&A.isObject3D?(A.removeFromParent(),A.parent=this,this.children.push(A),A.dispatchEvent(mo),an.child=A,this.dispatchEvent(an),an.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",A),this)}remove(A){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(A);return e!==-1&&(A.parent=null,this.children.splice(e,1),A.dispatchEvent(ih),Is.child=A,this.dispatchEvent(Is),Is.child=null),this}removeFromParent(){const A=this.parent;return A!==null&&A.remove(this),this}clear(){return this.remove(...this.children)}attach(A){return this.updateWorldMatrix(!0,!1),it.copy(this.matrixWorld).invert(),A.parent!==null&&(A.parent.updateWorldMatrix(!0,!1),it.multiply(A.parent.matrixWorld)),A.applyMatrix4(it),A.removeFromParent(),A.parent=this,this.children.push(A),A.updateWorldMatrix(!1,!0),A.dispatchEvent(mo),an.child=A,this.dispatchEvent(an),an.child=null,this}getObjectById(A){return this.getObjectByProperty("id",A)}getObjectByName(A){return this.getObjectByProperty("name",A)}getObjectByProperty(A,e){if(this[A]===e)return this;for(let t=0,n=this.children.length;t<n;t++){const r=this.children[t].getObjectByProperty(A,e);if(r!==void 0)return r}}getObjectsByProperty(A,e,t=[]){this[A]===e&&t.push(this);const n=this.children;for(let s=0,r=n.length;s<r;s++)n[s].getObjectsByProperty(A,e,t);return t}getWorldPosition(A){return this.updateWorldMatrix(!0,!1),A.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Vn,A,th),A}getWorldScale(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Vn,nh,A),A}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return A.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(A){A(this);const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].traverse(A)}traverseVisible(A){if(this.visible===!1)return;A(this);const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].traverseVisible(A)}traverseAncestors(A){const e=this.parent;e!==null&&(A(e),e.traverseAncestors(A))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(A){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||A)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,A=!0);const e=this.children;for(let t=0,n=e.length;t<n;t++){const s=e[t];(s.matrixWorldAutoUpdate===!0||A===!0)&&s.updateMatrixWorld(A)}}updateWorldMatrix(A,e){const t=this.parent;if(A===!0&&t!==null&&t.matrixWorldAutoUpdate===!0&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const n=this.children;for(let s=0,r=n.length;s<r;s++){const o=n[s];o.matrixWorldAutoUpdate===!0&&o.updateWorldMatrix(!1,!0)}}}toJSON(A){const e=A===void 0||typeof A=="string",t={};e&&(A={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},t.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.visibility=this._visibility,n.active=this._active,n.bounds=this._bounds.map(o=>({boxInitialized:o.boxInitialized,boxMin:o.box.min.toArray(),boxMax:o.box.max.toArray(),sphereInitialized:o.sphereInitialized,sphereRadius:o.sphere.radius,sphereCenter:o.sphere.center.toArray()})),n.maxGeometryCount=this._maxGeometryCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.geometryCount=this._geometryCount,n.matricesTexture=this._matricesTexture.toJSON(A),this.boundingSphere!==null&&(n.boundingSphere={center:n.boundingSphere.center.toArray(),radius:n.boundingSphere.radius}),this.boundingBox!==null&&(n.boundingBox={min:n.boundingBox.min.toArray(),max:n.boundingBox.max.toArray()}));function s(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(A)),a.uuid}if(this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(A).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(n.environment=this.environment.toJSON(A).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=s(A.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let c=0,l=a.length;c<l;c++){const h=a[c];s(A.shapes,h)}else s(A.shapes,a)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(A.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,c=this.material.length;a<c;a++)o.push(s(A.materials,this.material[a]));n.material=o}else n.material=s(A.materials,this.material);if(this.children.length>0){n.children=[];for(let o=0;o<this.children.length;o++)n.children.push(this.children[o].toJSON(A).object)}if(this.animations.length>0){n.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];n.animations.push(s(A.animations,a))}}if(e){const o=r(A.geometries),a=r(A.materials),c=r(A.textures),l=r(A.images),h=r(A.shapes),u=r(A.skeletons),d=r(A.animations),g=r(A.nodes);o.length>0&&(t.geometries=o),a.length>0&&(t.materials=a),c.length>0&&(t.textures=c),l.length>0&&(t.images=l),h.length>0&&(t.shapes=h),u.length>0&&(t.skeletons=u),d.length>0&&(t.animations=d),g.length>0&&(t.nodes=g)}return t.object=n,t;function r(o){const a=[];for(const c in o){const l=o[c];delete l.metadata,a.push(l)}return a}}clone(A){return new this.constructor().copy(this,A)}copy(A,e=!0){if(this.name=A.name,this.up.copy(A.up),this.position.copy(A.position),this.rotation.order=A.rotation.order,this.quaternion.copy(A.quaternion),this.scale.copy(A.scale),this.matrix.copy(A.matrix),this.matrixWorld.copy(A.matrixWorld),this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrixWorldAutoUpdate=A.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=A.matrixWorldNeedsUpdate,this.layers.mask=A.layers.mask,this.visible=A.visible,this.castShadow=A.castShadow,this.receiveShadow=A.receiveShadow,this.frustumCulled=A.frustumCulled,this.renderOrder=A.renderOrder,this.animations=A.animations.slice(),this.userData=JSON.parse(JSON.stringify(A.userData)),e===!0)for(let t=0;t<A.children.length;t++){const n=A.children[t];this.add(n.clone())}return this}}ie.DEFAULT_UP=new S(0,1,0);ie.DEFAULT_MATRIX_AUTO_UPDATE=!0;ie.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Fe=new S,st=new S,vs=new S,rt=new S,cn=new S,ln=new S,Co=new S,Es=new S,xs=new S,Ts=new S;class Xe{constructor(A=new S,e=new S,t=new S){this.a=A,this.b=e,this.c=t}static getNormal(A,e,t,n){n.subVectors(t,e),Fe.subVectors(A,e),n.cross(Fe);const s=n.lengthSq();return s>0?n.multiplyScalar(1/Math.sqrt(s)):n.set(0,0,0)}static getBarycoord(A,e,t,n,s){Fe.subVectors(n,e),st.subVectors(t,e),vs.subVectors(A,e);const r=Fe.dot(Fe),o=Fe.dot(st),a=Fe.dot(vs),c=st.dot(st),l=st.dot(vs),h=r*c-o*o;if(h===0)return s.set(0,0,0),null;const u=1/h,d=(c*a-o*l)*u,g=(r*l-o*a)*u;return s.set(1-d-g,g,d)}static containsPoint(A,e,t,n){return this.getBarycoord(A,e,t,n,rt)===null?!1:rt.x>=0&&rt.y>=0&&rt.x+rt.y<=1}static getInterpolation(A,e,t,n,s,r,o,a){return this.getBarycoord(A,e,t,n,rt)===null?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(s,rt.x),a.addScaledVector(r,rt.y),a.addScaledVector(o,rt.z),a)}static isFrontFacing(A,e,t,n){return Fe.subVectors(t,e),st.subVectors(A,e),Fe.cross(st).dot(n)<0}set(A,e,t){return this.a.copy(A),this.b.copy(e),this.c.copy(t),this}setFromPointsAndIndices(A,e,t,n){return this.a.copy(A[e]),this.b.copy(A[t]),this.c.copy(A[n]),this}setFromAttributeAndIndices(A,e,t,n){return this.a.fromBufferAttribute(A,e),this.b.fromBufferAttribute(A,t),this.c.fromBufferAttribute(A,n),this}clone(){return new this.constructor().copy(this)}copy(A){return this.a.copy(A.a),this.b.copy(A.b),this.c.copy(A.c),this}getArea(){return Fe.subVectors(this.c,this.b),st.subVectors(this.a,this.b),Fe.cross(st).length()*.5}getMidpoint(A){return A.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(A){return Xe.getNormal(this.a,this.b,this.c,A)}getPlane(A){return A.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(A,e){return Xe.getBarycoord(A,this.a,this.b,this.c,e)}getInterpolation(A,e,t,n,s){return Xe.getInterpolation(A,this.a,this.b,this.c,e,t,n,s)}containsPoint(A){return Xe.containsPoint(A,this.a,this.b,this.c)}isFrontFacing(A){return Xe.isFrontFacing(this.a,this.b,this.c,A)}intersectsBox(A){return A.intersectsTriangle(this)}closestPointToPoint(A,e){const t=this.a,n=this.b,s=this.c;let r,o;cn.subVectors(n,t),ln.subVectors(s,t),Es.subVectors(A,t);const a=cn.dot(Es),c=ln.dot(Es);if(a<=0&&c<=0)return e.copy(t);xs.subVectors(A,n);const l=cn.dot(xs),h=ln.dot(xs);if(l>=0&&h<=l)return e.copy(n);const u=a*h-l*c;if(u<=0&&a>=0&&l<=0)return r=a/(a-l),e.copy(t).addScaledVector(cn,r);Ts.subVectors(A,s);const d=cn.dot(Ts),g=ln.dot(Ts);if(g>=0&&d<=g)return e.copy(s);const C=d*c-a*g;if(C<=0&&c>=0&&g<=0)return o=c/(c-g),e.copy(t).addScaledVector(ln,o);const p=l*g-d*h;if(p<=0&&h-l>=0&&d-g>=0)return Co.subVectors(s,n),o=(h-l)/(h-l+(d-g)),e.copy(n).addScaledVector(Co,o);const f=1/(p+C+u);return r=C*f,o=u*f,e.copy(t).addScaledVector(cn,r).addScaledVector(ln,o)}equals(A){return A.a.equals(this.a)&&A.b.equals(this.b)&&A.c.equals(this.c)}}const Va={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},wt={h:0,s:0,l:0},Mi={h:0,s:0,l:0};function ys(i,A,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?i+(A-i)*6*e:e<1/2?A:e<2/3?i+(A-i)*6*(2/3-e):i}class wA{constructor(A,e,t){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(A,e,t)}set(A,e,t){if(e===void 0&&t===void 0){const n=A;n&&n.isColor?this.copy(n):typeof n=="number"?this.setHex(n):typeof n=="string"&&this.setStyle(n)}else this.setRGB(A,e,t);return this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,e=Me){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,WA.toWorkingColorSpace(this,e),this}setRGB(A,e,t,n=WA.workingColorSpace){return this.r=A,this.g=e,this.b=t,WA.toWorkingColorSpace(this,n),this}setHSL(A,e,t,n=WA.workingColorSpace){if(A=cr(A,1),e=de(e,0,1),t=de(t,0,1),e===0)this.r=this.g=this.b=t;else{const s=t<=.5?t*(1+e):t+e-t*e,r=2*t-s;this.r=ys(r,s,A+1/3),this.g=ys(r,s,A),this.b=ys(r,s,A-1/3)}return WA.toWorkingColorSpace(this,n),this}setStyle(A,e=Me){function t(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(A)){let s;const r=n[1],o=n[2];switch(r){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return t(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,e);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return t(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,e);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return t(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(A)){const s=n[1],r=s.length;if(r===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,e);if(r===6)return this.setHex(parseInt(s,16),e);console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,e);return this}setColorName(A,e=Me){const t=Va[A.toLowerCase()];return t!==void 0?this.setHex(t,e):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=En(A.r),this.g=En(A.g),this.b=En(A.b),this}copyLinearToSRGB(A){return this.r=fs(A.r),this.g=fs(A.g),this.b=fs(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=Me){return WA.fromWorkingColorSpace(Ce.copy(this),A),Math.round(de(Ce.r*255,0,255))*65536+Math.round(de(Ce.g*255,0,255))*256+Math.round(de(Ce.b*255,0,255))}getHexString(A=Me){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,e=WA.workingColorSpace){WA.fromWorkingColorSpace(Ce.copy(this),e);const t=Ce.r,n=Ce.g,s=Ce.b,r=Math.max(t,n,s),o=Math.min(t,n,s);let a,c;const l=(o+r)/2;if(o===r)a=0,c=0;else{const h=r-o;switch(c=l<=.5?h/(r+o):h/(2-r-o),r){case t:a=(n-s)/h+(n<s?6:0);break;case n:a=(s-t)/h+2;break;case s:a=(t-n)/h+4;break}a/=6}return A.h=a,A.s=c,A.l=l,A}getRGB(A,e=WA.workingColorSpace){return WA.fromWorkingColorSpace(Ce.copy(this),e),A.r=Ce.r,A.g=Ce.g,A.b=Ce.b,A}getStyle(A=Me){WA.fromWorkingColorSpace(Ce.copy(this),A);const e=Ce.r,t=Ce.g,n=Ce.b;return A!==Me?`color(${A} ${e.toFixed(3)} ${t.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(t*255)},${Math.round(n*255)})`}offsetHSL(A,e,t){return this.getHSL(wt),this.setHSL(wt.h+A,wt.s+e,wt.l+t)}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,e){return this.r=A.r+e.r,this.g=A.g+e.g,this.b=A.b+e.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,e){return this.r+=(A.r-this.r)*e,this.g+=(A.g-this.g)*e,this.b+=(A.b-this.b)*e,this}lerpColors(A,e,t){return this.r=A.r+(e.r-A.r)*t,this.g=A.g+(e.g-A.g)*t,this.b=A.b+(e.b-A.b)*t,this}lerpHSL(A,e){this.getHSL(wt),A.getHSL(Mi);const t=Ai(wt.h,Mi.h,e),n=Ai(wt.s,Mi.s,e),s=Ai(wt.l,Mi.l,e);return this.setHSL(t,n,s),this}setFromVector3(A){return this.r=A.x,this.g=A.y,this.b=A.z,this}applyMatrix3(A){const e=this.r,t=this.g,n=this.b,s=A.elements;return this.r=s[0]*e+s[3]*t+s[6]*n,this.g=s[1]*e+s[4]*t+s[7]*n,this.b=s[2]*e+s[5]*t+s[8]*n,this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,e=0){return this.r=A[e],this.g=A[e+1],this.b=A[e+2],this}toArray(A=[],e=0){return A[e]=this.r,A[e+1]=this.g,A[e+2]=this.b,A}fromBufferAttribute(A,e){return this.r=A.getX(e),this.g=A.getY(e),this.b=A.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Ce=new wA;wA.NAMES=Va;let sh=0;class ke extends _t{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:sh++}),this.uuid=He(),this.name="",this.type="Material",this.blending=In,this.side=ht,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Zs,this.blendDst=Xs,this.blendEquation=Vt,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new wA(0,0,0),this.blendAlpha=0,this.depthFunc=Hi,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=no,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=An,this.stencilZFail=An,this.stencilZPass=An,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(A){this._alphaTest>0!=A>0&&this.version++,this._alphaTest=A}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(A){if(A!==void 0)for(const e in A){const t=A[e];if(t===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const n=this[e];if(n===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}n&&n.isColor?n.set(t):n&&n.isVector3&&t&&t.isVector3?n.copy(t):this[e]=t}}toJSON(A){const e=A===void 0||typeof A=="string";e&&(A={textures:{},images:{}});const t={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen!==void 0&&(t.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(t.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(t.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(t.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(t.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(A).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(A).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(A).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(t.dispersion=this.dispersion),this.iridescence!==void 0&&(t.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(t.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(t.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(t.iridescenceMap=this.iridescenceMap.toJSON(A).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(t.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(A).uuid),this.anisotropy!==void 0&&(t.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(t.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(t.anisotropyMap=this.anisotropyMap.toJSON(A).uuid),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(A).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(A).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(A).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(A).uuid,t.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(A).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(A).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(A).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(A).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(A).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(A).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(A).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(A).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(t.specularIntensityMap=this.specularIntensityMap.toJSON(A).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(t.specularColorMap=this.specularColorMap.toJSON(A).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(A).uuid,this.combine!==void 0&&(t.combine=this.combine)),this.envMapRotation!==void 0&&(t.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(t.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(t.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(A).uuid),this.transmission!==void 0&&(t.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(t.transmissionMap=this.transmissionMap.toJSON(A).uuid),this.thickness!==void 0&&(t.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(t.thicknessMap=this.thicknessMap.toJSON(A).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(t.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(t.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(t.size=this.size),this.shadowSide!==null&&(t.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==In&&(t.blending=this.blending),this.side!==ht&&(t.side=this.side),this.vertexColors===!0&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=!0),this.blendSrc!==Zs&&(t.blendSrc=this.blendSrc),this.blendDst!==Xs&&(t.blendDst=this.blendDst),this.blendEquation!==Vt&&(t.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(t.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(t.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(t.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(t.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(t.blendAlpha=this.blendAlpha),this.depthFunc!==Hi&&(t.depthFunc=this.depthFunc),this.depthTest===!1&&(t.depthTest=this.depthTest),this.depthWrite===!1&&(t.depthWrite=this.depthWrite),this.colorWrite===!1&&(t.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(t.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==no&&(t.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(t.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(t.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==An&&(t.stencilFail=this.stencilFail),this.stencilZFail!==An&&(t.stencilZFail=this.stencilZFail),this.stencilZPass!==An&&(t.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(t.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.alphaHash===!0&&(t.alphaHash=!0),this.alphaToCoverage===!0&&(t.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=!0),this.forceSinglePass===!0&&(t.forceSinglePass=!0),this.wireframe===!0&&(t.wireframe=!0),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(t.flatShading=!0),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),this.fog===!1&&(t.fog=!1),Object.keys(this.userData).length>0&&(t.userData=this.userData);function n(s){const r=[];for(const o in s){const a=s[o];delete a.metadata,r.push(a)}return r}if(e){const s=n(A.textures),r=n(A.images);s.length>0&&(t.textures=s),r.length>0&&(t.images=r)}return t}clone(){return new this.constructor().copy(this)}copy(A){this.name=A.name,this.blending=A.blending,this.side=A.side,this.vertexColors=A.vertexColors,this.opacity=A.opacity,this.transparent=A.transparent,this.blendSrc=A.blendSrc,this.blendDst=A.blendDst,this.blendEquation=A.blendEquation,this.blendSrcAlpha=A.blendSrcAlpha,this.blendDstAlpha=A.blendDstAlpha,this.blendEquationAlpha=A.blendEquationAlpha,this.blendColor.copy(A.blendColor),this.blendAlpha=A.blendAlpha,this.depthFunc=A.depthFunc,this.depthTest=A.depthTest,this.depthWrite=A.depthWrite,this.stencilWriteMask=A.stencilWriteMask,this.stencilFunc=A.stencilFunc,this.stencilRef=A.stencilRef,this.stencilFuncMask=A.stencilFuncMask,this.stencilFail=A.stencilFail,this.stencilZFail=A.stencilZFail,this.stencilZPass=A.stencilZPass,this.stencilWrite=A.stencilWrite;const e=A.clippingPlanes;let t=null;if(e!==null){const n=e.length;t=new Array(n);for(let s=0;s!==n;++s)t[s]=e[s].clone()}return this.clippingPlanes=t,this.clipIntersection=A.clipIntersection,this.clipShadows=A.clipShadows,this.shadowSide=A.shadowSide,this.colorWrite=A.colorWrite,this.precision=A.precision,this.polygonOffset=A.polygonOffset,this.polygonOffsetFactor=A.polygonOffsetFactor,this.polygonOffsetUnits=A.polygonOffsetUnits,this.dithering=A.dithering,this.alphaTest=A.alphaTest,this.alphaHash=A.alphaHash,this.alphaToCoverage=A.alphaToCoverage,this.premultipliedAlpha=A.premultipliedAlpha,this.forceSinglePass=A.forceSinglePass,this.visible=A.visible,this.toneMapped=A.toneMapped,this.userData=JSON.parse(JSON.stringify(A.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(A){A===!0&&this.version++}}class Wt extends ke{constructor(A){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new wA(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Je,this.combine=xa,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.envMapRotation.copy(A.envMapRotation),this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.fog=A.fog,this}}const oe=new S,Pi=new MA;class xe{constructor(A,e,t=!1){if(Array.isArray(A))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=A,this.itemSize=e,this.count=A!==void 0?A.length/e:0,this.normalized=t,this.usage=qs,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=Ye,this.version=0}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}get updateRange(){return Qa("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(A){return this.usage=A,this}addUpdateRange(A,e){this.updateRanges.push({start:A,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(A){return this.name=A.name,this.array=new A.array.constructor(A.array),this.itemSize=A.itemSize,this.count=A.count,this.normalized=A.normalized,this.usage=A.usage,this.gpuType=A.gpuType,this}copyAt(A,e,t){A*=this.itemSize,t*=e.itemSize;for(let n=0,s=this.itemSize;n<s;n++)this.array[A+n]=e.array[t+n];return this}copyArray(A){return this.array.set(A),this}applyMatrix3(A){if(this.itemSize===2)for(let e=0,t=this.count;e<t;e++)Pi.fromBufferAttribute(this,e),Pi.applyMatrix3(A),this.setXY(e,Pi.x,Pi.y);else if(this.itemSize===3)for(let e=0,t=this.count;e<t;e++)oe.fromBufferAttribute(this,e),oe.applyMatrix3(A),this.setXYZ(e,oe.x,oe.y,oe.z);return this}applyMatrix4(A){for(let e=0,t=this.count;e<t;e++)oe.fromBufferAttribute(this,e),oe.applyMatrix4(A),this.setXYZ(e,oe.x,oe.y,oe.z);return this}applyNormalMatrix(A){for(let e=0,t=this.count;e<t;e++)oe.fromBufferAttribute(this,e),oe.applyNormalMatrix(A),this.setXYZ(e,oe.x,oe.y,oe.z);return this}transformDirection(A){for(let e=0,t=this.count;e<t;e++)oe.fromBufferAttribute(this,e),oe.transformDirection(A),this.setXYZ(e,oe.x,oe.y,oe.z);return this}set(A,e=0){return this.array.set(A,e),this}getComponent(A,e){let t=this.array[A*this.itemSize+e];return this.normalized&&(t=Qe(t,this.array)),t}setComponent(A,e,t){return this.normalized&&(t=XA(t,this.array)),this.array[A*this.itemSize+e]=t,this}getX(A){let e=this.array[A*this.itemSize];return this.normalized&&(e=Qe(e,this.array)),e}setX(A,e){return this.normalized&&(e=XA(e,this.array)),this.array[A*this.itemSize]=e,this}getY(A){let e=this.array[A*this.itemSize+1];return this.normalized&&(e=Qe(e,this.array)),e}setY(A,e){return this.normalized&&(e=XA(e,this.array)),this.array[A*this.itemSize+1]=e,this}getZ(A){let e=this.array[A*this.itemSize+2];return this.normalized&&(e=Qe(e,this.array)),e}setZ(A,e){return this.normalized&&(e=XA(e,this.array)),this.array[A*this.itemSize+2]=e,this}getW(A){let e=this.array[A*this.itemSize+3];return this.normalized&&(e=Qe(e,this.array)),e}setW(A,e){return this.normalized&&(e=XA(e,this.array)),this.array[A*this.itemSize+3]=e,this}setXY(A,e,t){return A*=this.itemSize,this.normalized&&(e=XA(e,this.array),t=XA(t,this.array)),this.array[A+0]=e,this.array[A+1]=t,this}setXYZ(A,e,t,n){return A*=this.itemSize,this.normalized&&(e=XA(e,this.array),t=XA(t,this.array),n=XA(n,this.array)),this.array[A+0]=e,this.array[A+1]=t,this.array[A+2]=n,this}setXYZW(A,e,t,n,s){return A*=this.itemSize,this.normalized&&(e=XA(e,this.array),t=XA(t,this.array),n=XA(n,this.array),s=XA(s,this.array)),this.array[A+0]=e,this.array[A+1]=t,this.array[A+2]=n,this.array[A+3]=s,this}onUpload(A){return this.onUploadCallback=A,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const A={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(A.name=this.name),this.usage!==qs&&(A.usage=this.usage),A}}class Ga extends xe{constructor(A,e,t){super(new Uint16Array(A),e,t)}}class Wa extends xe{constructor(A,e,t){super(new Uint32Array(A),e,t)}}class Ne extends xe{constructor(A,e,t){super(new Float32Array(A),e,t)}}let rh=0;const _e=new RA,Ds=new ie,hn=new S,Se=new ut,Gn=new ut,he=new S;class Ve extends _t{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:rh++}),this.uuid=He(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(A){return Array.isArray(A)?this.index=new(Fa(A)?Wa:Ga)(A,1):this.index=A,this}getAttribute(A){return this.attributes[A]}setAttribute(A,e){return this.attributes[A]=e,this}deleteAttribute(A){return delete this.attributes[A],this}hasAttribute(A){return this.attributes[A]!==void 0}addGroup(A,e,t=0){this.groups.push({start:A,count:e,materialIndex:t})}clearGroups(){this.groups=[]}setDrawRange(A,e){this.drawRange.start=A,this.drawRange.count=e}applyMatrix4(A){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(A),e.needsUpdate=!0);const t=this.attributes.normal;if(t!==void 0){const s=new BA().getNormalMatrix(A);t.applyNormalMatrix(s),t.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(A),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(A){return _e.makeRotationFromQuaternion(A),this.applyMatrix4(_e),this}rotateX(A){return _e.makeRotationX(A),this.applyMatrix4(_e),this}rotateY(A){return _e.makeRotationY(A),this.applyMatrix4(_e),this}rotateZ(A){return _e.makeRotationZ(A),this.applyMatrix4(_e),this}translate(A,e,t){return _e.makeTranslation(A,e,t),this.applyMatrix4(_e),this}scale(A,e,t){return _e.makeScale(A,e,t),this.applyMatrix4(_e),this}lookAt(A){return Ds.lookAt(A),Ds.updateMatrix(),this.applyMatrix4(Ds.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(hn).negate(),this.translate(hn.x,hn.y,hn.z),this}setFromPoints(A){const e=[];for(let t=0,n=A.length;t<n;t++){const s=A[t];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new Ne(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ut);const A=this.attributes.position,e=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new S(-1/0,-1/0,-1/0),new S(1/0,1/0,1/0));return}if(A!==void 0){if(this.boundingBox.setFromBufferAttribute(A),e)for(let t=0,n=e.length;t<n;t++){const s=e[t];Se.setFromBufferAttribute(s),this.morphTargetsRelative?(he.addVectors(this.boundingBox.min,Se.min),this.boundingBox.expandByPoint(he),he.addVectors(this.boundingBox.max,Se.max),this.boundingBox.expandByPoint(he)):(this.boundingBox.expandByPoint(Se.min),this.boundingBox.expandByPoint(Se.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ke);const A=this.attributes.position,e=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new S,1/0);return}if(A){const t=this.boundingSphere.center;if(Se.setFromBufferAttribute(A),e)for(let s=0,r=e.length;s<r;s++){const o=e[s];Gn.setFromBufferAttribute(o),this.morphTargetsRelative?(he.addVectors(Se.min,Gn.min),Se.expandByPoint(he),he.addVectors(Se.max,Gn.max),Se.expandByPoint(he)):(Se.expandByPoint(Gn.min),Se.expandByPoint(Gn.max))}Se.getCenter(t);let n=0;for(let s=0,r=A.count;s<r;s++)he.fromBufferAttribute(A,s),n=Math.max(n,t.distanceToSquared(he));if(e)for(let s=0,r=e.length;s<r;s++){const o=e[s],a=this.morphTargetsRelative;for(let c=0,l=o.count;c<l;c++)he.fromBufferAttribute(o,c),a&&(hn.fromBufferAttribute(A,c),he.add(hn)),n=Math.max(n,t.distanceToSquared(he))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const A=this.index,e=this.attributes;if(A===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const t=e.position,n=e.normal,s=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new xe(new Float32Array(4*t.count),4));const r=this.getAttribute("tangent"),o=[],a=[];for(let F=0;F<t.count;F++)o[F]=new S,a[F]=new S;const c=new S,l=new S,h=new S,u=new MA,d=new MA,g=new MA,C=new S,p=new S;function f(F,v,P){c.fromBufferAttribute(t,F),l.fromBufferAttribute(t,v),h.fromBufferAttribute(t,P),u.fromBufferAttribute(s,F),d.fromBufferAttribute(s,v),g.fromBufferAttribute(s,P),l.sub(c),h.sub(c),d.sub(u),g.sub(u);const N=1/(d.x*g.y-g.x*d.y);isFinite(N)&&(C.copy(l).multiplyScalar(g.y).addScaledVector(h,-d.y).multiplyScalar(N),p.copy(h).multiplyScalar(d.x).addScaledVector(l,-g.x).multiplyScalar(N),o[F].add(C),o[v].add(C),o[P].add(C),a[F].add(p),a[v].add(p),a[P].add(p))}let E=this.groups;E.length===0&&(E=[{start:0,count:A.count}]);for(let F=0,v=E.length;F<v;++F){const P=E[F],N=P.start,V=P.count;for(let b=N,W=N+V;b<W;b+=3)f(A.getX(b+0),A.getX(b+1),A.getX(b+2))}const I=new S,x=new S,z=new S,D=new S;function y(F){z.fromBufferAttribute(n,F),D.copy(z);const v=o[F];I.copy(v),I.sub(z.multiplyScalar(z.dot(v))).normalize(),x.crossVectors(D,v);const N=x.dot(a[F])<0?-1:1;r.setXYZW(F,I.x,I.y,I.z,N)}for(let F=0,v=E.length;F<v;++F){const P=E[F],N=P.start,V=P.count;for(let b=N,W=N+V;b<W;b+=3)y(A.getX(b+0)),y(A.getX(b+1)),y(A.getX(b+2))}}computeVertexNormals(){const A=this.index,e=this.getAttribute("position");if(e!==void 0){let t=this.getAttribute("normal");if(t===void 0)t=new xe(new Float32Array(e.count*3),3),this.setAttribute("normal",t);else for(let u=0,d=t.count;u<d;u++)t.setXYZ(u,0,0,0);const n=new S,s=new S,r=new S,o=new S,a=new S,c=new S,l=new S,h=new S;if(A)for(let u=0,d=A.count;u<d;u+=3){const g=A.getX(u+0),C=A.getX(u+1),p=A.getX(u+2);n.fromBufferAttribute(e,g),s.fromBufferAttribute(e,C),r.fromBufferAttribute(e,p),l.subVectors(r,s),h.subVectors(n,s),l.cross(h),o.fromBufferAttribute(t,g),a.fromBufferAttribute(t,C),c.fromBufferAttribute(t,p),o.add(l),a.add(l),c.add(l),t.setXYZ(g,o.x,o.y,o.z),t.setXYZ(C,a.x,a.y,a.z),t.setXYZ(p,c.x,c.y,c.z)}else for(let u=0,d=e.count;u<d;u+=3)n.fromBufferAttribute(e,u+0),s.fromBufferAttribute(e,u+1),r.fromBufferAttribute(e,u+2),l.subVectors(r,s),h.subVectors(n,s),l.cross(h),t.setXYZ(u+0,l.x,l.y,l.z),t.setXYZ(u+1,l.x,l.y,l.z),t.setXYZ(u+2,l.x,l.y,l.z);this.normalizeNormals(),t.needsUpdate=!0}}normalizeNormals(){const A=this.attributes.normal;for(let e=0,t=A.count;e<t;e++)he.fromBufferAttribute(A,e),he.normalize(),A.setXYZ(e,he.x,he.y,he.z)}toNonIndexed(){function A(o,a){const c=o.array,l=o.itemSize,h=o.normalized,u=new c.constructor(a.length*l);let d=0,g=0;for(let C=0,p=a.length;C<p;C++){o.isInterleavedBufferAttribute?d=a[C]*o.data.stride+o.offset:d=a[C]*l;for(let f=0;f<l;f++)u[g++]=c[d++]}return new xe(u,l,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ve,t=this.index.array,n=this.attributes;for(const o in n){const a=n[o],c=A(a,t);e.setAttribute(o,c)}const s=this.morphAttributes;for(const o in s){const a=[],c=s[o];for(let l=0,h=c.length;l<h;l++){const u=c[l],d=A(u,t);a.push(d)}e.morphAttributes[o]=a}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let o=0,a=r.length;o<a;o++){const c=r[o];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const A={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(A.uuid=this.uuid,A.type=this.type,this.name!==""&&(A.name=this.name),Object.keys(this.userData).length>0&&(A.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const c in a)a[c]!==void 0&&(A[c]=a[c]);return A}A.data={attributes:{}};const e=this.index;e!==null&&(A.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const t=this.attributes;for(const a in t){const c=t[a];A.data.attributes[a]=c.toJSON(A.data)}const n={};let s=!1;for(const a in this.morphAttributes){const c=this.morphAttributes[a],l=[];for(let h=0,u=c.length;h<u;h++){const d=c[h];l.push(d.toJSON(A.data))}l.length>0&&(n[a]=l,s=!0)}s&&(A.data.morphAttributes=n,A.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(A.data.groups=JSON.parse(JSON.stringify(r)));const o=this.boundingSphere;return o!==null&&(A.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),A}clone(){return new this.constructor().copy(this)}copy(A){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=A.name;const t=A.index;t!==null&&this.setIndex(t.clone(e));const n=A.attributes;for(const c in n){const l=n[c];this.setAttribute(c,l.clone(e))}const s=A.morphAttributes;for(const c in s){const l=[],h=s[c];for(let u=0,d=h.length;u<d;u++)l.push(h[u].clone(e));this.morphAttributes[c]=l}this.morphTargetsRelative=A.morphTargetsRelative;const r=A.groups;for(let c=0,l=r.length;c<l;c++){const h=r[c];this.addGroup(h.start,h.count,h.materialIndex)}const o=A.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=A.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=A.drawRange.start,this.drawRange.count=A.drawRange.count,this.userData=A.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Mo=new RA,Ot=new ri,wi=new Ke,Po=new S,un=new S,dn=new S,fn=new S,Ss=new S,Ii=new S,vi=new MA,Ei=new MA,xi=new MA,wo=new S,Io=new S,vo=new S,Ti=new S,yi=new S;class Ee extends ie{constructor(A=new Ve,e=new Wt){super(),this.isMesh=!0,this.type="Mesh",this.geometry=A,this.material=e,this.updateMorphTargets()}copy(A,e){return super.copy(A,e),A.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=A.morphTargetInfluences.slice()),A.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},A.morphTargetDictionary)),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,r=n.length;s<r;s++){const o=n[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}getVertexPosition(A,e){const t=this.geometry,n=t.attributes.position,s=t.morphAttributes.position,r=t.morphTargetsRelative;e.fromBufferAttribute(n,A);const o=this.morphTargetInfluences;if(s&&o){Ii.set(0,0,0);for(let a=0,c=s.length;a<c;a++){const l=o[a],h=s[a];l!==0&&(Ss.fromBufferAttribute(h,A),r?Ii.addScaledVector(Ss,l):Ii.addScaledVector(Ss.sub(e),l))}e.add(Ii)}return e}raycast(A,e){const t=this.geometry,n=this.material,s=this.matrixWorld;n!==void 0&&(t.boundingSphere===null&&t.computeBoundingSphere(),wi.copy(t.boundingSphere),wi.applyMatrix4(s),Ot.copy(A.ray).recast(A.near),!(wi.containsPoint(Ot.origin)===!1&&(Ot.intersectSphere(wi,Po)===null||Ot.origin.distanceToSquared(Po)>(A.far-A.near)**2))&&(Mo.copy(s).invert(),Ot.copy(A.ray).applyMatrix4(Mo),!(t.boundingBox!==null&&Ot.intersectsBox(t.boundingBox)===!1)&&this._computeIntersections(A,e,Ot)))}_computeIntersections(A,e,t){let n;const s=this.geometry,r=this.material,o=s.index,a=s.attributes.position,c=s.attributes.uv,l=s.attributes.uv1,h=s.attributes.normal,u=s.groups,d=s.drawRange;if(o!==null)if(Array.isArray(r))for(let g=0,C=u.length;g<C;g++){const p=u[g],f=r[p.materialIndex],E=Math.max(p.start,d.start),I=Math.min(o.count,Math.min(p.start+p.count,d.start+d.count));for(let x=E,z=I;x<z;x+=3){const D=o.getX(x),y=o.getX(x+1),F=o.getX(x+2);n=Di(this,f,A,t,c,l,h,D,y,F),n&&(n.faceIndex=Math.floor(x/3),n.face.materialIndex=p.materialIndex,e.push(n))}}else{const g=Math.max(0,d.start),C=Math.min(o.count,d.start+d.count);for(let p=g,f=C;p<f;p+=3){const E=o.getX(p),I=o.getX(p+1),x=o.getX(p+2);n=Di(this,r,A,t,c,l,h,E,I,x),n&&(n.faceIndex=Math.floor(p/3),e.push(n))}}else if(a!==void 0)if(Array.isArray(r))for(let g=0,C=u.length;g<C;g++){const p=u[g],f=r[p.materialIndex],E=Math.max(p.start,d.start),I=Math.min(a.count,Math.min(p.start+p.count,d.start+d.count));for(let x=E,z=I;x<z;x+=3){const D=x,y=x+1,F=x+2;n=Di(this,f,A,t,c,l,h,D,y,F),n&&(n.faceIndex=Math.floor(x/3),n.face.materialIndex=p.materialIndex,e.push(n))}}else{const g=Math.max(0,d.start),C=Math.min(a.count,d.start+d.count);for(let p=g,f=C;p<f;p+=3){const E=p,I=p+1,x=p+2;n=Di(this,r,A,t,c,l,h,E,I,x),n&&(n.faceIndex=Math.floor(p/3),e.push(n))}}}}function oh(i,A,e,t,n,s,r,o){let a;if(A.side===Te?a=t.intersectTriangle(r,s,n,!0,o):a=t.intersectTriangle(n,s,r,A.side===ht,o),a===null)return null;yi.copy(o),yi.applyMatrix4(i.matrixWorld);const c=e.ray.origin.distanceTo(yi);return c<e.near||c>e.far?null:{distance:c,point:yi.clone(),object:i}}function Di(i,A,e,t,n,s,r,o,a,c){i.getVertexPosition(o,un),i.getVertexPosition(a,dn),i.getVertexPosition(c,fn);const l=oh(i,A,e,t,un,dn,fn,Ti);if(l){n&&(vi.fromBufferAttribute(n,o),Ei.fromBufferAttribute(n,a),xi.fromBufferAttribute(n,c),l.uv=Xe.getInterpolation(Ti,un,dn,fn,vi,Ei,xi,new MA)),s&&(vi.fromBufferAttribute(s,o),Ei.fromBufferAttribute(s,a),xi.fromBufferAttribute(s,c),l.uv1=Xe.getInterpolation(Ti,un,dn,fn,vi,Ei,xi,new MA)),r&&(wo.fromBufferAttribute(r,o),Io.fromBufferAttribute(r,a),vo.fromBufferAttribute(r,c),l.normal=Xe.getInterpolation(Ti,un,dn,fn,wo,Io,vo,new S),l.normal.dot(t.direction)>0&&l.normal.multiplyScalar(-1));const h={a:o,b:a,c,normal:new S,materialIndex:0};Xe.getNormal(un,dn,fn,h.normal),l.face=h}return l}class oi extends Ve{constructor(A=1,e=1,t=1,n=1,s=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:A,height:e,depth:t,widthSegments:n,heightSegments:s,depthSegments:r};const o=this;n=Math.floor(n),s=Math.floor(s),r=Math.floor(r);const a=[],c=[],l=[],h=[];let u=0,d=0;g("z","y","x",-1,-1,t,e,A,r,s,0),g("z","y","x",1,-1,t,e,-A,r,s,1),g("x","z","y",1,1,A,t,e,n,r,2),g("x","z","y",1,-1,A,t,-e,n,r,3),g("x","y","z",1,-1,A,e,t,n,s,4),g("x","y","z",-1,-1,A,e,-t,n,s,5),this.setIndex(a),this.setAttribute("position",new Ne(c,3)),this.setAttribute("normal",new Ne(l,3)),this.setAttribute("uv",new Ne(h,2));function g(C,p,f,E,I,x,z,D,y,F,v){const P=x/y,N=z/F,V=x/2,b=z/2,W=D/2,G=y+1,K=F+1;let q=0,H=0;const AA=new S;for(let $=0;$<K;$++){const uA=$*N-b;for(let LA=0;LA<G;LA++){const ZA=LA*P-V;AA[C]=ZA*E,AA[p]=uA*I,AA[f]=W,c.push(AA.x,AA.y,AA.z),AA[C]=0,AA[p]=0,AA[f]=D>0?1:-1,l.push(AA.x,AA.y,AA.z),h.push(LA/y),h.push(1-$/F),q+=1}}for(let $=0;$<F;$++)for(let uA=0;uA<y;uA++){const LA=u+uA+G*$,ZA=u+uA+G*($+1),k=u+(uA+1)+G*($+1),eA=u+(uA+1)+G*$;a.push(LA,ZA,eA),a.push(ZA,k,eA),H+=6}o.addGroup(d,H,v),d+=H,u+=q}}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new oi(A.width,A.height,A.depth,A.widthSegments,A.heightSegments,A.depthSegments)}}function Rn(i){const A={};for(const e in i){A[e]={};for(const t in i[e]){const n=i[e][t];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?n.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),A[e][t]=null):A[e][t]=n.clone():Array.isArray(n)?A[e][t]=n.slice():A[e][t]=n}}return A}function we(i){const A={};for(let e=0;e<i.length;e++){const t=Rn(i[e]);for(const n in t)A[n]=t[n]}return A}function ah(i){const A=[];for(let e=0;e<i.length;e++)A.push(i[e].clone());return A}function Za(i){const A=i.getRenderTarget();return A===null?i.outputColorSpace:A.isXRRenderTarget===!0?A.texture.colorSpace:WA.workingColorSpace}const ch={clone:Rn,merge:we};var lh=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,hh=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Rt extends ke{constructor(A){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=lh,this.fragmentShader=hh,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,A!==void 0&&this.setValues(A)}copy(A){return super.copy(A),this.fragmentShader=A.fragmentShader,this.vertexShader=A.vertexShader,this.uniforms=Rn(A.uniforms),this.uniformsGroups=ah(A.uniformsGroups),this.defines=Object.assign({},A.defines),this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.fog=A.fog,this.lights=A.lights,this.clipping=A.clipping,this.extensions=Object.assign({},A.extensions),this.glslVersion=A.glslVersion,this}toJSON(A){const e=super.toJSON(A);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?e.uniforms[n]={type:"t",value:r.toJSON(A).uuid}:r&&r.isColor?e.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[n]={type:"m4",value:r.toArray()}:e.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const t={};for(const n in this.extensions)this.extensions[n]===!0&&(t[n]=!0);return Object.keys(t).length>0&&(e.extensions=t),e}}class Xa extends ie{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new RA,this.projectionMatrix=new RA,this.projectionMatrixInverse=new RA,this.coordinateSystem=lt}copy(A,e){return super.copy(A,e),this.matrixWorldInverse.copy(A.matrixWorldInverse),this.projectionMatrix.copy(A.projectionMatrix),this.projectionMatrixInverse.copy(A.projectionMatrixInverse),this.coordinateSystem=A.coordinateSystem,this}getWorldDirection(A){return super.getWorldDirection(A).negate()}updateMatrixWorld(A){super.updateMatrixWorld(A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(A,e){super.updateWorldMatrix(A,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const It=new S,Eo=new MA,xo=new MA;class Ie extends Xa{constructor(A=50,e=1,t=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=A,this.zoom=1,this.near=t,this.far=n,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(A,e){return super.copy(A,e),this.fov=A.fov,this.zoom=A.zoom,this.near=A.near,this.far=A.far,this.focus=A.focus,this.aspect=A.aspect,this.view=A.view===null?null:Object.assign({},A.view),this.filmGauge=A.filmGauge,this.filmOffset=A.filmOffset,this}setFocalLength(A){const e=.5*this.getFilmHeight()/A;this.fov=Bn*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const A=Math.tan($n*.5*this.fov);return .5*this.getFilmHeight()/A}getEffectiveFOV(){return Bn*2*Math.atan(Math.tan($n*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(A,e,t){It.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(It.x,It.y).multiplyScalar(-A/It.z),It.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(It.x,It.y).multiplyScalar(-A/It.z)}getViewSize(A,e){return this.getViewBounds(A,Eo,xo),e.subVectors(xo,Eo)}setViewOffset(A,e,t,n,s,r){this.aspect=A/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=n,this.view.width=s,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=this.near;let e=A*Math.tan($n*.5*this.fov)/this.zoom,t=2*e,n=this.aspect*t,s=-.5*n;const r=this.view;if(this.view!==null&&this.view.enabled){const a=r.fullWidth,c=r.fullHeight;s+=r.offsetX*n/a,e-=r.offsetY*t/c,n*=r.width/a,t*=r.height/c}const o=this.filmOffset;o!==0&&(s+=A*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+n,e,e-t,A,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const e=super.toJSON(A);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const pn=-90,gn=1;class uh extends ie{constructor(A,e,t){super(),this.type="CubeCamera",this.renderTarget=t,this.coordinateSystem=null,this.activeMipmapLevel=0;const n=new Ie(pn,gn,A,e);n.layers=this.layers,this.add(n);const s=new Ie(pn,gn,A,e);s.layers=this.layers,this.add(s);const r=new Ie(pn,gn,A,e);r.layers=this.layers,this.add(r);const o=new Ie(pn,gn,A,e);o.layers=this.layers,this.add(o);const a=new Ie(pn,gn,A,e);a.layers=this.layers,this.add(a);const c=new Ie(pn,gn,A,e);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const A=this.coordinateSystem,e=this.children.concat(),[t,n,s,r,o,a]=e;for(const c of e)this.remove(c);if(A===lt)t.up.set(0,1,0),t.lookAt(1,0,0),n.up.set(0,1,0),n.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),r.up.set(0,0,1),r.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),a.up.set(0,1,0),a.lookAt(0,0,-1);else if(A===Xi)t.up.set(0,-1,0),t.lookAt(-1,0,0),n.up.set(0,-1,0),n.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),r.up.set(0,0,-1),r.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),a.up.set(0,-1,0),a.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+A);for(const c of e)this.add(c),c.updateMatrixWorld()}update(A,e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:t,activeMipmapLevel:n}=this;this.coordinateSystem!==A.coordinateSystem&&(this.coordinateSystem=A.coordinateSystem,this.updateCoordinateSystem());const[s,r,o,a,c,l]=this.children,h=A.getRenderTarget(),u=A.getActiveCubeFace(),d=A.getActiveMipmapLevel(),g=A.xr.enabled;A.xr.enabled=!1;const C=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,A.setRenderTarget(t,0,n),A.render(e,s),A.setRenderTarget(t,1,n),A.render(e,r),A.setRenderTarget(t,2,n),A.render(e,o),A.setRenderTarget(t,3,n),A.render(e,a),A.setRenderTarget(t,4,n),A.render(e,c),t.texture.generateMipmaps=C,A.setRenderTarget(t,5,n),A.render(e,l),A.setRenderTarget(h,u,d),A.xr.enabled=g,t.texture.needsPMREMUpdate=!0}}class Ya extends ue{constructor(A,e,t,n,s,r,o,a,c,l){A=A!==void 0?A:[],e=e!==void 0?e:Tn,super(A,e,t,n,s,r,o,a,c,l),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(A){this.image=A}}class dh extends Xt{constructor(A=1,e={}){super(A,A,e),this.isWebGLCubeRenderTarget=!0;const t={width:A,height:A,depth:1},n=[t,t,t,t,t,t];this.texture=new Ya(n,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:be}fromEquirectangularTexture(A,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const t={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},n=new oi(5,5,5),s=new Rt({name:"CubemapFromEquirect",uniforms:Rn(t.uniforms),vertexShader:t.vertexShader,fragmentShader:t.fragmentShader,side:Te,blending:St});s.uniforms.tEquirect.value=e;const r=new Ee(n,s),o=e.minFilter;return e.minFilter===ct&&(e.minFilter=be),new uh(1,10,this).update(A,r),e.minFilter=o,r.geometry.dispose(),r.material.dispose(),this}clear(A,e,t,n){const s=A.getRenderTarget();for(let r=0;r<6;r++)A.setRenderTarget(this,r),A.clear(e,t,n);A.setRenderTarget(s)}}const bs=new S,fh=new S,ph=new BA;class Et{constructor(A=new S(1,0,0),e=0){this.isPlane=!0,this.normal=A,this.constant=e}set(A,e){return this.normal.copy(A),this.constant=e,this}setComponents(A,e,t,n){return this.normal.set(A,e,t),this.constant=n,this}setFromNormalAndCoplanarPoint(A,e){return this.normal.copy(A),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(A,e,t){const n=bs.subVectors(t,e).cross(fh.subVectors(A,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,A),this}copy(A){return this.normal.copy(A.normal),this.constant=A.constant,this}normalize(){const A=1/this.normal.length();return this.normal.multiplyScalar(A),this.constant*=A,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(A){return this.normal.dot(A)+this.constant}distanceToSphere(A){return this.distanceToPoint(A.center)-A.radius}projectPoint(A,e){return e.copy(A).addScaledVector(this.normal,-this.distanceToPoint(A))}intersectLine(A,e){const t=A.delta(bs),n=this.normal.dot(t);if(n===0)return this.distanceToPoint(A.start)===0?e.copy(A.start):null;const s=-(A.start.dot(this.normal)+this.constant)/n;return s<0||s>1?null:e.copy(A.start).addScaledVector(t,s)}intersectsLine(A){const e=this.distanceToPoint(A.start),t=this.distanceToPoint(A.end);return e<0&&t>0||t<0&&e>0}intersectsBox(A){return A.intersectsPlane(this)}intersectsSphere(A){return A.intersectsPlane(this)}coplanarPoint(A){return A.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(A,e){const t=e||ph.getNormalMatrix(A),n=this.coplanarPoint(bs).applyMatrix4(A),s=this.normal.applyMatrix3(t).normalize();return this.constant=-n.dot(s),this}translate(A){return this.constant-=A.dot(this.normal),this}equals(A){return A.normal.equals(this.normal)&&A.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Ft=new Ke,Si=new S;class lr{constructor(A=new Et,e=new Et,t=new Et,n=new Et,s=new Et,r=new Et){this.planes=[A,e,t,n,s,r]}set(A,e,t,n,s,r){const o=this.planes;return o[0].copy(A),o[1].copy(e),o[2].copy(t),o[3].copy(n),o[4].copy(s),o[5].copy(r),this}copy(A){const e=this.planes;for(let t=0;t<6;t++)e[t].copy(A.planes[t]);return this}setFromProjectionMatrix(A,e=lt){const t=this.planes,n=A.elements,s=n[0],r=n[1],o=n[2],a=n[3],c=n[4],l=n[5],h=n[6],u=n[7],d=n[8],g=n[9],C=n[10],p=n[11],f=n[12],E=n[13],I=n[14],x=n[15];if(t[0].setComponents(a-s,u-c,p-d,x-f).normalize(),t[1].setComponents(a+s,u+c,p+d,x+f).normalize(),t[2].setComponents(a+r,u+l,p+g,x+E).normalize(),t[3].setComponents(a-r,u-l,p-g,x-E).normalize(),t[4].setComponents(a-o,u-h,p-C,x-I).normalize(),e===lt)t[5].setComponents(a+o,u+h,p+C,x+I).normalize();else if(e===Xi)t[5].setComponents(o,h,C,I).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(A){if(A.boundingSphere!==void 0)A.boundingSphere===null&&A.computeBoundingSphere(),Ft.copy(A.boundingSphere).applyMatrix4(A.matrixWorld);else{const e=A.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),Ft.copy(e.boundingSphere).applyMatrix4(A.matrixWorld)}return this.intersectsSphere(Ft)}intersectsSprite(A){return Ft.center.set(0,0,0),Ft.radius=.7071067811865476,Ft.applyMatrix4(A.matrixWorld),this.intersectsSphere(Ft)}intersectsSphere(A){const e=this.planes,t=A.center,n=-A.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(t)<n)return!1;return!0}intersectsBox(A){const e=this.planes;for(let t=0;t<6;t++){const n=e[t];if(Si.x=n.normal.x>0?A.max.x:A.min.x,Si.y=n.normal.y>0?A.max.y:A.min.y,Si.z=n.normal.z>0?A.max.z:A.min.z,n.distanceToPoint(Si)<0)return!1}return!0}containsPoint(A){const e=this.planes;for(let t=0;t<6;t++)if(e[t].distanceToPoint(A)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Ja(){let i=null,A=!1,e=null,t=null;function n(s,r){e(s,r),t=i.requestAnimationFrame(n)}return{start:function(){A!==!0&&e!==null&&(t=i.requestAnimationFrame(n),A=!0)},stop:function(){i.cancelAnimationFrame(t),A=!1},setAnimationLoop:function(s){e=s},setContext:function(s){i=s}}}function gh(i){const A=new WeakMap;function e(o,a){const c=o.array,l=o.usage,h=c.byteLength,u=i.createBuffer();i.bindBuffer(a,u),i.bufferData(a,c,l),o.onUploadCallback();let d;if(c instanceof Float32Array)d=i.FLOAT;else if(c instanceof Uint16Array)o.isFloat16BufferAttribute?d=i.HALF_FLOAT:d=i.UNSIGNED_SHORT;else if(c instanceof Int16Array)d=i.SHORT;else if(c instanceof Uint32Array)d=i.UNSIGNED_INT;else if(c instanceof Int32Array)d=i.INT;else if(c instanceof Int8Array)d=i.BYTE;else if(c instanceof Uint8Array)d=i.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)d=i.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:u,type:d,bytesPerElement:c.BYTES_PER_ELEMENT,version:o.version,size:h}}function t(o,a,c){const l=a.array,h=a._updateRange,u=a.updateRanges;if(i.bindBuffer(c,o),h.count===-1&&u.length===0&&i.bufferSubData(c,0,l),u.length!==0){for(let d=0,g=u.length;d<g;d++){const C=u[d];i.bufferSubData(c,C.start*l.BYTES_PER_ELEMENT,l,C.start,C.count)}a.clearUpdateRanges()}h.count!==-1&&(i.bufferSubData(c,h.offset*l.BYTES_PER_ELEMENT,l,h.offset,h.count),h.count=-1),a.onUploadCallback()}function n(o){return o.isInterleavedBufferAttribute&&(o=o.data),A.get(o)}function s(o){o.isInterleavedBufferAttribute&&(o=o.data);const a=A.get(o);a&&(i.deleteBuffer(a.buffer),A.delete(o))}function r(o,a){if(o.isGLBufferAttribute){const l=A.get(o);(!l||l.version<o.version)&&A.set(o,{buffer:o.buffer,type:o.type,bytesPerElement:o.elementSize,version:o.version});return}o.isInterleavedBufferAttribute&&(o=o.data);const c=A.get(o);if(c===void 0)A.set(o,e(o,a));else if(c.version<o.version){if(c.size!==o.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");t(c.buffer,o,a),c.version=o.version}}return{get:n,remove:s,update:r}}class ai extends Ve{constructor(A=1,e=1,t=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:A,height:e,widthSegments:t,heightSegments:n};const s=A/2,r=e/2,o=Math.floor(t),a=Math.floor(n),c=o+1,l=a+1,h=A/o,u=e/a,d=[],g=[],C=[],p=[];for(let f=0;f<l;f++){const E=f*u-r;for(let I=0;I<c;I++){const x=I*h-s;g.push(x,-E,0),C.push(0,0,1),p.push(I/o),p.push(1-f/a)}}for(let f=0;f<a;f++)for(let E=0;E<o;E++){const I=E+c*f,x=E+c*(f+1),z=E+1+c*(f+1),D=E+1+c*f;d.push(I,x,D),d.push(x,z,D)}this.setIndex(d),this.setAttribute("position",new Ne(g,3)),this.setAttribute("normal",new Ne(C,3)),this.setAttribute("uv",new Ne(p,2))}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new ai(A.width,A.height,A.widthSegments,A.heightSegments)}}var mh=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,Ch=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,Mh=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,Ph=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,wh=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,Ih=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,vh=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,Eh=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,xh=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,Th=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,yh=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,Dh=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Sh=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,bh=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,Bh=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Rh=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,zh=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,_h=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Uh=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Nh=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Lh=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Oh=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Fh=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Qh=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,jh=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Hh=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,kh=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Vh=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,Gh=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Wh=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Zh="gl_FragColor = linearToOutputTexel( gl_FragColor );",Xh=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,Yh=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Jh=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Kh=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,qh=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,$h=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Au=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,eu=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,tu=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,nu=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,iu=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,su=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,ru=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,ou=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,au=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,cu=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,lu=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,hu=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,uu=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,du=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,fu=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,pu=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,gu=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,mu=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Cu=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,Mu=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Pu=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,wu=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Iu=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,vu=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,Eu=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,xu=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Tu=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,yu=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Du=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Su=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,bu=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,Bu=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,Ru=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,zu=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,_u=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,Uu=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Nu=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Lu=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Ou=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Fu=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,Qu=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,ju=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,Hu=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,ku=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Vu=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Gu=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,Wu=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Zu=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Xu=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Yu=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Ju=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Ku=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,qu=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`,$u=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Ad=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,ed=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,td=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,nd=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,id=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,sd=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,rd=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,od=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,ad=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,cd=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,ld=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,hd=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,ud=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,dd=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,fd=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,pd=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const gd=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,md=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Cd=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Md=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Pd=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,wd=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Id=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,vd=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Ed=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,xd=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Td=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,yd=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Dd=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Sd=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,bd=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Bd=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Rd=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,zd=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_d=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Ud=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Nd=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Ld=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Od=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Fd=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Qd=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,jd=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Hd=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,kd=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Vd=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Gd=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Wd=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Zd=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Xd=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Yd=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,bA={alphahash_fragment:mh,alphahash_pars_fragment:Ch,alphamap_fragment:Mh,alphamap_pars_fragment:Ph,alphatest_fragment:wh,alphatest_pars_fragment:Ih,aomap_fragment:vh,aomap_pars_fragment:Eh,batching_pars_vertex:xh,batching_vertex:Th,begin_vertex:yh,beginnormal_vertex:Dh,bsdfs:Sh,iridescence_fragment:bh,bumpmap_pars_fragment:Bh,clipping_planes_fragment:Rh,clipping_planes_pars_fragment:zh,clipping_planes_pars_vertex:_h,clipping_planes_vertex:Uh,color_fragment:Nh,color_pars_fragment:Lh,color_pars_vertex:Oh,color_vertex:Fh,common:Qh,cube_uv_reflection_fragment:jh,defaultnormal_vertex:Hh,displacementmap_pars_vertex:kh,displacementmap_vertex:Vh,emissivemap_fragment:Gh,emissivemap_pars_fragment:Wh,colorspace_fragment:Zh,colorspace_pars_fragment:Xh,envmap_fragment:Yh,envmap_common_pars_fragment:Jh,envmap_pars_fragment:Kh,envmap_pars_vertex:qh,envmap_physical_pars_fragment:cu,envmap_vertex:$h,fog_vertex:Au,fog_pars_vertex:eu,fog_fragment:tu,fog_pars_fragment:nu,gradientmap_pars_fragment:iu,lightmap_pars_fragment:su,lights_lambert_fragment:ru,lights_lambert_pars_fragment:ou,lights_pars_begin:au,lights_toon_fragment:lu,lights_toon_pars_fragment:hu,lights_phong_fragment:uu,lights_phong_pars_fragment:du,lights_physical_fragment:fu,lights_physical_pars_fragment:pu,lights_fragment_begin:gu,lights_fragment_maps:mu,lights_fragment_end:Cu,logdepthbuf_fragment:Mu,logdepthbuf_pars_fragment:Pu,logdepthbuf_pars_vertex:wu,logdepthbuf_vertex:Iu,map_fragment:vu,map_pars_fragment:Eu,map_particle_fragment:xu,map_particle_pars_fragment:Tu,metalnessmap_fragment:yu,metalnessmap_pars_fragment:Du,morphinstance_vertex:Su,morphcolor_vertex:bu,morphnormal_vertex:Bu,morphtarget_pars_vertex:Ru,morphtarget_vertex:zu,normal_fragment_begin:_u,normal_fragment_maps:Uu,normal_pars_fragment:Nu,normal_pars_vertex:Lu,normal_vertex:Ou,normalmap_pars_fragment:Fu,clearcoat_normal_fragment_begin:Qu,clearcoat_normal_fragment_maps:ju,clearcoat_pars_fragment:Hu,iridescence_pars_fragment:ku,opaque_fragment:Vu,packing:Gu,premultiplied_alpha_fragment:Wu,project_vertex:Zu,dithering_fragment:Xu,dithering_pars_fragment:Yu,roughnessmap_fragment:Ju,roughnessmap_pars_fragment:Ku,shadowmap_pars_fragment:qu,shadowmap_pars_vertex:$u,shadowmap_vertex:Ad,shadowmask_pars_fragment:ed,skinbase_vertex:td,skinning_pars_vertex:nd,skinning_vertex:id,skinnormal_vertex:sd,specularmap_fragment:rd,specularmap_pars_fragment:od,tonemapping_fragment:ad,tonemapping_pars_fragment:cd,transmission_fragment:ld,transmission_pars_fragment:hd,uv_pars_fragment:ud,uv_pars_vertex:dd,uv_vertex:fd,worldpos_vertex:pd,background_vert:gd,background_frag:md,backgroundCube_vert:Cd,backgroundCube_frag:Md,cube_vert:Pd,cube_frag:wd,depth_vert:Id,depth_frag:vd,distanceRGBA_vert:Ed,distanceRGBA_frag:xd,equirect_vert:Td,equirect_frag:yd,linedashed_vert:Dd,linedashed_frag:Sd,meshbasic_vert:bd,meshbasic_frag:Bd,meshlambert_vert:Rd,meshlambert_frag:zd,meshmatcap_vert:_d,meshmatcap_frag:Ud,meshnormal_vert:Nd,meshnormal_frag:Ld,meshphong_vert:Od,meshphong_frag:Fd,meshphysical_vert:Qd,meshphysical_frag:jd,meshtoon_vert:Hd,meshtoon_frag:kd,points_vert:Vd,points_frag:Gd,shadow_vert:Wd,shadow_frag:Zd,sprite_vert:Xd,sprite_frag:Yd},sA={common:{diffuse:{value:new wA(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new BA},alphaMap:{value:null},alphaMapTransform:{value:new BA},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new BA}},envmap:{envMap:{value:null},envMapRotation:{value:new BA},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new BA}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new BA}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new BA},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new BA},normalScale:{value:new MA(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new BA},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new BA}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new BA}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new BA}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new wA(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new wA(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new BA},alphaTest:{value:0},uvTransform:{value:new BA}},sprite:{diffuse:{value:new wA(16777215)},opacity:{value:1},center:{value:new MA(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new BA},alphaMap:{value:null},alphaMapTransform:{value:new BA},alphaTest:{value:0}}},Ge={basic:{uniforms:we([sA.common,sA.specularmap,sA.envmap,sA.aomap,sA.lightmap,sA.fog]),vertexShader:bA.meshbasic_vert,fragmentShader:bA.meshbasic_frag},lambert:{uniforms:we([sA.common,sA.specularmap,sA.envmap,sA.aomap,sA.lightmap,sA.emissivemap,sA.bumpmap,sA.normalmap,sA.displacementmap,sA.fog,sA.lights,{emissive:{value:new wA(0)}}]),vertexShader:bA.meshlambert_vert,fragmentShader:bA.meshlambert_frag},phong:{uniforms:we([sA.common,sA.specularmap,sA.envmap,sA.aomap,sA.lightmap,sA.emissivemap,sA.bumpmap,sA.normalmap,sA.displacementmap,sA.fog,sA.lights,{emissive:{value:new wA(0)},specular:{value:new wA(1118481)},shininess:{value:30}}]),vertexShader:bA.meshphong_vert,fragmentShader:bA.meshphong_frag},standard:{uniforms:we([sA.common,sA.envmap,sA.aomap,sA.lightmap,sA.emissivemap,sA.bumpmap,sA.normalmap,sA.displacementmap,sA.roughnessmap,sA.metalnessmap,sA.fog,sA.lights,{emissive:{value:new wA(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:bA.meshphysical_vert,fragmentShader:bA.meshphysical_frag},toon:{uniforms:we([sA.common,sA.aomap,sA.lightmap,sA.emissivemap,sA.bumpmap,sA.normalmap,sA.displacementmap,sA.gradientmap,sA.fog,sA.lights,{emissive:{value:new wA(0)}}]),vertexShader:bA.meshtoon_vert,fragmentShader:bA.meshtoon_frag},matcap:{uniforms:we([sA.common,sA.bumpmap,sA.normalmap,sA.displacementmap,sA.fog,{matcap:{value:null}}]),vertexShader:bA.meshmatcap_vert,fragmentShader:bA.meshmatcap_frag},points:{uniforms:we([sA.points,sA.fog]),vertexShader:bA.points_vert,fragmentShader:bA.points_frag},dashed:{uniforms:we([sA.common,sA.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:bA.linedashed_vert,fragmentShader:bA.linedashed_frag},depth:{uniforms:we([sA.common,sA.displacementmap]),vertexShader:bA.depth_vert,fragmentShader:bA.depth_frag},normal:{uniforms:we([sA.common,sA.bumpmap,sA.normalmap,sA.displacementmap,{opacity:{value:1}}]),vertexShader:bA.meshnormal_vert,fragmentShader:bA.meshnormal_frag},sprite:{uniforms:we([sA.sprite,sA.fog]),vertexShader:bA.sprite_vert,fragmentShader:bA.sprite_frag},background:{uniforms:{uvTransform:{value:new BA},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:bA.background_vert,fragmentShader:bA.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new BA}},vertexShader:bA.backgroundCube_vert,fragmentShader:bA.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:bA.cube_vert,fragmentShader:bA.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:bA.equirect_vert,fragmentShader:bA.equirect_frag},distanceRGBA:{uniforms:we([sA.common,sA.displacementmap,{referencePosition:{value:new S},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:bA.distanceRGBA_vert,fragmentShader:bA.distanceRGBA_frag},shadow:{uniforms:we([sA.lights,sA.fog,{color:{value:new wA(0)},opacity:{value:1}}]),vertexShader:bA.shadow_vert,fragmentShader:bA.shadow_frag}};Ge.physical={uniforms:we([Ge.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new BA},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new BA},clearcoatNormalScale:{value:new MA(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new BA},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new BA},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new BA},sheen:{value:0},sheenColor:{value:new wA(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new BA},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new BA},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new BA},transmissionSamplerSize:{value:new MA},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new BA},attenuationDistance:{value:0},attenuationColor:{value:new wA(0)},specularColor:{value:new wA(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new BA},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new BA},anisotropyVector:{value:new MA},anisotropyMap:{value:null},anisotropyMapTransform:{value:new BA}}]),vertexShader:bA.meshphysical_vert,fragmentShader:bA.meshphysical_frag};const bi={r:0,b:0,g:0},Qt=new Je,Jd=new RA;function Kd(i,A,e,t,n,s,r){const o=new wA(0);let a=s===!0?0:1,c,l,h=null,u=0,d=null;function g(E){let I=E.isScene===!0?E.background:null;return I&&I.isTexture&&(I=(E.backgroundBlurriness>0?e:A).get(I)),I}function C(E){let I=!1;const x=g(E);x===null?f(o,a):x&&x.isColor&&(f(x,1),I=!0);const z=i.xr.getEnvironmentBlendMode();z==="additive"?t.buffers.color.setClear(0,0,0,1,r):z==="alpha-blend"&&t.buffers.color.setClear(0,0,0,0,r),(i.autoClear||I)&&i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil)}function p(E,I){const x=g(I);x&&(x.isCubeTexture||x.mapping===qi)?(l===void 0&&(l=new Ee(new oi(1,1,1),new Rt({name:"BackgroundCubeMaterial",uniforms:Rn(Ge.backgroundCube.uniforms),vertexShader:Ge.backgroundCube.vertexShader,fragmentShader:Ge.backgroundCube.fragmentShader,side:Te,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(z,D,y){this.matrixWorld.copyPosition(y.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(l)),Qt.copy(I.backgroundRotation),Qt.x*=-1,Qt.y*=-1,Qt.z*=-1,x.isCubeTexture&&x.isRenderTargetTexture===!1&&(Qt.y*=-1,Qt.z*=-1),l.material.uniforms.envMap.value=x,l.material.uniforms.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,l.material.uniforms.backgroundBlurriness.value=I.backgroundBlurriness,l.material.uniforms.backgroundIntensity.value=I.backgroundIntensity,l.material.uniforms.backgroundRotation.value.setFromMatrix4(Jd.makeRotationFromEuler(Qt)),l.material.toneMapped=WA.getTransfer(x.colorSpace)!==Ae,(h!==x||u!==x.version||d!==i.toneMapping)&&(l.material.needsUpdate=!0,h=x,u=x.version,d=i.toneMapping),l.layers.enableAll(),E.unshift(l,l.geometry,l.material,0,0,null)):x&&x.isTexture&&(c===void 0&&(c=new Ee(new ai(2,2),new Rt({name:"BackgroundMaterial",uniforms:Rn(Ge.background.uniforms),vertexShader:Ge.background.vertexShader,fragmentShader:Ge.background.fragmentShader,side:ht,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(c)),c.material.uniforms.t2D.value=x,c.material.uniforms.backgroundIntensity.value=I.backgroundIntensity,c.material.toneMapped=WA.getTransfer(x.colorSpace)!==Ae,x.matrixAutoUpdate===!0&&x.updateMatrix(),c.material.uniforms.uvTransform.value.copy(x.matrix),(h!==x||u!==x.version||d!==i.toneMapping)&&(c.material.needsUpdate=!0,h=x,u=x.version,d=i.toneMapping),c.layers.enableAll(),E.unshift(c,c.geometry,c.material,0,0,null))}function f(E,I){E.getRGB(bi,Za(i)),t.buffers.color.setClear(bi.r,bi.g,bi.b,I,r)}return{getClearColor:function(){return o},setClearColor:function(E,I=1){o.set(E),a=I,f(o,a)},getClearAlpha:function(){return a},setClearAlpha:function(E){a=E,f(o,a)},render:C,addToRenderList:p}}function qd(i,A){const e=i.getParameter(i.MAX_VERTEX_ATTRIBS),t={},n=u(null);let s=n,r=!1;function o(P,N,V,b,W){let G=!1;const K=h(b,V,N);s!==K&&(s=K,c(s.object)),G=d(P,b,V,W),G&&g(P,b,V,W),W!==null&&A.update(W,i.ELEMENT_ARRAY_BUFFER),(G||r)&&(r=!1,x(P,N,V,b),W!==null&&i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,A.get(W).buffer))}function a(){return i.createVertexArray()}function c(P){return i.bindVertexArray(P)}function l(P){return i.deleteVertexArray(P)}function h(P,N,V){const b=V.wireframe===!0;let W=t[P.id];W===void 0&&(W={},t[P.id]=W);let G=W[N.id];G===void 0&&(G={},W[N.id]=G);let K=G[b];return K===void 0&&(K=u(a()),G[b]=K),K}function u(P){const N=[],V=[],b=[];for(let W=0;W<e;W++)N[W]=0,V[W]=0,b[W]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:N,enabledAttributes:V,attributeDivisors:b,object:P,attributes:{},index:null}}function d(P,N,V,b){const W=s.attributes,G=N.attributes;let K=0;const q=V.getAttributes();for(const H in q)if(q[H].location>=0){const $=W[H];let uA=G[H];if(uA===void 0&&(H==="instanceMatrix"&&P.instanceMatrix&&(uA=P.instanceMatrix),H==="instanceColor"&&P.instanceColor&&(uA=P.instanceColor)),$===void 0||$.attribute!==uA||uA&&$.data!==uA.data)return!0;K++}return s.attributesNum!==K||s.index!==b}function g(P,N,V,b){const W={},G=N.attributes;let K=0;const q=V.getAttributes();for(const H in q)if(q[H].location>=0){let $=G[H];$===void 0&&(H==="instanceMatrix"&&P.instanceMatrix&&($=P.instanceMatrix),H==="instanceColor"&&P.instanceColor&&($=P.instanceColor));const uA={};uA.attribute=$,$&&$.data&&(uA.data=$.data),W[H]=uA,K++}s.attributes=W,s.attributesNum=K,s.index=b}function C(){const P=s.newAttributes;for(let N=0,V=P.length;N<V;N++)P[N]=0}function p(P){f(P,0)}function f(P,N){const V=s.newAttributes,b=s.enabledAttributes,W=s.attributeDivisors;V[P]=1,b[P]===0&&(i.enableVertexAttribArray(P),b[P]=1),W[P]!==N&&(i.vertexAttribDivisor(P,N),W[P]=N)}function E(){const P=s.newAttributes,N=s.enabledAttributes;for(let V=0,b=N.length;V<b;V++)N[V]!==P[V]&&(i.disableVertexAttribArray(V),N[V]=0)}function I(P,N,V,b,W,G,K){K===!0?i.vertexAttribIPointer(P,N,V,W,G):i.vertexAttribPointer(P,N,V,b,W,G)}function x(P,N,V,b){C();const W=b.attributes,G=V.getAttributes(),K=N.defaultAttributeValues;for(const q in G){const H=G[q];if(H.location>=0){let AA=W[q];if(AA===void 0&&(q==="instanceMatrix"&&P.instanceMatrix&&(AA=P.instanceMatrix),q==="instanceColor"&&P.instanceColor&&(AA=P.instanceColor)),AA!==void 0){const $=AA.normalized,uA=AA.itemSize,LA=A.get(AA);if(LA===void 0)continue;const ZA=LA.buffer,k=LA.type,eA=LA.bytesPerElement,lA=k===i.INT||k===i.UNSIGNED_INT||AA.gpuType===Sa;if(AA.isInterleavedBufferAttribute){const iA=AA.data,OA=iA.stride,zA=AA.offset;if(iA.isInstancedInterleavedBuffer){for(let _=0;_<H.locationSize;_++)f(H.location+_,iA.meshPerAttribute);P.isInstancedMesh!==!0&&b._maxInstanceCount===void 0&&(b._maxInstanceCount=iA.meshPerAttribute*iA.count)}else for(let _=0;_<H.locationSize;_++)p(H.location+_);i.bindBuffer(i.ARRAY_BUFFER,ZA);for(let _=0;_<H.locationSize;_++)I(H.location+_,uA/H.locationSize,k,$,OA*eA,(zA+uA/H.locationSize*_)*eA,lA)}else{if(AA.isInstancedBufferAttribute){for(let iA=0;iA<H.locationSize;iA++)f(H.location+iA,AA.meshPerAttribute);P.isInstancedMesh!==!0&&b._maxInstanceCount===void 0&&(b._maxInstanceCount=AA.meshPerAttribute*AA.count)}else for(let iA=0;iA<H.locationSize;iA++)p(H.location+iA);i.bindBuffer(i.ARRAY_BUFFER,ZA);for(let iA=0;iA<H.locationSize;iA++)I(H.location+iA,uA/H.locationSize,k,$,uA*eA,uA/H.locationSize*iA*eA,lA)}}else if(K!==void 0){const $=K[q];if($!==void 0)switch($.length){case 2:i.vertexAttrib2fv(H.location,$);break;case 3:i.vertexAttrib3fv(H.location,$);break;case 4:i.vertexAttrib4fv(H.location,$);break;default:i.vertexAttrib1fv(H.location,$)}}}}E()}function z(){F();for(const P in t){const N=t[P];for(const V in N){const b=N[V];for(const W in b)l(b[W].object),delete b[W];delete N[V]}delete t[P]}}function D(P){if(t[P.id]===void 0)return;const N=t[P.id];for(const V in N){const b=N[V];for(const W in b)l(b[W].object),delete b[W];delete N[V]}delete t[P.id]}function y(P){for(const N in t){const V=t[N];if(V[P.id]===void 0)continue;const b=V[P.id];for(const W in b)l(b[W].object),delete b[W];delete V[P.id]}}function F(){v(),r=!0,s!==n&&(s=n,c(s.object))}function v(){n.geometry=null,n.program=null,n.wireframe=!1}return{setup:o,reset:F,resetDefaultState:v,dispose:z,releaseStatesOfGeometry:D,releaseStatesOfProgram:y,initAttributes:C,enableAttribute:p,disableUnusedAttributes:E}}function $d(i,A,e){let t;function n(c){t=c}function s(c,l){i.drawArrays(t,c,l),e.update(l,t,1)}function r(c,l,h){h!==0&&(i.drawArraysInstanced(t,c,l,h),e.update(l,t,h))}function o(c,l,h){if(h===0)return;const u=A.get("WEBGL_multi_draw");if(u===null)for(let d=0;d<h;d++)this.render(c[d],l[d]);else{u.multiDrawArraysWEBGL(t,c,0,l,0,h);let d=0;for(let g=0;g<h;g++)d+=l[g];e.update(d,t,1)}}function a(c,l,h,u){if(h===0)return;const d=A.get("WEBGL_multi_draw");if(d===null)for(let g=0;g<c.length;g++)r(c[g],l[g],u[g]);else{d.multiDrawArraysInstancedWEBGL(t,c,0,l,0,u,0,h);let g=0;for(let C=0;C<h;C++)g+=l[C];for(let C=0;C<u.length;C++)e.update(g,t,u[C])}}this.setMode=n,this.render=s,this.renderInstances=r,this.renderMultiDraw=o,this.renderMultiDrawInstances=a}function Af(i,A,e,t){let n;function s(){if(n!==void 0)return n;if(A.has("EXT_texture_filter_anisotropic")===!0){const D=A.get("EXT_texture_filter_anisotropic");n=i.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function r(D){return!(D!==je&&t.convert(D)!==i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT))}function o(D){const y=D===$i&&(A.has("EXT_color_buffer_half_float")||A.has("EXT_color_buffer_float"));return!(D!==Bt&&t.convert(D)!==i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE)&&D!==Ye&&!y)}function a(D){if(D==="highp"){if(i.getShaderPrecisionFormat(i.VERTEX_SHADER,i.HIGH_FLOAT).precision>0&&i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.HIGH_FLOAT).precision>0)return"highp";D="mediump"}return D==="mediump"&&i.getShaderPrecisionFormat(i.VERTEX_SHADER,i.MEDIUM_FLOAT).precision>0&&i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let c=e.precision!==void 0?e.precision:"highp";const l=a(c);l!==c&&(console.warn("THREE.WebGLRenderer:",c,"not supported, using",l,"instead."),c=l);const h=e.logarithmicDepthBuffer===!0,u=i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),d=i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),g=i.getParameter(i.MAX_TEXTURE_SIZE),C=i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),p=i.getParameter(i.MAX_VERTEX_ATTRIBS),f=i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),E=i.getParameter(i.MAX_VARYING_VECTORS),I=i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),x=d>0,z=i.getParameter(i.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:a,textureFormatReadable:r,textureTypeReadable:o,precision:c,logarithmicDepthBuffer:h,maxTextures:u,maxVertexTextures:d,maxTextureSize:g,maxCubemapSize:C,maxAttributes:p,maxVertexUniforms:f,maxVaryings:E,maxFragmentUniforms:I,vertexTextures:x,maxSamples:z}}function ef(i){const A=this;let e=null,t=0,n=!1,s=!1;const r=new Et,o=new BA,a={value:null,needsUpdate:!1};this.uniform=a,this.numPlanes=0,this.numIntersection=0,this.init=function(h,u){const d=h.length!==0||u||t!==0||n;return n=u,t=h.length,d},this.beginShadows=function(){s=!0,l(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(h,u){e=l(h,u,0)},this.setState=function(h,u,d){const g=h.clippingPlanes,C=h.clipIntersection,p=h.clipShadows,f=i.get(h);if(!n||g===null||g.length===0||s&&!p)s?l(null):c();else{const E=s?0:t,I=E*4;let x=f.clippingState||null;a.value=x,x=l(g,u,I,d);for(let z=0;z!==I;++z)x[z]=e[z];f.clippingState=x,this.numIntersection=C?this.numPlanes:0,this.numPlanes+=E}};function c(){a.value!==e&&(a.value=e,a.needsUpdate=t>0),A.numPlanes=t,A.numIntersection=0}function l(h,u,d,g){const C=h!==null?h.length:0;let p=null;if(C!==0){if(p=a.value,g!==!0||p===null){const f=d+C*4,E=u.matrixWorldInverse;o.getNormalMatrix(E),(p===null||p.length<f)&&(p=new Float32Array(f));for(let I=0,x=d;I!==C;++I,x+=4)r.copy(h[I]).applyMatrix4(E,o),r.normal.toArray(p,x),p[x+3]=r.constant}a.value=p,a.needsUpdate=!0}return A.numPlanes=C,A.numIntersection=0,p}}function tf(i){let A=new WeakMap;function e(r,o){return o===Ys?r.mapping=Tn:o===Js&&(r.mapping=yn),r}function t(r){if(r&&r.isTexture){const o=r.mapping;if(o===Ys||o===Js)if(A.has(r)){const a=A.get(r).texture;return e(a,r.mapping)}else{const a=r.image;if(a&&a.height>0){const c=new dh(a.height);return c.fromEquirectangularTexture(i,r),A.set(r,c),r.addEventListener("dispose",n),e(c.texture,r.mapping)}else return null}}return r}function n(r){const o=r.target;o.removeEventListener("dispose",n);const a=A.get(o);a!==void 0&&(A.delete(o),a.dispose())}function s(){A=new WeakMap}return{get:t,dispose:s}}class hr extends Xa{constructor(A=-1,e=1,t=1,n=-1,s=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=A,this.right=e,this.top=t,this.bottom=n,this.near=s,this.far=r,this.updateProjectionMatrix()}copy(A,e){return super.copy(A,e),this.left=A.left,this.right=A.right,this.top=A.top,this.bottom=A.bottom,this.near=A.near,this.far=A.far,this.zoom=A.zoom,this.view=A.view===null?null:Object.assign({},A.view),this}setViewOffset(A,e,t,n,s,r){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=n,this.view.width=s,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let s=t-A,r=t+A,o=n+e,a=n-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,l=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,r=s+c*this.view.width,o-=l*this.view.offsetY,a=o-l*this.view.height}this.projectionMatrix.makeOrthographic(s,r,o,a,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const e=super.toJSON(A);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}const wn=4,To=[.125,.215,.35,.446,.526,.582],Gt=20,Bs=new hr,yo=new wA;let Rs=null,zs=0,_s=0,Us=!1;const kt=(1+Math.sqrt(5))/2,mn=1/kt,Do=[new S(-kt,mn,0),new S(kt,mn,0),new S(-mn,0,kt),new S(mn,0,kt),new S(0,kt,-mn),new S(0,kt,mn),new S(-1,1,-1),new S(1,1,-1),new S(-1,1,1),new S(1,1,1)];class So{constructor(A){this._renderer=A,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(A,e=0,t=.1,n=100){Rs=this._renderer.getRenderTarget(),zs=this._renderer.getActiveCubeFace(),_s=this._renderer.getActiveMipmapLevel(),Us=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(A,t,n,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(A,e=null){return this._fromTexture(A,e)}fromCubemap(A,e=null){return this._fromTexture(A,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=Ro(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=Bo(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(A){this._lodMax=Math.floor(Math.log2(A)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let A=0;A<this._lodPlanes.length;A++)this._lodPlanes[A].dispose()}_cleanup(A){this._renderer.setRenderTarget(Rs,zs,_s),this._renderer.xr.enabled=Us,A.scissorTest=!1,Bi(A,0,0,A.width,A.height)}_fromTexture(A,e){A.mapping===Tn||A.mapping===yn?this._setSize(A.image.length===0?16:A.image[0].width||A.image[0].image.width):this._setSize(A.image.width/4),Rs=this._renderer.getRenderTarget(),zs=this._renderer.getActiveCubeFace(),_s=this._renderer.getActiveMipmapLevel(),Us=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const t=e||this._allocateTargets();return this._textureToCubeUV(A,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(){const A=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,t={magFilter:be,minFilter:be,generateMipmaps:!1,type:$i,format:je,colorSpace:fe,depthBuffer:!1},n=bo(A,e,t);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==A||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=bo(A,e,t);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=nf(s)),this._blurMaterial=sf(s,A,e)}return n}_compileMaterial(A){const e=new Ee(this._lodPlanes[0],A);this._renderer.compile(e,Bs)}_sceneToCubeUV(A,e,t,n){const o=new Ie(90,1,e,t),a=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],l=this._renderer,h=l.autoClear,u=l.toneMapping;l.getClearColor(yo),l.toneMapping=bt,l.autoClear=!1;const d=new Wt({name:"PMREM.Background",side:Te,depthWrite:!1,depthTest:!1}),g=new Ee(new oi,d);let C=!1;const p=A.background;p?p.isColor&&(d.color.copy(p),A.background=null,C=!0):(d.color.copy(yo),C=!0);for(let f=0;f<6;f++){const E=f%3;E===0?(o.up.set(0,a[f],0),o.lookAt(c[f],0,0)):E===1?(o.up.set(0,0,a[f]),o.lookAt(0,c[f],0)):(o.up.set(0,a[f],0),o.lookAt(0,0,c[f]));const I=this._cubeSize;Bi(n,E*I,f>2?I:0,I,I),l.setRenderTarget(n),C&&l.render(g,o),l.render(A,o)}g.geometry.dispose(),g.material.dispose(),l.toneMapping=u,l.autoClear=h,A.background=p}_textureToCubeUV(A,e){const t=this._renderer,n=A.mapping===Tn||A.mapping===yn;n?(this._cubemapMaterial===null&&(this._cubemapMaterial=Ro()),this._cubemapMaterial.uniforms.flipEnvMap.value=A.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=Bo());const s=n?this._cubemapMaterial:this._equirectMaterial,r=new Ee(this._lodPlanes[0],s),o=s.uniforms;o.envMap.value=A;const a=this._cubeSize;Bi(e,0,0,3*a,2*a),t.setRenderTarget(e),t.render(r,Bs)}_applyPMREM(A){const e=this._renderer,t=e.autoClear;e.autoClear=!1;const n=this._lodPlanes.length;for(let s=1;s<n;s++){const r=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),o=Do[(n-s-1)%Do.length];this._blur(A,s-1,s,r,o)}e.autoClear=t}_blur(A,e,t,n,s){const r=this._pingPongRenderTarget;this._halfBlur(A,r,e,t,n,"latitudinal",s),this._halfBlur(r,A,t,t,n,"longitudinal",s)}_halfBlur(A,e,t,n,s,r,o){const a=this._renderer,c=this._blurMaterial;r!=="latitudinal"&&r!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const l=3,h=new Ee(this._lodPlanes[n],c),u=c.uniforms,d=this._sizeLods[t]-1,g=isFinite(s)?Math.PI/(2*d):2*Math.PI/(2*Gt-1),C=s/g,p=isFinite(s)?1+Math.floor(l*C):Gt;p>Gt&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Gt}`);const f=[];let E=0;for(let y=0;y<Gt;++y){const F=y/C,v=Math.exp(-F*F/2);f.push(v),y===0?E+=v:y<p&&(E+=2*v)}for(let y=0;y<f.length;y++)f[y]=f[y]/E;u.envMap.value=A.texture,u.samples.value=p,u.weights.value=f,u.latitudinal.value=r==="latitudinal",o&&(u.poleAxis.value=o);const{_lodMax:I}=this;u.dTheta.value=g,u.mipInt.value=I-t;const x=this._sizeLods[n],z=3*x*(n>I-wn?n-I+wn:0),D=4*(this._cubeSize-x);Bi(e,z,D,3*x,2*x),a.setRenderTarget(e),a.render(h,Bs)}}function nf(i){const A=[],e=[],t=[];let n=i;const s=i-wn+1+To.length;for(let r=0;r<s;r++){const o=Math.pow(2,n);e.push(o);let a=1/o;r>i-wn?a=To[r-i+wn-1]:r===0&&(a=0),t.push(a);const c=1/(o-2),l=-c,h=1+c,u=[l,l,h,l,h,h,l,l,h,h,l,h],d=6,g=6,C=3,p=2,f=1,E=new Float32Array(C*g*d),I=new Float32Array(p*g*d),x=new Float32Array(f*g*d);for(let D=0;D<d;D++){const y=D%3*2/3-1,F=D>2?0:-1,v=[y,F,0,y+2/3,F,0,y+2/3,F+1,0,y,F,0,y+2/3,F+1,0,y,F+1,0];E.set(v,C*g*D),I.set(u,p*g*D);const P=[D,D,D,D,D,D];x.set(P,f*g*D)}const z=new Ve;z.setAttribute("position",new xe(E,C)),z.setAttribute("uv",new xe(I,p)),z.setAttribute("faceIndex",new xe(x,f)),A.push(z),n>wn&&n--}return{lodPlanes:A,sizeLods:e,sigmas:t}}function bo(i,A,e){const t=new Xt(i,A,e);return t.texture.mapping=qi,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Bi(i,A,e,t,n){i.viewport.set(A,e,t,n),i.scissor.set(A,e,t,n)}function sf(i,A,e){const t=new Float32Array(Gt),n=new S(0,1,0);return new Rt({name:"SphericalGaussianBlur",defines:{n:Gt,CUBEUV_TEXEL_WIDTH:1/A,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${i}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n}},vertexShader:ur(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:St,depthTest:!1,depthWrite:!1})}function Bo(){return new Rt({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:ur(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:St,depthTest:!1,depthWrite:!1})}function Ro(){return new Rt({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:ur(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:St,depthTest:!1,depthWrite:!1})}function ur(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function rf(i){let A=new WeakMap,e=null;function t(o){if(o&&o.isTexture){const a=o.mapping,c=a===Ys||a===Js,l=a===Tn||a===yn;if(c||l){let h=A.get(o);const u=h!==void 0?h.texture.pmremVersion:0;if(o.isRenderTargetTexture&&o.pmremVersion!==u)return e===null&&(e=new So(i)),h=c?e.fromEquirectangular(o,h):e.fromCubemap(o,h),h.texture.pmremVersion=o.pmremVersion,A.set(o,h),h.texture;if(h!==void 0)return h.texture;{const d=o.image;return c&&d&&d.height>0||l&&d&&n(d)?(e===null&&(e=new So(i)),h=c?e.fromEquirectangular(o):e.fromCubemap(o),h.texture.pmremVersion=o.pmremVersion,A.set(o,h),o.addEventListener("dispose",s),h.texture):null}}}return o}function n(o){let a=0;const c=6;for(let l=0;l<c;l++)o[l]!==void 0&&a++;return a===c}function s(o){const a=o.target;a.removeEventListener("dispose",s);const c=A.get(a);c!==void 0&&(A.delete(a),c.dispose())}function r(){A=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:t,dispose:r}}function of(i){const A={};function e(t){if(A[t]!==void 0)return A[t];let n;switch(t){case"WEBGL_depth_texture":n=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=i.getExtension(t)}return A[t]=n,n}return{has:function(t){return e(t)!==null},init:function(){e("EXT_color_buffer_float"),e("WEBGL_clip_cull_distance"),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture"),e("WEBGL_render_shared_exponent")},get:function(t){const n=e(t);return n===null&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),n}}}function af(i,A,e,t){const n={},s=new WeakMap;function r(h){const u=h.target;u.index!==null&&A.remove(u.index);for(const g in u.attributes)A.remove(u.attributes[g]);for(const g in u.morphAttributes){const C=u.morphAttributes[g];for(let p=0,f=C.length;p<f;p++)A.remove(C[p])}u.removeEventListener("dispose",r),delete n[u.id];const d=s.get(u);d&&(A.remove(d),s.delete(u)),t.releaseStatesOfGeometry(u),u.isInstancedBufferGeometry===!0&&delete u._maxInstanceCount,e.memory.geometries--}function o(h,u){return n[u.id]===!0||(u.addEventListener("dispose",r),n[u.id]=!0,e.memory.geometries++),u}function a(h){const u=h.attributes;for(const g in u)A.update(u[g],i.ARRAY_BUFFER);const d=h.morphAttributes;for(const g in d){const C=d[g];for(let p=0,f=C.length;p<f;p++)A.update(C[p],i.ARRAY_BUFFER)}}function c(h){const u=[],d=h.index,g=h.attributes.position;let C=0;if(d!==null){const E=d.array;C=d.version;for(let I=0,x=E.length;I<x;I+=3){const z=E[I+0],D=E[I+1],y=E[I+2];u.push(z,D,D,y,y,z)}}else if(g!==void 0){const E=g.array;C=g.version;for(let I=0,x=E.length/3-1;I<x;I+=3){const z=I+0,D=I+1,y=I+2;u.push(z,D,D,y,y,z)}}else return;const p=new(Fa(u)?Wa:Ga)(u,1);p.version=C;const f=s.get(h);f&&A.remove(f),s.set(h,p)}function l(h){const u=s.get(h);if(u){const d=h.index;d!==null&&u.version<d.version&&c(h)}else c(h);return s.get(h)}return{get:o,update:a,getWireframeAttribute:l}}function cf(i,A,e){let t;function n(u){t=u}let s,r;function o(u){s=u.type,r=u.bytesPerElement}function a(u,d){i.drawElements(t,d,s,u*r),e.update(d,t,1)}function c(u,d,g){g!==0&&(i.drawElementsInstanced(t,d,s,u*r,g),e.update(d,t,g))}function l(u,d,g){if(g===0)return;const C=A.get("WEBGL_multi_draw");if(C===null)for(let p=0;p<g;p++)this.render(u[p]/r,d[p]);else{C.multiDrawElementsWEBGL(t,d,0,s,u,0,g);let p=0;for(let f=0;f<g;f++)p+=d[f];e.update(p,t,1)}}function h(u,d,g,C){if(g===0)return;const p=A.get("WEBGL_multi_draw");if(p===null)for(let f=0;f<u.length;f++)c(u[f]/r,d[f],C[f]);else{p.multiDrawElementsInstancedWEBGL(t,d,0,s,u,0,C,0,g);let f=0;for(let E=0;E<g;E++)f+=d[E];for(let E=0;E<C.length;E++)e.update(f,t,C[E])}}this.setMode=n,this.setIndex=o,this.render=a,this.renderInstances=c,this.renderMultiDraw=l,this.renderMultiDrawInstances=h}function lf(i){const A={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function t(s,r,o){switch(e.calls++,r){case i.TRIANGLES:e.triangles+=o*(s/3);break;case i.LINES:e.lines+=o*(s/2);break;case i.LINE_STRIP:e.lines+=o*(s-1);break;case i.LINE_LOOP:e.lines+=o*s;break;case i.POINTS:e.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r);break}}function n(){e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:A,render:e,programs:null,autoReset:!0,reset:n,update:t}}function hf(i,A,e){const t=new WeakMap,n=new qA;function s(r,o,a){const c=r.morphTargetInfluences,l=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,h=l!==void 0?l.length:0;let u=t.get(o);if(u===void 0||u.count!==h){let P=function(){F.dispose(),t.delete(o),o.removeEventListener("dispose",P)};var d=P;u!==void 0&&u.texture.dispose();const g=o.morphAttributes.position!==void 0,C=o.morphAttributes.normal!==void 0,p=o.morphAttributes.color!==void 0,f=o.morphAttributes.position||[],E=o.morphAttributes.normal||[],I=o.morphAttributes.color||[];let x=0;g===!0&&(x=1),C===!0&&(x=2),p===!0&&(x=3);let z=o.attributes.position.count*x,D=1;z>A.maxTextureSize&&(D=Math.ceil(z/A.maxTextureSize),z=A.maxTextureSize);const y=new Float32Array(z*D*4*h),F=new Ha(y,z,D,h);F.type=Ye,F.needsUpdate=!0;const v=x*4;for(let N=0;N<h;N++){const V=f[N],b=E[N],W=I[N],G=z*D*4*N;for(let K=0;K<V.count;K++){const q=K*v;g===!0&&(n.fromBufferAttribute(V,K),y[G+q+0]=n.x,y[G+q+1]=n.y,y[G+q+2]=n.z,y[G+q+3]=0),C===!0&&(n.fromBufferAttribute(b,K),y[G+q+4]=n.x,y[G+q+5]=n.y,y[G+q+6]=n.z,y[G+q+7]=0),p===!0&&(n.fromBufferAttribute(W,K),y[G+q+8]=n.x,y[G+q+9]=n.y,y[G+q+10]=n.z,y[G+q+11]=W.itemSize===4?n.w:1)}}u={count:h,texture:F,size:new MA(z,D)},t.set(o,u),o.addEventListener("dispose",P)}if(r.isInstancedMesh===!0&&r.morphTexture!==null)a.getUniforms().setValue(i,"morphTexture",r.morphTexture,e);else{let g=0;for(let p=0;p<c.length;p++)g+=c[p];const C=o.morphTargetsRelative?1:1-g;a.getUniforms().setValue(i,"morphTargetBaseInfluence",C),a.getUniforms().setValue(i,"morphTargetInfluences",c)}a.getUniforms().setValue(i,"morphTargetsTexture",u.texture,e),a.getUniforms().setValue(i,"morphTargetsTextureSize",u.size)}return{update:s}}function uf(i,A,e,t){let n=new WeakMap;function s(a){const c=t.render.frame,l=a.geometry,h=A.get(a,l);if(n.get(h)!==c&&(A.update(h),n.set(h,c)),a.isInstancedMesh&&(a.hasEventListener("dispose",o)===!1&&a.addEventListener("dispose",o),n.get(a)!==c&&(e.update(a.instanceMatrix,i.ARRAY_BUFFER),a.instanceColor!==null&&e.update(a.instanceColor,i.ARRAY_BUFFER),n.set(a,c))),a.isSkinnedMesh){const u=a.skeleton;n.get(u)!==c&&(u.update(),n.set(u,c))}return h}function r(){n=new WeakMap}function o(a){const c=a.target;c.removeEventListener("dispose",o),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:s,dispose:r}}class Ka extends ue{constructor(A,e,t,n,s,r,o,a,c,l){if(l=l!==void 0?l:vn,l!==vn&&l!==ti)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");t===void 0&&l===vn&&(t=Sn),t===void 0&&l===ti&&(t=si),super(null,n,s,r,o,a,l,t,c),this.isDepthTexture=!0,this.image={width:A,height:e},this.magFilter=o!==void 0?o:ve,this.minFilter=a!==void 0?a:ve,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(A){return super.copy(A),this.compareFunction=A.compareFunction,this}toJSON(A){const e=super.toJSON(A);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}const qa=new ue,$a=new Ka(1,1);$a.compareFunction=La;const Ac=new Ha,ec=new Kl,tc=new Ya,zo=[],_o=[],Uo=new Float32Array(16),No=new Float32Array(9),Lo=new Float32Array(4);function Un(i,A,e){const t=i[0];if(t<=0||t>0)return i;const n=A*e;let s=zo[n];if(s===void 0&&(s=new Float32Array(n),zo[n]=s),A!==0){t.toArray(s,0);for(let r=1,o=0;r!==A;++r)o+=e,i[r].toArray(s,o)}return s}function ae(i,A){if(i.length!==A.length)return!1;for(let e=0,t=i.length;e<t;e++)if(i[e]!==A[e])return!1;return!0}function ce(i,A){for(let e=0,t=A.length;e<t;e++)i[e]=A[e]}function es(i,A){let e=_o[A];e===void 0&&(e=new Int32Array(A),_o[A]=e);for(let t=0;t!==A;++t)e[t]=i.allocateTextureUnit();return e}function df(i,A){const e=this.cache;e[0]!==A&&(i.uniform1f(this.addr,A),e[0]=A)}function ff(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y)&&(i.uniform2f(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(ae(e,A))return;i.uniform2fv(this.addr,A),ce(e,A)}}function pf(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z)&&(i.uniform3f(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else if(A.r!==void 0)(e[0]!==A.r||e[1]!==A.g||e[2]!==A.b)&&(i.uniform3f(this.addr,A.r,A.g,A.b),e[0]=A.r,e[1]=A.g,e[2]=A.b);else{if(ae(e,A))return;i.uniform3fv(this.addr,A),ce(e,A)}}function gf(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z||e[3]!==A.w)&&(i.uniform4f(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(ae(e,A))return;i.uniform4fv(this.addr,A),ce(e,A)}}function mf(i,A){const e=this.cache,t=A.elements;if(t===void 0){if(ae(e,A))return;i.uniformMatrix2fv(this.addr,!1,A),ce(e,A)}else{if(ae(e,t))return;Lo.set(t),i.uniformMatrix2fv(this.addr,!1,Lo),ce(e,t)}}function Cf(i,A){const e=this.cache,t=A.elements;if(t===void 0){if(ae(e,A))return;i.uniformMatrix3fv(this.addr,!1,A),ce(e,A)}else{if(ae(e,t))return;No.set(t),i.uniformMatrix3fv(this.addr,!1,No),ce(e,t)}}function Mf(i,A){const e=this.cache,t=A.elements;if(t===void 0){if(ae(e,A))return;i.uniformMatrix4fv(this.addr,!1,A),ce(e,A)}else{if(ae(e,t))return;Uo.set(t),i.uniformMatrix4fv(this.addr,!1,Uo),ce(e,t)}}function Pf(i,A){const e=this.cache;e[0]!==A&&(i.uniform1i(this.addr,A),e[0]=A)}function wf(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y)&&(i.uniform2i(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(ae(e,A))return;i.uniform2iv(this.addr,A),ce(e,A)}}function If(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z)&&(i.uniform3i(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else{if(ae(e,A))return;i.uniform3iv(this.addr,A),ce(e,A)}}function vf(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z||e[3]!==A.w)&&(i.uniform4i(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(ae(e,A))return;i.uniform4iv(this.addr,A),ce(e,A)}}function Ef(i,A){const e=this.cache;e[0]!==A&&(i.uniform1ui(this.addr,A),e[0]=A)}function xf(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y)&&(i.uniform2ui(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(ae(e,A))return;i.uniform2uiv(this.addr,A),ce(e,A)}}function Tf(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z)&&(i.uniform3ui(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else{if(ae(e,A))return;i.uniform3uiv(this.addr,A),ce(e,A)}}function yf(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z||e[3]!==A.w)&&(i.uniform4ui(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(ae(e,A))return;i.uniform4uiv(this.addr,A),ce(e,A)}}function Df(i,A,e){const t=this.cache,n=e.allocateTextureUnit();t[0]!==n&&(i.uniform1i(this.addr,n),t[0]=n);const s=this.type===i.SAMPLER_2D_SHADOW?$a:qa;e.setTexture2D(A||s,n)}function Sf(i,A,e){const t=this.cache,n=e.allocateTextureUnit();t[0]!==n&&(i.uniform1i(this.addr,n),t[0]=n),e.setTexture3D(A||ec,n)}function bf(i,A,e){const t=this.cache,n=e.allocateTextureUnit();t[0]!==n&&(i.uniform1i(this.addr,n),t[0]=n),e.setTextureCube(A||tc,n)}function Bf(i,A,e){const t=this.cache,n=e.allocateTextureUnit();t[0]!==n&&(i.uniform1i(this.addr,n),t[0]=n),e.setTexture2DArray(A||Ac,n)}function Rf(i){switch(i){case 5126:return df;case 35664:return ff;case 35665:return pf;case 35666:return gf;case 35674:return mf;case 35675:return Cf;case 35676:return Mf;case 5124:case 35670:return Pf;case 35667:case 35671:return wf;case 35668:case 35672:return If;case 35669:case 35673:return vf;case 5125:return Ef;case 36294:return xf;case 36295:return Tf;case 36296:return yf;case 35678:case 36198:case 36298:case 36306:case 35682:return Df;case 35679:case 36299:case 36307:return Sf;case 35680:case 36300:case 36308:case 36293:return bf;case 36289:case 36303:case 36311:case 36292:return Bf}}function zf(i,A){i.uniform1fv(this.addr,A)}function _f(i,A){const e=Un(A,this.size,2);i.uniform2fv(this.addr,e)}function Uf(i,A){const e=Un(A,this.size,3);i.uniform3fv(this.addr,e)}function Nf(i,A){const e=Un(A,this.size,4);i.uniform4fv(this.addr,e)}function Lf(i,A){const e=Un(A,this.size,4);i.uniformMatrix2fv(this.addr,!1,e)}function Of(i,A){const e=Un(A,this.size,9);i.uniformMatrix3fv(this.addr,!1,e)}function Ff(i,A){const e=Un(A,this.size,16);i.uniformMatrix4fv(this.addr,!1,e)}function Qf(i,A){i.uniform1iv(this.addr,A)}function jf(i,A){i.uniform2iv(this.addr,A)}function Hf(i,A){i.uniform3iv(this.addr,A)}function kf(i,A){i.uniform4iv(this.addr,A)}function Vf(i,A){i.uniform1uiv(this.addr,A)}function Gf(i,A){i.uniform2uiv(this.addr,A)}function Wf(i,A){i.uniform3uiv(this.addr,A)}function Zf(i,A){i.uniform4uiv(this.addr,A)}function Xf(i,A,e){const t=this.cache,n=A.length,s=es(e,n);ae(t,s)||(i.uniform1iv(this.addr,s),ce(t,s));for(let r=0;r!==n;++r)e.setTexture2D(A[r]||qa,s[r])}function Yf(i,A,e){const t=this.cache,n=A.length,s=es(e,n);ae(t,s)||(i.uniform1iv(this.addr,s),ce(t,s));for(let r=0;r!==n;++r)e.setTexture3D(A[r]||ec,s[r])}function Jf(i,A,e){const t=this.cache,n=A.length,s=es(e,n);ae(t,s)||(i.uniform1iv(this.addr,s),ce(t,s));for(let r=0;r!==n;++r)e.setTextureCube(A[r]||tc,s[r])}function Kf(i,A,e){const t=this.cache,n=A.length,s=es(e,n);ae(t,s)||(i.uniform1iv(this.addr,s),ce(t,s));for(let r=0;r!==n;++r)e.setTexture2DArray(A[r]||Ac,s[r])}function qf(i){switch(i){case 5126:return zf;case 35664:return _f;case 35665:return Uf;case 35666:return Nf;case 35674:return Lf;case 35675:return Of;case 35676:return Ff;case 5124:case 35670:return Qf;case 35667:case 35671:return jf;case 35668:case 35672:return Hf;case 35669:case 35673:return kf;case 5125:return Vf;case 36294:return Gf;case 36295:return Wf;case 36296:return Zf;case 35678:case 36198:case 36298:case 36306:case 35682:return Xf;case 35679:case 36299:case 36307:return Yf;case 35680:case 36300:case 36308:case 36293:return Jf;case 36289:case 36303:case 36311:case 36292:return Kf}}class $f{constructor(A,e,t){this.id=A,this.addr=t,this.cache=[],this.type=e.type,this.setValue=Rf(e.type)}}class Ap{constructor(A,e,t){this.id=A,this.addr=t,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=qf(e.type)}}class ep{constructor(A){this.id=A,this.seq=[],this.map={}}setValue(A,e,t){const n=this.seq;for(let s=0,r=n.length;s!==r;++s){const o=n[s];o.setValue(A,e[o.id],t)}}}const Ns=/(\w+)(\])?(\[|\.)?/g;function Oo(i,A){i.seq.push(A),i.map[A.id]=A}function tp(i,A,e){const t=i.name,n=t.length;for(Ns.lastIndex=0;;){const s=Ns.exec(t),r=Ns.lastIndex;let o=s[1];const a=s[2]==="]",c=s[3];if(a&&(o=o|0),c===void 0||c==="["&&r+2===n){Oo(e,c===void 0?new $f(o,i,A):new Ap(o,i,A));break}else{let h=e.map[o];h===void 0&&(h=new ep(o),Oo(e,h)),e=h}}}class ji{constructor(A,e){this.seq=[],this.map={};const t=A.getProgramParameter(e,A.ACTIVE_UNIFORMS);for(let n=0;n<t;++n){const s=A.getActiveUniform(e,n),r=A.getUniformLocation(e,s.name);tp(s,r,this)}}setValue(A,e,t,n){const s=this.map[e];s!==void 0&&s.setValue(A,t,n)}setOptional(A,e,t){const n=e[t];n!==void 0&&this.setValue(A,t,n)}static upload(A,e,t,n){for(let s=0,r=e.length;s!==r;++s){const o=e[s],a=t[o.id];a.needsUpdate!==!1&&o.setValue(A,a.value,n)}}static seqWithValue(A,e){const t=[];for(let n=0,s=A.length;n!==s;++n){const r=A[n];r.id in e&&t.push(r)}return t}}function Fo(i,A,e){const t=i.createShader(A);return i.shaderSource(t,e),i.compileShader(t),t}const np=37297;let ip=0;function sp(i,A){const e=i.split(`
`),t=[],n=Math.max(A-6,0),s=Math.min(A+6,e.length);for(let r=n;r<s;r++){const o=r+1;t.push(`${o===A?">":" "} ${o}: ${e[r]}`)}return t.join(`
`)}function rp(i){const A=WA.getPrimaries(WA.workingColorSpace),e=WA.getPrimaries(i);let t;switch(A===e?t="":A===Zi&&e===Wi?t="LinearDisplayP3ToLinearSRGB":A===Wi&&e===Zi&&(t="LinearSRGBToLinearDisplayP3"),i){case fe:case As:return[t,"LinearTransferOETF"];case Me:case ar:return[t,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",i),[t,"LinearTransferOETF"]}}function Qo(i,A,e){const t=i.getShaderParameter(A,i.COMPILE_STATUS),n=i.getShaderInfoLog(A).trim();if(t&&n==="")return"";const s=/ERROR: 0:(\d+)/.exec(n);if(s){const r=parseInt(s[1]);return e.toUpperCase()+`

`+n+`

`+sp(i.getShaderSource(A),r)}else return n}function op(i,A){const e=rp(A);return`vec4 ${i}( vec4 value ) { return ${e[0]}( ${e[1]}( value ) ); }`}function ap(i,A){let e;switch(A){case Kc:e="Linear";break;case qc:e="Reinhard";break;case $c:e="OptimizedCineon";break;case Al:e="ACESFilmic";break;case tl:e="AgX";break;case nl:e="Neutral";break;case el:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",A),e="Linear"}return"vec3 "+i+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function cp(i){return[i.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",i.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(qn).join(`
`)}function lp(i){const A=[];for(const e in i){const t=i[e];t!==!1&&A.push("#define "+e+" "+t)}return A.join(`
`)}function hp(i,A){const e={},t=i.getProgramParameter(A,i.ACTIVE_ATTRIBUTES);for(let n=0;n<t;n++){const s=i.getActiveAttrib(A,n),r=s.name;let o=1;s.type===i.FLOAT_MAT2&&(o=2),s.type===i.FLOAT_MAT3&&(o=3),s.type===i.FLOAT_MAT4&&(o=4),e[r]={type:s.type,location:i.getAttribLocation(A,r),locationSize:o}}return e}function qn(i){return i!==""}function jo(i,A){const e=A.numSpotLightShadows+A.numSpotLightMaps-A.numSpotLightShadowsWithMaps;return i.replace(/NUM_DIR_LIGHTS/g,A.numDirLights).replace(/NUM_SPOT_LIGHTS/g,A.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,A.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,A.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,A.numPointLights).replace(/NUM_HEMI_LIGHTS/g,A.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,A.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,A.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,A.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,A.numPointLightShadows)}function Ho(i,A){return i.replace(/NUM_CLIPPING_PLANES/g,A.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,A.numClippingPlanes-A.numClipIntersection)}const up=/^[ \t]*#include +<([\w\d./]+)>/gm;function $s(i){return i.replace(up,fp)}const dp=new Map;function fp(i,A){let e=bA[A];if(e===void 0){const t=dp.get(A);if(t!==void 0)e=bA[t],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',A,t);else throw new Error("Can not resolve #include <"+A+">")}return $s(e)}const pp=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function ko(i){return i.replace(pp,gp)}function gp(i,A,e,t){let n="";for(let s=parseInt(A);s<parseInt(e);s++)n+=t.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return n}function Vo(i){let A=`precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;return i.precision==="highp"?A+=`
#define HIGH_PRECISION`:i.precision==="mediump"?A+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(A+=`
#define LOW_PRECISION`),A}function mp(i){let A="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===va?A="SHADOWMAP_TYPE_PCF":i.shadowMapType===Ea?A="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===at&&(A="SHADOWMAP_TYPE_VSM"),A}function Cp(i){let A="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case Tn:case yn:A="ENVMAP_TYPE_CUBE";break;case qi:A="ENVMAP_TYPE_CUBE_UV";break}return A}function Mp(i){let A="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case yn:A="ENVMAP_MODE_REFRACTION";break}return A}function Pp(i){let A="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case xa:A="ENVMAP_BLENDING_MULTIPLY";break;case Yc:A="ENVMAP_BLENDING_MIX";break;case Jc:A="ENVMAP_BLENDING_ADD";break}return A}function wp(i){const A=i.envMapCubeUVHeight;if(A===null)return null;const e=Math.log2(A)-2,t=1/A;return{texelWidth:1/(3*Math.max(Math.pow(2,e),7*16)),texelHeight:t,maxMip:e}}function Ip(i,A,e,t){const n=i.getContext(),s=e.defines;let r=e.vertexShader,o=e.fragmentShader;const a=mp(e),c=Cp(e),l=Mp(e),h=Pp(e),u=wp(e),d=cp(e),g=lp(s),C=n.createProgram();let p,f,E=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(p=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,g].filter(qn).join(`
`),p.length>0&&(p+=`
`),f=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,g].filter(qn).join(`
`),f.length>0&&(f+=`
`)):(p=[Vo(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,g,e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",e.batching?"#define USE_BATCHING":"",e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.instancingMorph?"#define USE_INSTANCING_MORPH":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+l:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+a:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.useLegacyLights?"#define LEGACY_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(qn).join(`
`),f=[Vo(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,g,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+l:"",e.envMap?"#define "+h:"",u?"#define CUBEUV_TEXEL_WIDTH "+u.texelWidth:"",u?"#define CUBEUV_TEXEL_HEIGHT "+u.texelHeight:"",u?"#define CUBEUV_MAX_MIP "+u.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.dispersion?"#define USE_DISPERSION":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+a:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.useLegacyLights?"#define LEGACY_LIGHTS":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==bt?"#define TONE_MAPPING":"",e.toneMapping!==bt?bA.tonemapping_pars_fragment:"",e.toneMapping!==bt?ap("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",bA.colorspace_pars_fragment,op("linearToOutputTexel",e.outputColorSpace),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(qn).join(`
`)),r=$s(r),r=jo(r,e),r=Ho(r,e),o=$s(o),o=jo(o,e),o=Ho(o,e),r=ko(r),o=ko(o),e.isRawShaderMaterial!==!0&&(E=`#version 300 es
`,p=[d,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+p,f=["#define varying in",e.glslVersion===io?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===io?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+f);const I=E+p+r,x=E+f+o,z=Fo(n,n.VERTEX_SHADER,I),D=Fo(n,n.FRAGMENT_SHADER,x);n.attachShader(C,z),n.attachShader(C,D),e.index0AttributeName!==void 0?n.bindAttribLocation(C,0,e.index0AttributeName):e.morphTargets===!0&&n.bindAttribLocation(C,0,"position"),n.linkProgram(C);function y(N){if(i.debug.checkShaderErrors){const V=n.getProgramInfoLog(C).trim(),b=n.getShaderInfoLog(z).trim(),W=n.getShaderInfoLog(D).trim();let G=!0,K=!0;if(n.getProgramParameter(C,n.LINK_STATUS)===!1)if(G=!1,typeof i.debug.onShaderError=="function")i.debug.onShaderError(n,C,z,D);else{const q=Qo(n,z,"vertex"),H=Qo(n,D,"fragment");console.error("THREE.WebGLProgram: Shader Error "+n.getError()+" - VALIDATE_STATUS "+n.getProgramParameter(C,n.VALIDATE_STATUS)+`

Material Name: `+N.name+`
Material Type: `+N.type+`

Program Info Log: `+V+`
`+q+`
`+H)}else V!==""?console.warn("THREE.WebGLProgram: Program Info Log:",V):(b===""||W==="")&&(K=!1);K&&(N.diagnostics={runnable:G,programLog:V,vertexShader:{log:b,prefix:p},fragmentShader:{log:W,prefix:f}})}n.deleteShader(z),n.deleteShader(D),F=new ji(n,C),v=hp(n,C)}let F;this.getUniforms=function(){return F===void 0&&y(this),F};let v;this.getAttributes=function(){return v===void 0&&y(this),v};let P=e.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return P===!1&&(P=n.getProgramParameter(C,np)),P},this.destroy=function(){t.releaseStatesOfProgram(this),n.deleteProgram(C),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=ip++,this.cacheKey=A,this.usedTimes=1,this.program=C,this.vertexShader=z,this.fragmentShader=D,this}let vp=0;class Ep{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(A){const e=A.vertexShader,t=A.fragmentShader,n=this._getShaderStage(e),s=this._getShaderStage(t),r=this._getShaderCacheForMaterial(A);return r.has(n)===!1&&(r.add(n),n.usedTimes++),r.has(s)===!1&&(r.add(s),s.usedTimes++),this}remove(A){const e=this.materialCache.get(A);for(const t of e)t.usedTimes--,t.usedTimes===0&&this.shaderCache.delete(t.code);return this.materialCache.delete(A),this}getVertexShaderID(A){return this._getShaderStage(A.vertexShader).id}getFragmentShaderID(A){return this._getShaderStage(A.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(A){const e=this.materialCache;let t=e.get(A);return t===void 0&&(t=new Set,e.set(A,t)),t}_getShaderStage(A){const e=this.shaderCache;let t=e.get(A);return t===void 0&&(t=new xp(A),e.set(A,t)),t}}class xp{constructor(A){this.id=vp++,this.code=A,this.usedTimes=0}}function Tp(i,A,e,t,n,s,r){const o=new ka,a=new Ep,c=new Set,l=[],h=n.logarithmicDepthBuffer,u=n.vertexTextures;let d=n.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function C(v){return c.add(v),v===0?"uv":`uv${v}`}function p(v,P,N,V,b){const W=V.fog,G=b.geometry,K=v.isMeshStandardMaterial?V.environment:null,q=(v.isMeshStandardMaterial?e:A).get(v.envMap||K),H=q&&q.mapping===qi?q.image.height:null,AA=g[v.type];v.precision!==null&&(d=n.getMaxPrecision(v.precision),d!==v.precision&&console.warn("THREE.WebGLProgram.getParameters:",v.precision,"not supported, using",d,"instead."));const $=G.morphAttributes.position||G.morphAttributes.normal||G.morphAttributes.color,uA=$!==void 0?$.length:0;let LA=0;G.morphAttributes.position!==void 0&&(LA=1),G.morphAttributes.normal!==void 0&&(LA=2),G.morphAttributes.color!==void 0&&(LA=3);let ZA,k,eA,lA;if(AA){const kA=Ge[AA];ZA=kA.vertexShader,k=kA.fragmentShader}else ZA=v.vertexShader,k=v.fragmentShader,a.update(v),eA=a.getVertexShaderID(v),lA=a.getFragmentShaderID(v);const iA=i.getRenderTarget(),OA=b.isInstancedMesh===!0,zA=b.isBatchedMesh===!0,_=!!v.map,YA=!!v.matcap,gA=!!q,JA=!!v.aoMap,CA=!!v.lightMap,FA=!!v.bumpMap,xA=!!v.normalMap,jA=!!v.displacementMap,ee=!!v.emissiveMap,T=!!v.metalnessMap,M=!!v.roughnessMap,j=v.anisotropy>0,Z=v.clearcoat>0,Y=v.dispersion>0,J=v.iridescence>0,pA=v.sheen>0,oA=v.transmission>0,rA=j&&!!v.anisotropyMap,IA=Z&&!!v.clearcoatMap,nA=Z&&!!v.clearcoatNormalMap,fA=Z&&!!v.clearcoatRoughnessMap,HA=J&&!!v.iridescenceMap,mA=J&&!!v.iridescenceThicknessMap,cA=pA&&!!v.sheenColorMap,TA=pA&&!!v.sheenRoughnessMap,_A=!!v.specularMap,KA=!!v.specularColorMap,DA=!!v.specularIntensityMap,m=oA&&!!v.transmissionMap,B=oA&&!!v.thicknessMap,U=!!v.gradientMap,X=!!v.alphaMap,tA=v.alphaTest>0,yA=!!v.alphaHash,UA=!!v.extensions;let ne=bt;v.toneMapped&&(iA===null||iA.isXRRenderTarget===!0)&&(ne=i.toneMapping);const le={shaderID:AA,shaderType:v.type,shaderName:v.name,vertexShader:ZA,fragmentShader:k,defines:v.defines,customVertexShaderID:eA,customFragmentShaderID:lA,isRawShaderMaterial:v.isRawShaderMaterial===!0,glslVersion:v.glslVersion,precision:d,batching:zA,instancing:OA,instancingColor:OA&&b.instanceColor!==null,instancingMorph:OA&&b.morphTexture!==null,supportsVertexTextures:u,outputColorSpace:iA===null?i.outputColorSpace:iA.isXRRenderTarget===!0?iA.texture.colorSpace:fe,alphaToCoverage:!!v.alphaToCoverage,map:_,matcap:YA,envMap:gA,envMapMode:gA&&q.mapping,envMapCubeUVHeight:H,aoMap:JA,lightMap:CA,bumpMap:FA,normalMap:xA,displacementMap:u&&jA,emissiveMap:ee,normalMapObjectSpace:xA&&v.normalMapType===wl,normalMapTangentSpace:xA&&v.normalMapType===or,metalnessMap:T,roughnessMap:M,anisotropy:j,anisotropyMap:rA,clearcoat:Z,clearcoatMap:IA,clearcoatNormalMap:nA,clearcoatRoughnessMap:fA,dispersion:Y,iridescence:J,iridescenceMap:HA,iridescenceThicknessMap:mA,sheen:pA,sheenColorMap:cA,sheenRoughnessMap:TA,specularMap:_A,specularColorMap:KA,specularIntensityMap:DA,transmission:oA,transmissionMap:m,thicknessMap:B,gradientMap:U,opaque:v.transparent===!1&&v.blending===In&&v.alphaToCoverage===!1,alphaMap:X,alphaTest:tA,alphaHash:yA,combine:v.combine,mapUv:_&&C(v.map.channel),aoMapUv:JA&&C(v.aoMap.channel),lightMapUv:CA&&C(v.lightMap.channel),bumpMapUv:FA&&C(v.bumpMap.channel),normalMapUv:xA&&C(v.normalMap.channel),displacementMapUv:jA&&C(v.displacementMap.channel),emissiveMapUv:ee&&C(v.emissiveMap.channel),metalnessMapUv:T&&C(v.metalnessMap.channel),roughnessMapUv:M&&C(v.roughnessMap.channel),anisotropyMapUv:rA&&C(v.anisotropyMap.channel),clearcoatMapUv:IA&&C(v.clearcoatMap.channel),clearcoatNormalMapUv:nA&&C(v.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:fA&&C(v.clearcoatRoughnessMap.channel),iridescenceMapUv:HA&&C(v.iridescenceMap.channel),iridescenceThicknessMapUv:mA&&C(v.iridescenceThicknessMap.channel),sheenColorMapUv:cA&&C(v.sheenColorMap.channel),sheenRoughnessMapUv:TA&&C(v.sheenRoughnessMap.channel),specularMapUv:_A&&C(v.specularMap.channel),specularColorMapUv:KA&&C(v.specularColorMap.channel),specularIntensityMapUv:DA&&C(v.specularIntensityMap.channel),transmissionMapUv:m&&C(v.transmissionMap.channel),thicknessMapUv:B&&C(v.thicknessMap.channel),alphaMapUv:X&&C(v.alphaMap.channel),vertexTangents:!!G.attributes.tangent&&(xA||j),vertexColors:v.vertexColors,vertexAlphas:v.vertexColors===!0&&!!G.attributes.color&&G.attributes.color.itemSize===4,pointsUvs:b.isPoints===!0&&!!G.attributes.uv&&(_||X),fog:!!W,useFog:v.fog===!0,fogExp2:!!W&&W.isFogExp2,flatShading:v.flatShading===!0,sizeAttenuation:v.sizeAttenuation===!0,logarithmicDepthBuffer:h,skinning:b.isSkinnedMesh===!0,morphTargets:G.morphAttributes.position!==void 0,morphNormals:G.morphAttributes.normal!==void 0,morphColors:G.morphAttributes.color!==void 0,morphTargetsCount:uA,morphTextureStride:LA,numDirLights:P.directional.length,numPointLights:P.point.length,numSpotLights:P.spot.length,numSpotLightMaps:P.spotLightMap.length,numRectAreaLights:P.rectArea.length,numHemiLights:P.hemi.length,numDirLightShadows:P.directionalShadowMap.length,numPointLightShadows:P.pointShadowMap.length,numSpotLightShadows:P.spotShadowMap.length,numSpotLightShadowsWithMaps:P.numSpotLightShadowsWithMaps,numLightProbes:P.numLightProbes,numClippingPlanes:r.numPlanes,numClipIntersection:r.numIntersection,dithering:v.dithering,shadowMapEnabled:i.shadowMap.enabled&&N.length>0,shadowMapType:i.shadowMap.type,toneMapping:ne,useLegacyLights:i._useLegacyLights,decodeVideoTexture:_&&v.map.isVideoTexture===!0&&WA.getTransfer(v.map.colorSpace)===Ae,premultipliedAlpha:v.premultipliedAlpha,doubleSided:v.side===Ze,flipSided:v.side===Te,useDepthPacking:v.depthPacking>=0,depthPacking:v.depthPacking||0,index0AttributeName:v.index0AttributeName,extensionClipCullDistance:UA&&v.extensions.clipCullDistance===!0&&t.has("WEBGL_clip_cull_distance"),extensionMultiDraw:UA&&v.extensions.multiDraw===!0&&t.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:t.has("KHR_parallel_shader_compile"),customProgramCacheKey:v.customProgramCacheKey()};return le.vertexUv1s=c.has(1),le.vertexUv2s=c.has(2),le.vertexUv3s=c.has(3),c.clear(),le}function f(v){const P=[];if(v.shaderID?P.push(v.shaderID):(P.push(v.customVertexShaderID),P.push(v.customFragmentShaderID)),v.defines!==void 0)for(const N in v.defines)P.push(N),P.push(v.defines[N]);return v.isRawShaderMaterial===!1&&(E(P,v),I(P,v),P.push(i.outputColorSpace)),P.push(v.customProgramCacheKey),P.join()}function E(v,P){v.push(P.precision),v.push(P.outputColorSpace),v.push(P.envMapMode),v.push(P.envMapCubeUVHeight),v.push(P.mapUv),v.push(P.alphaMapUv),v.push(P.lightMapUv),v.push(P.aoMapUv),v.push(P.bumpMapUv),v.push(P.normalMapUv),v.push(P.displacementMapUv),v.push(P.emissiveMapUv),v.push(P.metalnessMapUv),v.push(P.roughnessMapUv),v.push(P.anisotropyMapUv),v.push(P.clearcoatMapUv),v.push(P.clearcoatNormalMapUv),v.push(P.clearcoatRoughnessMapUv),v.push(P.iridescenceMapUv),v.push(P.iridescenceThicknessMapUv),v.push(P.sheenColorMapUv),v.push(P.sheenRoughnessMapUv),v.push(P.specularMapUv),v.push(P.specularColorMapUv),v.push(P.specularIntensityMapUv),v.push(P.transmissionMapUv),v.push(P.thicknessMapUv),v.push(P.combine),v.push(P.fogExp2),v.push(P.sizeAttenuation),v.push(P.morphTargetsCount),v.push(P.morphAttributeCount),v.push(P.numDirLights),v.push(P.numPointLights),v.push(P.numSpotLights),v.push(P.numSpotLightMaps),v.push(P.numHemiLights),v.push(P.numRectAreaLights),v.push(P.numDirLightShadows),v.push(P.numPointLightShadows),v.push(P.numSpotLightShadows),v.push(P.numSpotLightShadowsWithMaps),v.push(P.numLightProbes),v.push(P.shadowMapType),v.push(P.toneMapping),v.push(P.numClippingPlanes),v.push(P.numClipIntersection),v.push(P.depthPacking)}function I(v,P){o.disableAll(),P.supportsVertexTextures&&o.enable(0),P.instancing&&o.enable(1),P.instancingColor&&o.enable(2),P.instancingMorph&&o.enable(3),P.matcap&&o.enable(4),P.envMap&&o.enable(5),P.normalMapObjectSpace&&o.enable(6),P.normalMapTangentSpace&&o.enable(7),P.clearcoat&&o.enable(8),P.iridescence&&o.enable(9),P.alphaTest&&o.enable(10),P.vertexColors&&o.enable(11),P.vertexAlphas&&o.enable(12),P.vertexUv1s&&o.enable(13),P.vertexUv2s&&o.enable(14),P.vertexUv3s&&o.enable(15),P.vertexTangents&&o.enable(16),P.anisotropy&&o.enable(17),P.alphaHash&&o.enable(18),P.batching&&o.enable(19),P.dispersion&&o.enable(20),v.push(o.mask),o.disableAll(),P.fog&&o.enable(0),P.useFog&&o.enable(1),P.flatShading&&o.enable(2),P.logarithmicDepthBuffer&&o.enable(3),P.skinning&&o.enable(4),P.morphTargets&&o.enable(5),P.morphNormals&&o.enable(6),P.morphColors&&o.enable(7),P.premultipliedAlpha&&o.enable(8),P.shadowMapEnabled&&o.enable(9),P.useLegacyLights&&o.enable(10),P.doubleSided&&o.enable(11),P.flipSided&&o.enable(12),P.useDepthPacking&&o.enable(13),P.dithering&&o.enable(14),P.transmission&&o.enable(15),P.sheen&&o.enable(16),P.opaque&&o.enable(17),P.pointsUvs&&o.enable(18),P.decodeVideoTexture&&o.enable(19),P.alphaToCoverage&&o.enable(20),v.push(o.mask)}function x(v){const P=g[v.type];let N;if(P){const V=Ge[P];N=ch.clone(V.uniforms)}else N=v.uniforms;return N}function z(v,P){let N;for(let V=0,b=l.length;V<b;V++){const W=l[V];if(W.cacheKey===P){N=W,++N.usedTimes;break}}return N===void 0&&(N=new Ip(i,P,v,s),l.push(N)),N}function D(v){if(--v.usedTimes===0){const P=l.indexOf(v);l[P]=l[l.length-1],l.pop(),v.destroy()}}function y(v){a.remove(v)}function F(){a.dispose()}return{getParameters:p,getProgramCacheKey:f,getUniforms:x,acquireProgram:z,releaseProgram:D,releaseShaderCache:y,programs:l,dispose:F}}function yp(){let i=new WeakMap;function A(s){let r=i.get(s);return r===void 0&&(r={},i.set(s,r)),r}function e(s){i.delete(s)}function t(s,r,o){i.get(s)[r]=o}function n(){i=new WeakMap}return{get:A,remove:e,update:t,dispose:n}}function Dp(i,A){return i.groupOrder!==A.groupOrder?i.groupOrder-A.groupOrder:i.renderOrder!==A.renderOrder?i.renderOrder-A.renderOrder:i.material.id!==A.material.id?i.material.id-A.material.id:i.z!==A.z?i.z-A.z:i.id-A.id}function Go(i,A){return i.groupOrder!==A.groupOrder?i.groupOrder-A.groupOrder:i.renderOrder!==A.renderOrder?i.renderOrder-A.renderOrder:i.z!==A.z?A.z-i.z:i.id-A.id}function Wo(){const i=[];let A=0;const e=[],t=[],n=[];function s(){A=0,e.length=0,t.length=0,n.length=0}function r(h,u,d,g,C,p){let f=i[A];return f===void 0?(f={id:h.id,object:h,geometry:u,material:d,groupOrder:g,renderOrder:h.renderOrder,z:C,group:p},i[A]=f):(f.id=h.id,f.object=h,f.geometry=u,f.material=d,f.groupOrder=g,f.renderOrder=h.renderOrder,f.z=C,f.group=p),A++,f}function o(h,u,d,g,C,p){const f=r(h,u,d,g,C,p);d.transmission>0?t.push(f):d.transparent===!0?n.push(f):e.push(f)}function a(h,u,d,g,C,p){const f=r(h,u,d,g,C,p);d.transmission>0?t.unshift(f):d.transparent===!0?n.unshift(f):e.unshift(f)}function c(h,u){e.length>1&&e.sort(h||Dp),t.length>1&&t.sort(u||Go),n.length>1&&n.sort(u||Go)}function l(){for(let h=A,u=i.length;h<u;h++){const d=i[h];if(d.id===null)break;d.id=null,d.object=null,d.geometry=null,d.material=null,d.group=null}}return{opaque:e,transmissive:t,transparent:n,init:s,push:o,unshift:a,finish:l,sort:c}}function Sp(){let i=new WeakMap;function A(t,n){const s=i.get(t);let r;return s===void 0?(r=new Wo,i.set(t,[r])):n>=s.length?(r=new Wo,s.push(r)):r=s[n],r}function e(){i=new WeakMap}return{get:A,dispose:e}}function bp(){const i={};return{get:function(A){if(i[A.id]!==void 0)return i[A.id];let e;switch(A.type){case"DirectionalLight":e={direction:new S,color:new wA};break;case"SpotLight":e={position:new S,direction:new S,color:new wA,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new S,color:new wA,distance:0,decay:0};break;case"HemisphereLight":e={direction:new S,skyColor:new wA,groundColor:new wA};break;case"RectAreaLight":e={color:new wA,position:new S,halfWidth:new S,halfHeight:new S};break}return i[A.id]=e,e}}}function Bp(){const i={};return{get:function(A){if(i[A.id]!==void 0)return i[A.id];let e;switch(A.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new MA};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new MA};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new MA,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[A.id]=e,e}}}let Rp=0;function zp(i,A){return(A.castShadow?2:0)-(i.castShadow?2:0)+(A.map?1:0)-(i.map?1:0)}function _p(i){const A=new bp,e=Bp(),t={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)t.probe.push(new S);const n=new S,s=new RA,r=new RA;function o(c,l){let h=0,u=0,d=0;for(let N=0;N<9;N++)t.probe[N].set(0,0,0);let g=0,C=0,p=0,f=0,E=0,I=0,x=0,z=0,D=0,y=0,F=0;c.sort(zp);const v=l===!0?Math.PI:1;for(let N=0,V=c.length;N<V;N++){const b=c[N],W=b.color,G=b.intensity,K=b.distance,q=b.shadow&&b.shadow.map?b.shadow.map.texture:null;if(b.isAmbientLight)h+=W.r*G*v,u+=W.g*G*v,d+=W.b*G*v;else if(b.isLightProbe){for(let H=0;H<9;H++)t.probe[H].addScaledVector(b.sh.coefficients[H],G);F++}else if(b.isDirectionalLight){const H=A.get(b);if(H.color.copy(b.color).multiplyScalar(b.intensity*v),b.castShadow){const AA=b.shadow,$=e.get(b);$.shadowBias=AA.bias,$.shadowNormalBias=AA.normalBias,$.shadowRadius=AA.radius,$.shadowMapSize=AA.mapSize,t.directionalShadow[g]=$,t.directionalShadowMap[g]=q,t.directionalShadowMatrix[g]=b.shadow.matrix,I++}t.directional[g]=H,g++}else if(b.isSpotLight){const H=A.get(b);H.position.setFromMatrixPosition(b.matrixWorld),H.color.copy(W).multiplyScalar(G*v),H.distance=K,H.coneCos=Math.cos(b.angle),H.penumbraCos=Math.cos(b.angle*(1-b.penumbra)),H.decay=b.decay,t.spot[p]=H;const AA=b.shadow;if(b.map&&(t.spotLightMap[D]=b.map,D++,AA.updateMatrices(b),b.castShadow&&y++),t.spotLightMatrix[p]=AA.matrix,b.castShadow){const $=e.get(b);$.shadowBias=AA.bias,$.shadowNormalBias=AA.normalBias,$.shadowRadius=AA.radius,$.shadowMapSize=AA.mapSize,t.spotShadow[p]=$,t.spotShadowMap[p]=q,z++}p++}else if(b.isRectAreaLight){const H=A.get(b);H.color.copy(W).multiplyScalar(G),H.halfWidth.set(b.width*.5,0,0),H.halfHeight.set(0,b.height*.5,0),t.rectArea[f]=H,f++}else if(b.isPointLight){const H=A.get(b);if(H.color.copy(b.color).multiplyScalar(b.intensity*v),H.distance=b.distance,H.decay=b.decay,b.castShadow){const AA=b.shadow,$=e.get(b);$.shadowBias=AA.bias,$.shadowNormalBias=AA.normalBias,$.shadowRadius=AA.radius,$.shadowMapSize=AA.mapSize,$.shadowCameraNear=AA.camera.near,$.shadowCameraFar=AA.camera.far,t.pointShadow[C]=$,t.pointShadowMap[C]=q,t.pointShadowMatrix[C]=b.shadow.matrix,x++}t.point[C]=H,C++}else if(b.isHemisphereLight){const H=A.get(b);H.skyColor.copy(b.color).multiplyScalar(G*v),H.groundColor.copy(b.groundColor).multiplyScalar(G*v),t.hemi[E]=H,E++}}f>0&&(i.has("OES_texture_float_linear")===!0?(t.rectAreaLTC1=sA.LTC_FLOAT_1,t.rectAreaLTC2=sA.LTC_FLOAT_2):(t.rectAreaLTC1=sA.LTC_HALF_1,t.rectAreaLTC2=sA.LTC_HALF_2)),t.ambient[0]=h,t.ambient[1]=u,t.ambient[2]=d;const P=t.hash;(P.directionalLength!==g||P.pointLength!==C||P.spotLength!==p||P.rectAreaLength!==f||P.hemiLength!==E||P.numDirectionalShadows!==I||P.numPointShadows!==x||P.numSpotShadows!==z||P.numSpotMaps!==D||P.numLightProbes!==F)&&(t.directional.length=g,t.spot.length=p,t.rectArea.length=f,t.point.length=C,t.hemi.length=E,t.directionalShadow.length=I,t.directionalShadowMap.length=I,t.pointShadow.length=x,t.pointShadowMap.length=x,t.spotShadow.length=z,t.spotShadowMap.length=z,t.directionalShadowMatrix.length=I,t.pointShadowMatrix.length=x,t.spotLightMatrix.length=z+D-y,t.spotLightMap.length=D,t.numSpotLightShadowsWithMaps=y,t.numLightProbes=F,P.directionalLength=g,P.pointLength=C,P.spotLength=p,P.rectAreaLength=f,P.hemiLength=E,P.numDirectionalShadows=I,P.numPointShadows=x,P.numSpotShadows=z,P.numSpotMaps=D,P.numLightProbes=F,t.version=Rp++)}function a(c,l){let h=0,u=0,d=0,g=0,C=0;const p=l.matrixWorldInverse;for(let f=0,E=c.length;f<E;f++){const I=c[f];if(I.isDirectionalLight){const x=t.directional[h];x.direction.setFromMatrixPosition(I.matrixWorld),n.setFromMatrixPosition(I.target.matrixWorld),x.direction.sub(n),x.direction.transformDirection(p),h++}else if(I.isSpotLight){const x=t.spot[d];x.position.setFromMatrixPosition(I.matrixWorld),x.position.applyMatrix4(p),x.direction.setFromMatrixPosition(I.matrixWorld),n.setFromMatrixPosition(I.target.matrixWorld),x.direction.sub(n),x.direction.transformDirection(p),d++}else if(I.isRectAreaLight){const x=t.rectArea[g];x.position.setFromMatrixPosition(I.matrixWorld),x.position.applyMatrix4(p),r.identity(),s.copy(I.matrixWorld),s.premultiply(p),r.extractRotation(s),x.halfWidth.set(I.width*.5,0,0),x.halfHeight.set(0,I.height*.5,0),x.halfWidth.applyMatrix4(r),x.halfHeight.applyMatrix4(r),g++}else if(I.isPointLight){const x=t.point[u];x.position.setFromMatrixPosition(I.matrixWorld),x.position.applyMatrix4(p),u++}else if(I.isHemisphereLight){const x=t.hemi[C];x.direction.setFromMatrixPosition(I.matrixWorld),x.direction.transformDirection(p),C++}}}return{setup:o,setupView:a,state:t}}function Zo(i){const A=new _p(i),e=[],t=[];function n(l){c.camera=l,e.length=0,t.length=0}function s(l){e.push(l)}function r(l){t.push(l)}function o(l){A.setup(e,l)}function a(l){A.setupView(e,l)}const c={lightsArray:e,shadowsArray:t,camera:null,lights:A,transmissionRenderTarget:{}};return{init:n,state:c,setupLights:o,setupLightsView:a,pushLight:s,pushShadow:r}}function Up(i){let A=new WeakMap;function e(n,s=0){const r=A.get(n);let o;return r===void 0?(o=new Zo(i),A.set(n,[o])):s>=r.length?(o=new Zo(i),r.push(o)):o=r[s],o}function t(){A=new WeakMap}return{get:e,dispose:t}}class Np extends ke{constructor(A){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Ml,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(A)}copy(A){return super.copy(A),this.depthPacking=A.depthPacking,this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this}}class Lp extends ke{constructor(A){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(A)}copy(A){return super.copy(A),this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this}}const Op=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Fp=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Qp(i,A,e){let t=new lr;const n=new MA,s=new MA,r=new qA,o=new Np({depthPacking:Pl}),a=new Lp,c={},l=e.maxTextureSize,h={[ht]:Te,[Te]:ht,[Ze]:Ze},u=new Rt({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new MA},radius:{value:4}},vertexShader:Op,fragmentShader:Fp}),d=u.clone();d.defines.HORIZONTAL_PASS=1;const g=new Ve;g.setAttribute("position",new xe(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const C=new Ee(g,u),p=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=va;let f=this.type;this.render=function(D,y,F){if(p.enabled===!1||p.autoUpdate===!1&&p.needsUpdate===!1||D.length===0)return;const v=i.getRenderTarget(),P=i.getActiveCubeFace(),N=i.getActiveMipmapLevel(),V=i.state;V.setBlending(St),V.buffers.color.setClear(1,1,1,1),V.buffers.depth.setTest(!0),V.setScissorTest(!1);const b=f!==at&&this.type===at,W=f===at&&this.type!==at;for(let G=0,K=D.length;G<K;G++){const q=D[G],H=q.shadow;if(H===void 0){console.warn("THREE.WebGLShadowMap:",q,"has no shadow.");continue}if(H.autoUpdate===!1&&H.needsUpdate===!1)continue;n.copy(H.mapSize);const AA=H.getFrameExtents();if(n.multiply(AA),s.copy(H.mapSize),(n.x>l||n.y>l)&&(n.x>l&&(s.x=Math.floor(l/AA.x),n.x=s.x*AA.x,H.mapSize.x=s.x),n.y>l&&(s.y=Math.floor(l/AA.y),n.y=s.y*AA.y,H.mapSize.y=s.y)),H.map===null||b===!0||W===!0){const uA=this.type!==at?{minFilter:ve,magFilter:ve}:{};H.map!==null&&H.map.dispose(),H.map=new Xt(n.x,n.y,uA),H.map.texture.name=q.name+".shadowMap",H.camera.updateProjectionMatrix()}i.setRenderTarget(H.map),i.clear();const $=H.getViewportCount();for(let uA=0;uA<$;uA++){const LA=H.getViewport(uA);r.set(s.x*LA.x,s.y*LA.y,s.x*LA.z,s.y*LA.w),V.viewport(r),H.updateMatrices(q,uA),t=H.getFrustum(),x(y,F,H.camera,q,this.type)}H.isPointLightShadow!==!0&&this.type===at&&E(H,F),H.needsUpdate=!1}f=this.type,p.needsUpdate=!1,i.setRenderTarget(v,P,N)};function E(D,y){const F=A.update(C);u.defines.VSM_SAMPLES!==D.blurSamples&&(u.defines.VSM_SAMPLES=D.blurSamples,d.defines.VSM_SAMPLES=D.blurSamples,u.needsUpdate=!0,d.needsUpdate=!0),D.mapPass===null&&(D.mapPass=new Xt(n.x,n.y)),u.uniforms.shadow_pass.value=D.map.texture,u.uniforms.resolution.value=D.mapSize,u.uniforms.radius.value=D.radius,i.setRenderTarget(D.mapPass),i.clear(),i.renderBufferDirect(y,null,F,u,C,null),d.uniforms.shadow_pass.value=D.mapPass.texture,d.uniforms.resolution.value=D.mapSize,d.uniforms.radius.value=D.radius,i.setRenderTarget(D.map),i.clear(),i.renderBufferDirect(y,null,F,d,C,null)}function I(D,y,F,v){let P=null;const N=F.isPointLight===!0?D.customDistanceMaterial:D.customDepthMaterial;if(N!==void 0)P=N;else if(P=F.isPointLight===!0?a:o,i.localClippingEnabled&&y.clipShadows===!0&&Array.isArray(y.clippingPlanes)&&y.clippingPlanes.length!==0||y.displacementMap&&y.displacementScale!==0||y.alphaMap&&y.alphaTest>0||y.map&&y.alphaTest>0){const V=P.uuid,b=y.uuid;let W=c[V];W===void 0&&(W={},c[V]=W);let G=W[b];G===void 0&&(G=P.clone(),W[b]=G,y.addEventListener("dispose",z)),P=G}if(P.visible=y.visible,P.wireframe=y.wireframe,v===at?P.side=y.shadowSide!==null?y.shadowSide:y.side:P.side=y.shadowSide!==null?y.shadowSide:h[y.side],P.alphaMap=y.alphaMap,P.alphaTest=y.alphaTest,P.map=y.map,P.clipShadows=y.clipShadows,P.clippingPlanes=y.clippingPlanes,P.clipIntersection=y.clipIntersection,P.displacementMap=y.displacementMap,P.displacementScale=y.displacementScale,P.displacementBias=y.displacementBias,P.wireframeLinewidth=y.wireframeLinewidth,P.linewidth=y.linewidth,F.isPointLight===!0&&P.isMeshDistanceMaterial===!0){const V=i.properties.get(P);V.light=F}return P}function x(D,y,F,v,P){if(D.visible===!1)return;if(D.layers.test(y.layers)&&(D.isMesh||D.isLine||D.isPoints)&&(D.castShadow||D.receiveShadow&&P===at)&&(!D.frustumCulled||t.intersectsObject(D))){D.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse,D.matrixWorld);const b=A.update(D),W=D.material;if(Array.isArray(W)){const G=b.groups;for(let K=0,q=G.length;K<q;K++){const H=G[K],AA=W[H.materialIndex];if(AA&&AA.visible){const $=I(D,AA,v,P);D.onBeforeShadow(i,D,y,F,b,$,H),i.renderBufferDirect(F,null,b,$,D,H),D.onAfterShadow(i,D,y,F,b,$,H)}}}else if(W.visible){const G=I(D,W,v,P);D.onBeforeShadow(i,D,y,F,b,G,null),i.renderBufferDirect(F,null,b,G,D,null),D.onAfterShadow(i,D,y,F,b,G,null)}}const V=D.children;for(let b=0,W=V.length;b<W;b++)x(V[b],y,F,v,P)}function z(D){D.target.removeEventListener("dispose",z);for(const F in c){const v=c[F],P=D.target.uuid;P in v&&(v[P].dispose(),delete v[P])}}}function jp(i){function A(){let m=!1;const B=new qA;let U=null;const X=new qA(0,0,0,0);return{setMask:function(tA){U!==tA&&!m&&(i.colorMask(tA,tA,tA,tA),U=tA)},setLocked:function(tA){m=tA},setClear:function(tA,yA,UA,ne,le){le===!0&&(tA*=ne,yA*=ne,UA*=ne),B.set(tA,yA,UA,ne),X.equals(B)===!1&&(i.clearColor(tA,yA,UA,ne),X.copy(B))},reset:function(){m=!1,U=null,X.set(-1,0,0,0)}}}function e(){let m=!1,B=null,U=null,X=null;return{setTest:function(tA){tA?lA(i.DEPTH_TEST):iA(i.DEPTH_TEST)},setMask:function(tA){B!==tA&&!m&&(i.depthMask(tA),B=tA)},setFunc:function(tA){if(U!==tA){switch(tA){case Hc:i.depthFunc(i.NEVER);break;case kc:i.depthFunc(i.ALWAYS);break;case Vc:i.depthFunc(i.LESS);break;case Hi:i.depthFunc(i.LEQUAL);break;case Gc:i.depthFunc(i.EQUAL);break;case Wc:i.depthFunc(i.GEQUAL);break;case Zc:i.depthFunc(i.GREATER);break;case Xc:i.depthFunc(i.NOTEQUAL);break;default:i.depthFunc(i.LEQUAL)}U=tA}},setLocked:function(tA){m=tA},setClear:function(tA){X!==tA&&(i.clearDepth(tA),X=tA)},reset:function(){m=!1,B=null,U=null,X=null}}}function t(){let m=!1,B=null,U=null,X=null,tA=null,yA=null,UA=null,ne=null,le=null;return{setTest:function(kA){m||(kA?lA(i.STENCIL_TEST):iA(i.STENCIL_TEST))},setMask:function(kA){B!==kA&&!m&&(i.stencilMask(kA),B=kA)},setFunc:function(kA,se,$A){(U!==kA||X!==se||tA!==$A)&&(i.stencilFunc(kA,se,$A),U=kA,X=se,tA=$A)},setOp:function(kA,se,$A){(yA!==kA||UA!==se||ne!==$A)&&(i.stencilOp(kA,se,$A),yA=kA,UA=se,ne=$A)},setLocked:function(kA){m=kA},setClear:function(kA){le!==kA&&(i.clearStencil(kA),le=kA)},reset:function(){m=!1,B=null,U=null,X=null,tA=null,yA=null,UA=null,ne=null,le=null}}}const n=new A,s=new e,r=new t,o=new WeakMap,a=new WeakMap;let c={},l={},h=new WeakMap,u=[],d=null,g=!1,C=null,p=null,f=null,E=null,I=null,x=null,z=null,D=new wA(0,0,0),y=0,F=!1,v=null,P=null,N=null,V=null,b=null;const W=i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let G=!1,K=0;const q=i.getParameter(i.VERSION);q.indexOf("WebGL")!==-1?(K=parseFloat(/^WebGL (\d)/.exec(q)[1]),G=K>=1):q.indexOf("OpenGL ES")!==-1&&(K=parseFloat(/^OpenGL ES (\d)/.exec(q)[1]),G=K>=2);let H=null,AA={};const $=i.getParameter(i.SCISSOR_BOX),uA=i.getParameter(i.VIEWPORT),LA=new qA().fromArray($),ZA=new qA().fromArray(uA);function k(m,B,U,X){const tA=new Uint8Array(4),yA=i.createTexture();i.bindTexture(m,yA),i.texParameteri(m,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(m,i.TEXTURE_MAG_FILTER,i.NEAREST);for(let UA=0;UA<U;UA++)m===i.TEXTURE_3D||m===i.TEXTURE_2D_ARRAY?i.texImage3D(B,0,i.RGBA,1,1,X,0,i.RGBA,i.UNSIGNED_BYTE,tA):i.texImage2D(B+UA,0,i.RGBA,1,1,0,i.RGBA,i.UNSIGNED_BYTE,tA);return yA}const eA={};eA[i.TEXTURE_2D]=k(i.TEXTURE_2D,i.TEXTURE_2D,1),eA[i.TEXTURE_CUBE_MAP]=k(i.TEXTURE_CUBE_MAP,i.TEXTURE_CUBE_MAP_POSITIVE_X,6),eA[i.TEXTURE_2D_ARRAY]=k(i.TEXTURE_2D_ARRAY,i.TEXTURE_2D_ARRAY,1,1),eA[i.TEXTURE_3D]=k(i.TEXTURE_3D,i.TEXTURE_3D,1,1),n.setClear(0,0,0,1),s.setClear(1),r.setClear(0),lA(i.DEPTH_TEST),s.setFunc(Hi),FA(!1),xA(Tr),lA(i.CULL_FACE),JA(St);function lA(m){c[m]!==!0&&(i.enable(m),c[m]=!0)}function iA(m){c[m]!==!1&&(i.disable(m),c[m]=!1)}function OA(m,B){return l[m]!==B?(i.bindFramebuffer(m,B),l[m]=B,m===i.DRAW_FRAMEBUFFER&&(l[i.FRAMEBUFFER]=B),m===i.FRAMEBUFFER&&(l[i.DRAW_FRAMEBUFFER]=B),!0):!1}function zA(m,B){let U=u,X=!1;if(m){U=h.get(B),U===void 0&&(U=[],h.set(B,U));const tA=m.textures;if(U.length!==tA.length||U[0]!==i.COLOR_ATTACHMENT0){for(let yA=0,UA=tA.length;yA<UA;yA++)U[yA]=i.COLOR_ATTACHMENT0+yA;U.length=tA.length,X=!0}}else U[0]!==i.BACK&&(U[0]=i.BACK,X=!0);X&&i.drawBuffers(U)}function _(m){return d!==m?(i.useProgram(m),d=m,!0):!1}const YA={[Vt]:i.FUNC_ADD,[xc]:i.FUNC_SUBTRACT,[Tc]:i.FUNC_REVERSE_SUBTRACT};YA[yc]=i.MIN,YA[Dc]=i.MAX;const gA={[Sc]:i.ZERO,[bc]:i.ONE,[Bc]:i.SRC_COLOR,[Zs]:i.SRC_ALPHA,[Lc]:i.SRC_ALPHA_SATURATE,[Uc]:i.DST_COLOR,[zc]:i.DST_ALPHA,[Rc]:i.ONE_MINUS_SRC_COLOR,[Xs]:i.ONE_MINUS_SRC_ALPHA,[Nc]:i.ONE_MINUS_DST_COLOR,[_c]:i.ONE_MINUS_DST_ALPHA,[Oc]:i.CONSTANT_COLOR,[Fc]:i.ONE_MINUS_CONSTANT_COLOR,[Qc]:i.CONSTANT_ALPHA,[jc]:i.ONE_MINUS_CONSTANT_ALPHA};function JA(m,B,U,X,tA,yA,UA,ne,le,kA){if(m===St){g===!0&&(iA(i.BLEND),g=!1);return}if(g===!1&&(lA(i.BLEND),g=!0),m!==Ec){if(m!==C||kA!==F){if((p!==Vt||I!==Vt)&&(i.blendEquation(i.FUNC_ADD),p=Vt,I=Vt),kA)switch(m){case In:i.blendFuncSeparate(i.ONE,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA);break;case yr:i.blendFunc(i.ONE,i.ONE);break;case Dr:i.blendFuncSeparate(i.ZERO,i.ONE_MINUS_SRC_COLOR,i.ZERO,i.ONE);break;case Sr:i.blendFuncSeparate(i.ZERO,i.SRC_COLOR,i.ZERO,i.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",m);break}else switch(m){case In:i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA);break;case yr:i.blendFunc(i.SRC_ALPHA,i.ONE);break;case Dr:i.blendFuncSeparate(i.ZERO,i.ONE_MINUS_SRC_COLOR,i.ZERO,i.ONE);break;case Sr:i.blendFunc(i.ZERO,i.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",m);break}f=null,E=null,x=null,z=null,D.set(0,0,0),y=0,C=m,F=kA}return}tA=tA||B,yA=yA||U,UA=UA||X,(B!==p||tA!==I)&&(i.blendEquationSeparate(YA[B],YA[tA]),p=B,I=tA),(U!==f||X!==E||yA!==x||UA!==z)&&(i.blendFuncSeparate(gA[U],gA[X],gA[yA],gA[UA]),f=U,E=X,x=yA,z=UA),(ne.equals(D)===!1||le!==y)&&(i.blendColor(ne.r,ne.g,ne.b,le),D.copy(ne),y=le),C=m,F=!1}function CA(m,B){m.side===Ze?iA(i.CULL_FACE):lA(i.CULL_FACE);let U=m.side===Te;B&&(U=!U),FA(U),m.blending===In&&m.transparent===!1?JA(St):JA(m.blending,m.blendEquation,m.blendSrc,m.blendDst,m.blendEquationAlpha,m.blendSrcAlpha,m.blendDstAlpha,m.blendColor,m.blendAlpha,m.premultipliedAlpha),s.setFunc(m.depthFunc),s.setTest(m.depthTest),s.setMask(m.depthWrite),n.setMask(m.colorWrite);const X=m.stencilWrite;r.setTest(X),X&&(r.setMask(m.stencilWriteMask),r.setFunc(m.stencilFunc,m.stencilRef,m.stencilFuncMask),r.setOp(m.stencilFail,m.stencilZFail,m.stencilZPass)),ee(m.polygonOffset,m.polygonOffsetFactor,m.polygonOffsetUnits),m.alphaToCoverage===!0?lA(i.SAMPLE_ALPHA_TO_COVERAGE):iA(i.SAMPLE_ALPHA_TO_COVERAGE)}function FA(m){v!==m&&(m?i.frontFace(i.CW):i.frontFace(i.CCW),v=m)}function xA(m){m!==Ic?(lA(i.CULL_FACE),m!==P&&(m===Tr?i.cullFace(i.BACK):m===vc?i.cullFace(i.FRONT):i.cullFace(i.FRONT_AND_BACK))):iA(i.CULL_FACE),P=m}function jA(m){m!==N&&(G&&i.lineWidth(m),N=m)}function ee(m,B,U){m?(lA(i.POLYGON_OFFSET_FILL),(V!==B||b!==U)&&(i.polygonOffset(B,U),V=B,b=U)):iA(i.POLYGON_OFFSET_FILL)}function T(m){m?lA(i.SCISSOR_TEST):iA(i.SCISSOR_TEST)}function M(m){m===void 0&&(m=i.TEXTURE0+W-1),H!==m&&(i.activeTexture(m),H=m)}function j(m,B,U){U===void 0&&(H===null?U=i.TEXTURE0+W-1:U=H);let X=AA[U];X===void 0&&(X={type:void 0,texture:void 0},AA[U]=X),(X.type!==m||X.texture!==B)&&(H!==U&&(i.activeTexture(U),H=U),i.bindTexture(m,B||eA[m]),X.type=m,X.texture=B)}function Z(){const m=AA[H];m!==void 0&&m.type!==void 0&&(i.bindTexture(m.type,null),m.type=void 0,m.texture=void 0)}function Y(){try{i.compressedTexImage2D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function J(){try{i.compressedTexImage3D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function pA(){try{i.texSubImage2D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function oA(){try{i.texSubImage3D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function rA(){try{i.compressedTexSubImage2D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function IA(){try{i.compressedTexSubImage3D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function nA(){try{i.texStorage2D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function fA(){try{i.texStorage3D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function HA(){try{i.texImage2D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function mA(){try{i.texImage3D.apply(i,arguments)}catch(m){console.error("THREE.WebGLState:",m)}}function cA(m){LA.equals(m)===!1&&(i.scissor(m.x,m.y,m.z,m.w),LA.copy(m))}function TA(m){ZA.equals(m)===!1&&(i.viewport(m.x,m.y,m.z,m.w),ZA.copy(m))}function _A(m,B){let U=a.get(B);U===void 0&&(U=new WeakMap,a.set(B,U));let X=U.get(m);X===void 0&&(X=i.getUniformBlockIndex(B,m.name),U.set(m,X))}function KA(m,B){const X=a.get(B).get(m);o.get(B)!==X&&(i.uniformBlockBinding(B,X,m.__bindingPointIndex),o.set(B,X))}function DA(){i.disable(i.BLEND),i.disable(i.CULL_FACE),i.disable(i.DEPTH_TEST),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SCISSOR_TEST),i.disable(i.STENCIL_TEST),i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),i.blendEquation(i.FUNC_ADD),i.blendFunc(i.ONE,i.ZERO),i.blendFuncSeparate(i.ONE,i.ZERO,i.ONE,i.ZERO),i.blendColor(0,0,0,0),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(i.LESS),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(i.ALWAYS,0,4294967295),i.stencilOp(i.KEEP,i.KEEP,i.KEEP),i.clearStencil(0),i.cullFace(i.BACK),i.frontFace(i.CCW),i.polygonOffset(0,0),i.activeTexture(i.TEXTURE0),i.bindFramebuffer(i.FRAMEBUFFER,null),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,null),i.bindFramebuffer(i.READ_FRAMEBUFFER,null),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),c={},H=null,AA={},l={},h=new WeakMap,u=[],d=null,g=!1,C=null,p=null,f=null,E=null,I=null,x=null,z=null,D=new wA(0,0,0),y=0,F=!1,v=null,P=null,N=null,V=null,b=null,LA.set(0,0,i.canvas.width,i.canvas.height),ZA.set(0,0,i.canvas.width,i.canvas.height),n.reset(),s.reset(),r.reset()}return{buffers:{color:n,depth:s,stencil:r},enable:lA,disable:iA,bindFramebuffer:OA,drawBuffers:zA,useProgram:_,setBlending:JA,setMaterial:CA,setFlipSided:FA,setCullFace:xA,setLineWidth:jA,setPolygonOffset:ee,setScissorTest:T,activeTexture:M,bindTexture:j,unbindTexture:Z,compressedTexImage2D:Y,compressedTexImage3D:J,texImage2D:HA,texImage3D:mA,updateUBOMapping:_A,uniformBlockBinding:KA,texStorage2D:nA,texStorage3D:fA,texSubImage2D:pA,texSubImage3D:oA,compressedTexSubImage2D:rA,compressedTexSubImage3D:IA,scissor:cA,viewport:TA,reset:DA}}function Hp(i,A,e,t,n,s,r){const o=A.has("WEBGL_multisampled_render_to_texture")?A.get("WEBGL_multisampled_render_to_texture"):null,a=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new MA,l=new WeakMap;let h;const u=new WeakMap;let d=!1;try{d=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(T,M){return d?new OffscreenCanvas(T,M):ii("canvas")}function C(T,M,j){let Z=1;const Y=ee(T);if((Y.width>j||Y.height>j)&&(Z=j/Math.max(Y.width,Y.height)),Z<1)if(typeof HTMLImageElement<"u"&&T instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&T instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&T instanceof ImageBitmap||typeof VideoFrame<"u"&&T instanceof VideoFrame){const J=Math.floor(Z*Y.width),pA=Math.floor(Z*Y.height);h===void 0&&(h=g(J,pA));const oA=M?g(J,pA):h;return oA.width=J,oA.height=pA,oA.getContext("2d").drawImage(T,0,0,J,pA),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+Y.width+"x"+Y.height+") to ("+J+"x"+pA+")."),oA}else return"data"in T&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+Y.width+"x"+Y.height+")."),T;return T}function p(T){return T.generateMipmaps&&T.minFilter!==ve&&T.minFilter!==be}function f(T){i.generateMipmap(T)}function E(T,M,j,Z,Y=!1){if(T!==null){if(i[T]!==void 0)return i[T];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+T+"'")}let J=M;if(M===i.RED&&(j===i.FLOAT&&(J=i.R32F),j===i.HALF_FLOAT&&(J=i.R16F),j===i.UNSIGNED_BYTE&&(J=i.R8)),M===i.RED_INTEGER&&(j===i.UNSIGNED_BYTE&&(J=i.R8UI),j===i.UNSIGNED_SHORT&&(J=i.R16UI),j===i.UNSIGNED_INT&&(J=i.R32UI),j===i.BYTE&&(J=i.R8I),j===i.SHORT&&(J=i.R16I),j===i.INT&&(J=i.R32I)),M===i.RG&&(j===i.FLOAT&&(J=i.RG32F),j===i.HALF_FLOAT&&(J=i.RG16F),j===i.UNSIGNED_BYTE&&(J=i.RG8)),M===i.RG_INTEGER&&(j===i.UNSIGNED_BYTE&&(J=i.RG8UI),j===i.UNSIGNED_SHORT&&(J=i.RG16UI),j===i.UNSIGNED_INT&&(J=i.RG32UI),j===i.BYTE&&(J=i.RG8I),j===i.SHORT&&(J=i.RG16I),j===i.INT&&(J=i.RG32I)),M===i.RGB&&j===i.UNSIGNED_INT_5_9_9_9_REV&&(J=i.RGB9_E5),M===i.RGBA){const pA=Y?Gi:WA.getTransfer(Z);j===i.FLOAT&&(J=i.RGBA32F),j===i.HALF_FLOAT&&(J=i.RGBA16F),j===i.UNSIGNED_BYTE&&(J=pA===Ae?i.SRGB8_ALPHA8:i.RGBA8),j===i.UNSIGNED_SHORT_4_4_4_4&&(J=i.RGBA4),j===i.UNSIGNED_SHORT_5_5_5_1&&(J=i.RGB5_A1)}return(J===i.R16F||J===i.R32F||J===i.RG16F||J===i.RG32F||J===i.RGBA16F||J===i.RGBA32F)&&A.get("EXT_color_buffer_float"),J}function I(T,M){return p(T)===!0||T.isFramebufferTexture&&T.minFilter!==ve&&T.minFilter!==be?Math.log2(Math.max(M.width,M.height))+1:T.mipmaps!==void 0&&T.mipmaps.length>0?T.mipmaps.length:T.isCompressedTexture&&Array.isArray(T.image)?M.mipmaps.length:1}function x(T){const M=T.target;M.removeEventListener("dispose",x),D(M),M.isVideoTexture&&l.delete(M)}function z(T){const M=T.target;M.removeEventListener("dispose",z),F(M)}function D(T){const M=t.get(T);if(M.__webglInit===void 0)return;const j=T.source,Z=u.get(j);if(Z){const Y=Z[M.__cacheKey];Y.usedTimes--,Y.usedTimes===0&&y(T),Object.keys(Z).length===0&&u.delete(j)}t.remove(T)}function y(T){const M=t.get(T);i.deleteTexture(M.__webglTexture);const j=T.source,Z=u.get(j);delete Z[M.__cacheKey],r.memory.textures--}function F(T){const M=t.get(T);if(T.depthTexture&&T.depthTexture.dispose(),T.isWebGLCubeRenderTarget)for(let Z=0;Z<6;Z++){if(Array.isArray(M.__webglFramebuffer[Z]))for(let Y=0;Y<M.__webglFramebuffer[Z].length;Y++)i.deleteFramebuffer(M.__webglFramebuffer[Z][Y]);else i.deleteFramebuffer(M.__webglFramebuffer[Z]);M.__webglDepthbuffer&&i.deleteRenderbuffer(M.__webglDepthbuffer[Z])}else{if(Array.isArray(M.__webglFramebuffer))for(let Z=0;Z<M.__webglFramebuffer.length;Z++)i.deleteFramebuffer(M.__webglFramebuffer[Z]);else i.deleteFramebuffer(M.__webglFramebuffer);if(M.__webglDepthbuffer&&i.deleteRenderbuffer(M.__webglDepthbuffer),M.__webglMultisampledFramebuffer&&i.deleteFramebuffer(M.__webglMultisampledFramebuffer),M.__webglColorRenderbuffer)for(let Z=0;Z<M.__webglColorRenderbuffer.length;Z++)M.__webglColorRenderbuffer[Z]&&i.deleteRenderbuffer(M.__webglColorRenderbuffer[Z]);M.__webglDepthRenderbuffer&&i.deleteRenderbuffer(M.__webglDepthRenderbuffer)}const j=T.textures;for(let Z=0,Y=j.length;Z<Y;Z++){const J=t.get(j[Z]);J.__webglTexture&&(i.deleteTexture(J.__webglTexture),r.memory.textures--),t.remove(j[Z])}t.remove(T)}let v=0;function P(){v=0}function N(){const T=v;return T>=n.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+T+" texture units while this GPU supports only "+n.maxTextures),v+=1,T}function V(T){const M=[];return M.push(T.wrapS),M.push(T.wrapT),M.push(T.wrapR||0),M.push(T.magFilter),M.push(T.minFilter),M.push(T.anisotropy),M.push(T.internalFormat),M.push(T.format),M.push(T.type),M.push(T.generateMipmaps),M.push(T.premultiplyAlpha),M.push(T.flipY),M.push(T.unpackAlignment),M.push(T.colorSpace),M.join()}function b(T,M){const j=t.get(T);if(T.isVideoTexture&&xA(T),T.isRenderTargetTexture===!1&&T.version>0&&j.__version!==T.version){const Z=T.image;if(Z===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Z.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{LA(j,T,M);return}}e.bindTexture(i.TEXTURE_2D,j.__webglTexture,i.TEXTURE0+M)}function W(T,M){const j=t.get(T);if(T.version>0&&j.__version!==T.version){LA(j,T,M);return}e.bindTexture(i.TEXTURE_2D_ARRAY,j.__webglTexture,i.TEXTURE0+M)}function G(T,M){const j=t.get(T);if(T.version>0&&j.__version!==T.version){LA(j,T,M);return}e.bindTexture(i.TEXTURE_3D,j.__webglTexture,i.TEXTURE0+M)}function K(T,M){const j=t.get(T);if(T.version>0&&j.__version!==T.version){ZA(j,T,M);return}e.bindTexture(i.TEXTURE_CUBE_MAP,j.__webglTexture,i.TEXTURE0+M)}const q={[Dn]:i.REPEAT,[yt]:i.CLAMP_TO_EDGE,[ki]:i.MIRRORED_REPEAT},H={[ve]:i.NEAREST,[ya]:i.NEAREST_MIPMAP_NEAREST,[Kn]:i.NEAREST_MIPMAP_LINEAR,[be]:i.LINEAR,[Qi]:i.LINEAR_MIPMAP_NEAREST,[ct]:i.LINEAR_MIPMAP_LINEAR},AA={[Il]:i.NEVER,[Dl]:i.ALWAYS,[vl]:i.LESS,[La]:i.LEQUAL,[El]:i.EQUAL,[yl]:i.GEQUAL,[xl]:i.GREATER,[Tl]:i.NOTEQUAL};function $(T,M){if(M.type===Ye&&A.has("OES_texture_float_linear")===!1&&(M.magFilter===be||M.magFilter===Qi||M.magFilter===Kn||M.magFilter===ct||M.minFilter===be||M.minFilter===Qi||M.minFilter===Kn||M.minFilter===ct)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),i.texParameteri(T,i.TEXTURE_WRAP_S,q[M.wrapS]),i.texParameteri(T,i.TEXTURE_WRAP_T,q[M.wrapT]),(T===i.TEXTURE_3D||T===i.TEXTURE_2D_ARRAY)&&i.texParameteri(T,i.TEXTURE_WRAP_R,q[M.wrapR]),i.texParameteri(T,i.TEXTURE_MAG_FILTER,H[M.magFilter]),i.texParameteri(T,i.TEXTURE_MIN_FILTER,H[M.minFilter]),M.compareFunction&&(i.texParameteri(T,i.TEXTURE_COMPARE_MODE,i.COMPARE_REF_TO_TEXTURE),i.texParameteri(T,i.TEXTURE_COMPARE_FUNC,AA[M.compareFunction])),A.has("EXT_texture_filter_anisotropic")===!0){if(M.magFilter===ve||M.minFilter!==Kn&&M.minFilter!==ct||M.type===Ye&&A.has("OES_texture_float_linear")===!1)return;if(M.anisotropy>1||t.get(M).__currentAnisotropy){const j=A.get("EXT_texture_filter_anisotropic");i.texParameterf(T,j.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(M.anisotropy,n.getMaxAnisotropy())),t.get(M).__currentAnisotropy=M.anisotropy}}}function uA(T,M){let j=!1;T.__webglInit===void 0&&(T.__webglInit=!0,M.addEventListener("dispose",x));const Z=M.source;let Y=u.get(Z);Y===void 0&&(Y={},u.set(Z,Y));const J=V(M);if(J!==T.__cacheKey){Y[J]===void 0&&(Y[J]={texture:i.createTexture(),usedTimes:0},r.memory.textures++,j=!0),Y[J].usedTimes++;const pA=Y[T.__cacheKey];pA!==void 0&&(Y[T.__cacheKey].usedTimes--,pA.usedTimes===0&&y(M)),T.__cacheKey=J,T.__webglTexture=Y[J].texture}return j}function LA(T,M,j){let Z=i.TEXTURE_2D;(M.isDataArrayTexture||M.isCompressedArrayTexture)&&(Z=i.TEXTURE_2D_ARRAY),M.isData3DTexture&&(Z=i.TEXTURE_3D);const Y=uA(T,M),J=M.source;e.bindTexture(Z,T.__webglTexture,i.TEXTURE0+j);const pA=t.get(J);if(J.version!==pA.__version||Y===!0){e.activeTexture(i.TEXTURE0+j);const oA=WA.getPrimaries(WA.workingColorSpace),rA=M.colorSpace===Tt?null:WA.getPrimaries(M.colorSpace),IA=M.colorSpace===Tt||oA===rA?i.NONE:i.BROWSER_DEFAULT_WEBGL;i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,M.flipY),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,M.premultiplyAlpha),i.pixelStorei(i.UNPACK_ALIGNMENT,M.unpackAlignment),i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,IA);let nA=C(M.image,!1,n.maxTextureSize);nA=jA(M,nA);const fA=s.convert(M.format,M.colorSpace),HA=s.convert(M.type);let mA=E(M.internalFormat,fA,HA,M.colorSpace,M.isVideoTexture);$(Z,M);let cA;const TA=M.mipmaps,_A=M.isVideoTexture!==!0,KA=pA.__version===void 0||Y===!0,DA=J.dataReady,m=I(M,nA);if(M.isDepthTexture)mA=i.DEPTH_COMPONENT16,M.type===Ye?mA=i.DEPTH_COMPONENT32F:M.type===Sn?mA=i.DEPTH_COMPONENT24:M.type===si&&(mA=i.DEPTH24_STENCIL8),KA&&(_A?e.texStorage2D(i.TEXTURE_2D,1,mA,nA.width,nA.height):e.texImage2D(i.TEXTURE_2D,0,mA,nA.width,nA.height,0,fA,HA,null));else if(M.isDataTexture)if(TA.length>0){_A&&KA&&e.texStorage2D(i.TEXTURE_2D,m,mA,TA[0].width,TA[0].height);for(let B=0,U=TA.length;B<U;B++)cA=TA[B],_A?DA&&e.texSubImage2D(i.TEXTURE_2D,B,0,0,cA.width,cA.height,fA,HA,cA.data):e.texImage2D(i.TEXTURE_2D,B,mA,cA.width,cA.height,0,fA,HA,cA.data);M.generateMipmaps=!1}else _A?(KA&&e.texStorage2D(i.TEXTURE_2D,m,mA,nA.width,nA.height),DA&&e.texSubImage2D(i.TEXTURE_2D,0,0,0,nA.width,nA.height,fA,HA,nA.data)):e.texImage2D(i.TEXTURE_2D,0,mA,nA.width,nA.height,0,fA,HA,nA.data);else if(M.isCompressedTexture)if(M.isCompressedArrayTexture){_A&&KA&&e.texStorage3D(i.TEXTURE_2D_ARRAY,m,mA,TA[0].width,TA[0].height,nA.depth);for(let B=0,U=TA.length;B<U;B++)cA=TA[B],M.format!==je?fA!==null?_A?DA&&e.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY,B,0,0,0,cA.width,cA.height,nA.depth,fA,cA.data,0,0):e.compressedTexImage3D(i.TEXTURE_2D_ARRAY,B,mA,cA.width,cA.height,nA.depth,0,cA.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_A?DA&&e.texSubImage3D(i.TEXTURE_2D_ARRAY,B,0,0,0,cA.width,cA.height,nA.depth,fA,HA,cA.data):e.texImage3D(i.TEXTURE_2D_ARRAY,B,mA,cA.width,cA.height,nA.depth,0,fA,HA,cA.data)}else{_A&&KA&&e.texStorage2D(i.TEXTURE_2D,m,mA,TA[0].width,TA[0].height);for(let B=0,U=TA.length;B<U;B++)cA=TA[B],M.format!==je?fA!==null?_A?DA&&e.compressedTexSubImage2D(i.TEXTURE_2D,B,0,0,cA.width,cA.height,fA,cA.data):e.compressedTexImage2D(i.TEXTURE_2D,B,mA,cA.width,cA.height,0,cA.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_A?DA&&e.texSubImage2D(i.TEXTURE_2D,B,0,0,cA.width,cA.height,fA,HA,cA.data):e.texImage2D(i.TEXTURE_2D,B,mA,cA.width,cA.height,0,fA,HA,cA.data)}else if(M.isDataArrayTexture)_A?(KA&&e.texStorage3D(i.TEXTURE_2D_ARRAY,m,mA,nA.width,nA.height,nA.depth),DA&&e.texSubImage3D(i.TEXTURE_2D_ARRAY,0,0,0,0,nA.width,nA.height,nA.depth,fA,HA,nA.data)):e.texImage3D(i.TEXTURE_2D_ARRAY,0,mA,nA.width,nA.height,nA.depth,0,fA,HA,nA.data);else if(M.isData3DTexture)_A?(KA&&e.texStorage3D(i.TEXTURE_3D,m,mA,nA.width,nA.height,nA.depth),DA&&e.texSubImage3D(i.TEXTURE_3D,0,0,0,0,nA.width,nA.height,nA.depth,fA,HA,nA.data)):e.texImage3D(i.TEXTURE_3D,0,mA,nA.width,nA.height,nA.depth,0,fA,HA,nA.data);else if(M.isFramebufferTexture){if(KA)if(_A)e.texStorage2D(i.TEXTURE_2D,m,mA,nA.width,nA.height);else{let B=nA.width,U=nA.height;for(let X=0;X<m;X++)e.texImage2D(i.TEXTURE_2D,X,mA,B,U,0,fA,HA,null),B>>=1,U>>=1}}else if(TA.length>0){if(_A&&KA){const B=ee(TA[0]);e.texStorage2D(i.TEXTURE_2D,m,mA,B.width,B.height)}for(let B=0,U=TA.length;B<U;B++)cA=TA[B],_A?DA&&e.texSubImage2D(i.TEXTURE_2D,B,0,0,fA,HA,cA):e.texImage2D(i.TEXTURE_2D,B,mA,fA,HA,cA);M.generateMipmaps=!1}else if(_A){if(KA){const B=ee(nA);e.texStorage2D(i.TEXTURE_2D,m,mA,B.width,B.height)}DA&&e.texSubImage2D(i.TEXTURE_2D,0,0,0,fA,HA,nA)}else e.texImage2D(i.TEXTURE_2D,0,mA,fA,HA,nA);p(M)&&f(Z),pA.__version=J.version,M.onUpdate&&M.onUpdate(M)}T.__version=M.version}function ZA(T,M,j){if(M.image.length!==6)return;const Z=uA(T,M),Y=M.source;e.bindTexture(i.TEXTURE_CUBE_MAP,T.__webglTexture,i.TEXTURE0+j);const J=t.get(Y);if(Y.version!==J.__version||Z===!0){e.activeTexture(i.TEXTURE0+j);const pA=WA.getPrimaries(WA.workingColorSpace),oA=M.colorSpace===Tt?null:WA.getPrimaries(M.colorSpace),rA=M.colorSpace===Tt||pA===oA?i.NONE:i.BROWSER_DEFAULT_WEBGL;i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,M.flipY),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,M.premultiplyAlpha),i.pixelStorei(i.UNPACK_ALIGNMENT,M.unpackAlignment),i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,rA);const IA=M.isCompressedTexture||M.image[0].isCompressedTexture,nA=M.image[0]&&M.image[0].isDataTexture,fA=[];for(let U=0;U<6;U++)!IA&&!nA?fA[U]=C(M.image[U],!0,n.maxCubemapSize):fA[U]=nA?M.image[U].image:M.image[U],fA[U]=jA(M,fA[U]);const HA=fA[0],mA=s.convert(M.format,M.colorSpace),cA=s.convert(M.type),TA=E(M.internalFormat,mA,cA,M.colorSpace),_A=M.isVideoTexture!==!0,KA=J.__version===void 0||Z===!0,DA=Y.dataReady;let m=I(M,HA);$(i.TEXTURE_CUBE_MAP,M);let B;if(IA){_A&&KA&&e.texStorage2D(i.TEXTURE_CUBE_MAP,m,TA,HA.width,HA.height);for(let U=0;U<6;U++){B=fA[U].mipmaps;for(let X=0;X<B.length;X++){const tA=B[X];M.format!==je?mA!==null?_A?DA&&e.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,X,0,0,tA.width,tA.height,mA,tA.data):e.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,X,TA,tA.width,tA.height,0,tA.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):_A?DA&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,X,0,0,tA.width,tA.height,mA,cA,tA.data):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,X,TA,tA.width,tA.height,0,mA,cA,tA.data)}}}else{if(B=M.mipmaps,_A&&KA){B.length>0&&m++;const U=ee(fA[0]);e.texStorage2D(i.TEXTURE_CUBE_MAP,m,TA,U.width,U.height)}for(let U=0;U<6;U++)if(nA){_A?DA&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,0,0,0,fA[U].width,fA[U].height,mA,cA,fA[U].data):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,0,TA,fA[U].width,fA[U].height,0,mA,cA,fA[U].data);for(let X=0;X<B.length;X++){const yA=B[X].image[U].image;_A?DA&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,X+1,0,0,yA.width,yA.height,mA,cA,yA.data):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,X+1,TA,yA.width,yA.height,0,mA,cA,yA.data)}}else{_A?DA&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,0,0,0,mA,cA,fA[U]):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,0,TA,mA,cA,fA[U]);for(let X=0;X<B.length;X++){const tA=B[X];_A?DA&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,X+1,0,0,mA,cA,tA.image[U]):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+U,X+1,TA,mA,cA,tA.image[U])}}}p(M)&&f(i.TEXTURE_CUBE_MAP),J.__version=Y.version,M.onUpdate&&M.onUpdate(M)}T.__version=M.version}function k(T,M,j,Z,Y,J){const pA=s.convert(j.format,j.colorSpace),oA=s.convert(j.type),rA=E(j.internalFormat,pA,oA,j.colorSpace);if(!t.get(M).__hasExternalTextures){const nA=Math.max(1,M.width>>J),fA=Math.max(1,M.height>>J);Y===i.TEXTURE_3D||Y===i.TEXTURE_2D_ARRAY?e.texImage3D(Y,J,rA,nA,fA,M.depth,0,pA,oA,null):e.texImage2D(Y,J,rA,nA,fA,0,pA,oA,null)}e.bindFramebuffer(i.FRAMEBUFFER,T),FA(M)?o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER,Z,Y,t.get(j).__webglTexture,0,CA(M)):(Y===i.TEXTURE_2D||Y>=i.TEXTURE_CUBE_MAP_POSITIVE_X&&Y<=i.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&i.framebufferTexture2D(i.FRAMEBUFFER,Z,Y,t.get(j).__webglTexture,J),e.bindFramebuffer(i.FRAMEBUFFER,null)}function eA(T,M,j){if(i.bindRenderbuffer(i.RENDERBUFFER,T),M.depthBuffer&&!M.stencilBuffer){let Z=i.DEPTH_COMPONENT24;if(j||FA(M)){const Y=M.depthTexture;Y&&Y.isDepthTexture&&(Y.type===Ye?Z=i.DEPTH_COMPONENT32F:Y.type===Sn&&(Z=i.DEPTH_COMPONENT24));const J=CA(M);FA(M)?o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER,J,Z,M.width,M.height):i.renderbufferStorageMultisample(i.RENDERBUFFER,J,Z,M.width,M.height)}else i.renderbufferStorage(i.RENDERBUFFER,Z,M.width,M.height);i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.RENDERBUFFER,T)}else if(M.depthBuffer&&M.stencilBuffer){const Z=CA(M);j&&FA(M)===!1?i.renderbufferStorageMultisample(i.RENDERBUFFER,Z,i.DEPTH24_STENCIL8,M.width,M.height):FA(M)?o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER,Z,i.DEPTH24_STENCIL8,M.width,M.height):i.renderbufferStorage(i.RENDERBUFFER,i.DEPTH_STENCIL,M.width,M.height),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.RENDERBUFFER,T)}else{const Z=M.textures;for(let Y=0;Y<Z.length;Y++){const J=Z[Y],pA=s.convert(J.format,J.colorSpace),oA=s.convert(J.type),rA=E(J.internalFormat,pA,oA,J.colorSpace),IA=CA(M);j&&FA(M)===!1?i.renderbufferStorageMultisample(i.RENDERBUFFER,IA,rA,M.width,M.height):FA(M)?o.renderbufferStorageMultisampleEXT(i.RENDERBUFFER,IA,rA,M.width,M.height):i.renderbufferStorage(i.RENDERBUFFER,rA,M.width,M.height)}}i.bindRenderbuffer(i.RENDERBUFFER,null)}function lA(T,M){if(M&&M.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(i.FRAMEBUFFER,T),!(M.depthTexture&&M.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!t.get(M.depthTexture).__webglTexture||M.depthTexture.image.width!==M.width||M.depthTexture.image.height!==M.height)&&(M.depthTexture.image.width=M.width,M.depthTexture.image.height=M.height,M.depthTexture.needsUpdate=!0),b(M.depthTexture,0);const Z=t.get(M.depthTexture).__webglTexture,Y=CA(M);if(M.depthTexture.format===vn)FA(M)?o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.TEXTURE_2D,Z,0,Y):i.framebufferTexture2D(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.TEXTURE_2D,Z,0);else if(M.depthTexture.format===ti)FA(M)?o.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.TEXTURE_2D,Z,0,Y):i.framebufferTexture2D(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.TEXTURE_2D,Z,0);else throw new Error("Unknown depthTexture format")}function iA(T){const M=t.get(T),j=T.isWebGLCubeRenderTarget===!0;if(T.depthTexture&&!M.__autoAllocateDepthBuffer){if(j)throw new Error("target.depthTexture not supported in Cube render targets");lA(M.__webglFramebuffer,T)}else if(j){M.__webglDepthbuffer=[];for(let Z=0;Z<6;Z++)e.bindFramebuffer(i.FRAMEBUFFER,M.__webglFramebuffer[Z]),M.__webglDepthbuffer[Z]=i.createRenderbuffer(),eA(M.__webglDepthbuffer[Z],T,!1)}else e.bindFramebuffer(i.FRAMEBUFFER,M.__webglFramebuffer),M.__webglDepthbuffer=i.createRenderbuffer(),eA(M.__webglDepthbuffer,T,!1);e.bindFramebuffer(i.FRAMEBUFFER,null)}function OA(T,M,j){const Z=t.get(T);M!==void 0&&k(Z.__webglFramebuffer,T,T.texture,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,0),j!==void 0&&iA(T)}function zA(T){const M=T.texture,j=t.get(T),Z=t.get(M);T.addEventListener("dispose",z);const Y=T.textures,J=T.isWebGLCubeRenderTarget===!0,pA=Y.length>1;if(pA||(Z.__webglTexture===void 0&&(Z.__webglTexture=i.createTexture()),Z.__version=M.version,r.memory.textures++),J){j.__webglFramebuffer=[];for(let oA=0;oA<6;oA++)if(M.mipmaps&&M.mipmaps.length>0){j.__webglFramebuffer[oA]=[];for(let rA=0;rA<M.mipmaps.length;rA++)j.__webglFramebuffer[oA][rA]=i.createFramebuffer()}else j.__webglFramebuffer[oA]=i.createFramebuffer()}else{if(M.mipmaps&&M.mipmaps.length>0){j.__webglFramebuffer=[];for(let oA=0;oA<M.mipmaps.length;oA++)j.__webglFramebuffer[oA]=i.createFramebuffer()}else j.__webglFramebuffer=i.createFramebuffer();if(pA)for(let oA=0,rA=Y.length;oA<rA;oA++){const IA=t.get(Y[oA]);IA.__webglTexture===void 0&&(IA.__webglTexture=i.createTexture(),r.memory.textures++)}if(T.samples>0&&FA(T)===!1){j.__webglMultisampledFramebuffer=i.createFramebuffer(),j.__webglColorRenderbuffer=[],e.bindFramebuffer(i.FRAMEBUFFER,j.__webglMultisampledFramebuffer);for(let oA=0;oA<Y.length;oA++){const rA=Y[oA];j.__webglColorRenderbuffer[oA]=i.createRenderbuffer(),i.bindRenderbuffer(i.RENDERBUFFER,j.__webglColorRenderbuffer[oA]);const IA=s.convert(rA.format,rA.colorSpace),nA=s.convert(rA.type),fA=E(rA.internalFormat,IA,nA,rA.colorSpace,T.isXRRenderTarget===!0),HA=CA(T);i.renderbufferStorageMultisample(i.RENDERBUFFER,HA,fA,T.width,T.height),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+oA,i.RENDERBUFFER,j.__webglColorRenderbuffer[oA])}i.bindRenderbuffer(i.RENDERBUFFER,null),T.depthBuffer&&(j.__webglDepthRenderbuffer=i.createRenderbuffer(),eA(j.__webglDepthRenderbuffer,T,!0)),e.bindFramebuffer(i.FRAMEBUFFER,null)}}if(J){e.bindTexture(i.TEXTURE_CUBE_MAP,Z.__webglTexture),$(i.TEXTURE_CUBE_MAP,M);for(let oA=0;oA<6;oA++)if(M.mipmaps&&M.mipmaps.length>0)for(let rA=0;rA<M.mipmaps.length;rA++)k(j.__webglFramebuffer[oA][rA],T,M,i.COLOR_ATTACHMENT0,i.TEXTURE_CUBE_MAP_POSITIVE_X+oA,rA);else k(j.__webglFramebuffer[oA],T,M,i.COLOR_ATTACHMENT0,i.TEXTURE_CUBE_MAP_POSITIVE_X+oA,0);p(M)&&f(i.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(pA){for(let oA=0,rA=Y.length;oA<rA;oA++){const IA=Y[oA],nA=t.get(IA);e.bindTexture(i.TEXTURE_2D,nA.__webglTexture),$(i.TEXTURE_2D,IA),k(j.__webglFramebuffer,T,IA,i.COLOR_ATTACHMENT0+oA,i.TEXTURE_2D,0),p(IA)&&f(i.TEXTURE_2D)}e.unbindTexture()}else{let oA=i.TEXTURE_2D;if((T.isWebGL3DRenderTarget||T.isWebGLArrayRenderTarget)&&(oA=T.isWebGL3DRenderTarget?i.TEXTURE_3D:i.TEXTURE_2D_ARRAY),e.bindTexture(oA,Z.__webglTexture),$(oA,M),M.mipmaps&&M.mipmaps.length>0)for(let rA=0;rA<M.mipmaps.length;rA++)k(j.__webglFramebuffer[rA],T,M,i.COLOR_ATTACHMENT0,oA,rA);else k(j.__webglFramebuffer,T,M,i.COLOR_ATTACHMENT0,oA,0);p(M)&&f(oA),e.unbindTexture()}T.depthBuffer&&iA(T)}function _(T){const M=T.textures;for(let j=0,Z=M.length;j<Z;j++){const Y=M[j];if(p(Y)){const J=T.isWebGLCubeRenderTarget?i.TEXTURE_CUBE_MAP:i.TEXTURE_2D,pA=t.get(Y).__webglTexture;e.bindTexture(J,pA),f(J),e.unbindTexture()}}}const YA=[],gA=[];function JA(T){if(T.samples>0){if(FA(T)===!1){const M=T.textures,j=T.width,Z=T.height;let Y=i.COLOR_BUFFER_BIT;const J=T.stencilBuffer?i.DEPTH_STENCIL_ATTACHMENT:i.DEPTH_ATTACHMENT,pA=t.get(T),oA=M.length>1;if(oA)for(let rA=0;rA<M.length;rA++)e.bindFramebuffer(i.FRAMEBUFFER,pA.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+rA,i.RENDERBUFFER,null),e.bindFramebuffer(i.FRAMEBUFFER,pA.__webglFramebuffer),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0+rA,i.TEXTURE_2D,null,0);e.bindFramebuffer(i.READ_FRAMEBUFFER,pA.__webglMultisampledFramebuffer),e.bindFramebuffer(i.DRAW_FRAMEBUFFER,pA.__webglFramebuffer);for(let rA=0;rA<M.length;rA++){if(T.resolveDepthBuffer&&(T.depthBuffer&&(Y|=i.DEPTH_BUFFER_BIT),T.stencilBuffer&&T.resolveStencilBuffer&&(Y|=i.STENCIL_BUFFER_BIT)),oA){i.framebufferRenderbuffer(i.READ_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.RENDERBUFFER,pA.__webglColorRenderbuffer[rA]);const IA=t.get(M[rA]).__webglTexture;i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,IA,0)}i.blitFramebuffer(0,0,j,Z,0,0,j,Z,Y,i.NEAREST),a===!0&&(YA.length=0,gA.length=0,YA.push(i.COLOR_ATTACHMENT0+rA),T.depthBuffer&&T.resolveDepthBuffer===!1&&(YA.push(J),gA.push(J),i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER,gA)),i.invalidateFramebuffer(i.READ_FRAMEBUFFER,YA))}if(e.bindFramebuffer(i.READ_FRAMEBUFFER,null),e.bindFramebuffer(i.DRAW_FRAMEBUFFER,null),oA)for(let rA=0;rA<M.length;rA++){e.bindFramebuffer(i.FRAMEBUFFER,pA.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+rA,i.RENDERBUFFER,pA.__webglColorRenderbuffer[rA]);const IA=t.get(M[rA]).__webglTexture;e.bindFramebuffer(i.FRAMEBUFFER,pA.__webglFramebuffer),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0+rA,i.TEXTURE_2D,IA,0)}e.bindFramebuffer(i.DRAW_FRAMEBUFFER,pA.__webglMultisampledFramebuffer)}else if(T.depthBuffer&&T.resolveDepthBuffer===!1&&a){const M=T.stencilBuffer?i.DEPTH_STENCIL_ATTACHMENT:i.DEPTH_ATTACHMENT;i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER,[M])}}}function CA(T){return Math.min(n.maxSamples,T.samples)}function FA(T){const M=t.get(T);return T.samples>0&&A.has("WEBGL_multisampled_render_to_texture")===!0&&M.__useRenderToTexture!==!1}function xA(T){const M=r.render.frame;l.get(T)!==M&&(l.set(T,M),T.update())}function jA(T,M){const j=T.colorSpace,Z=T.format,Y=T.type;return T.isCompressedTexture===!0||T.isVideoTexture===!0||j!==fe&&j!==Tt&&(WA.getTransfer(j)===Ae?(Z!==je||Y!==Bt)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",j)),M}function ee(T){return typeof HTMLImageElement<"u"&&T instanceof HTMLImageElement?(c.width=T.naturalWidth||T.width,c.height=T.naturalHeight||T.height):typeof VideoFrame<"u"&&T instanceof VideoFrame?(c.width=T.displayWidth,c.height=T.displayHeight):(c.width=T.width,c.height=T.height),c}this.allocateTextureUnit=N,this.resetTextureUnits=P,this.setTexture2D=b,this.setTexture2DArray=W,this.setTexture3D=G,this.setTextureCube=K,this.rebindTextures=OA,this.setupRenderTarget=zA,this.updateRenderTargetMipmap=_,this.updateMultisampleRenderTarget=JA,this.setupDepthRenderbuffer=iA,this.setupFrameBufferTexture=k,this.useMultisampledRTT=FA}function kp(i,A){function e(t,n=Tt){let s;const r=WA.getTransfer(n);if(t===Bt)return i.UNSIGNED_BYTE;if(t===ba)return i.UNSIGNED_SHORT_4_4_4_4;if(t===Ba)return i.UNSIGNED_SHORT_5_5_5_1;if(t===ol)return i.UNSIGNED_INT_5_9_9_9_REV;if(t===sl)return i.BYTE;if(t===rl)return i.SHORT;if(t===Da)return i.UNSIGNED_SHORT;if(t===Sa)return i.INT;if(t===Sn)return i.UNSIGNED_INT;if(t===Ye)return i.FLOAT;if(t===$i)return i.HALF_FLOAT;if(t===al)return i.ALPHA;if(t===cl)return i.RGB;if(t===je)return i.RGBA;if(t===ll)return i.LUMINANCE;if(t===hl)return i.LUMINANCE_ALPHA;if(t===vn)return i.DEPTH_COMPONENT;if(t===ti)return i.DEPTH_STENCIL;if(t===Ra)return i.RED;if(t===za)return i.RED_INTEGER;if(t===ul)return i.RG;if(t===_a)return i.RG_INTEGER;if(t===Ua)return i.RGBA_INTEGER;if(t===os||t===as||t===cs||t===ls)if(r===Ae)if(s=A.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(t===os)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(t===as)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(t===cs)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(t===ls)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=A.get("WEBGL_compressed_texture_s3tc"),s!==null){if(t===os)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===as)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===cs)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===ls)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(t===Br||t===Rr||t===zr||t===_r)if(s=A.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(t===Br)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===Rr)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===zr)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===_r)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(t===Ur||t===Nr||t===Lr)if(s=A.get("WEBGL_compressed_texture_etc"),s!==null){if(t===Ur||t===Nr)return r===Ae?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(t===Lr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(t===Or||t===Fr||t===Qr||t===jr||t===Hr||t===kr||t===Vr||t===Gr||t===Wr||t===Zr||t===Xr||t===Yr||t===Jr||t===Kr)if(s=A.get("WEBGL_compressed_texture_astc"),s!==null){if(t===Or)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(t===Fr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(t===Qr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(t===jr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(t===Hr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(t===kr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(t===Vr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(t===Gr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(t===Wr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(t===Zr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(t===Xr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(t===Yr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(t===Jr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(t===Kr)return r===Ae?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(t===hs||t===qr||t===$r)if(s=A.get("EXT_texture_compression_bptc"),s!==null){if(t===hs)return r===Ae?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(t===qr)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(t===$r)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(t===dl||t===Ao||t===eo||t===to)if(s=A.get("EXT_texture_compression_rgtc"),s!==null){if(t===hs)return s.COMPRESSED_RED_RGTC1_EXT;if(t===Ao)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(t===eo)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(t===to)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return t===si?i.UNSIGNED_INT_24_8:i[t]!==void 0?i[t]:null}return{convert:e}}class Vp extends Ie{constructor(A=[]){super(),this.isArrayCamera=!0,this.cameras=A}}class Zt extends ie{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Gp={type:"move"};class Ls{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Zt,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Zt,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new S,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new S),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Zt,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new S,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new S),this._grip}dispatchEvent(A){return this._targetRay!==null&&this._targetRay.dispatchEvent(A),this._grip!==null&&this._grip.dispatchEvent(A),this._hand!==null&&this._hand.dispatchEvent(A),this}connect(A){if(A&&A.hand){const e=this._hand;if(e)for(const t of A.hand.values())this._getHandJoint(e,t)}return this.dispatchEvent({type:"connected",data:A}),this}disconnect(A){return this.dispatchEvent({type:"disconnected",data:A}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(A,e,t){let n=null,s=null,r=null;const o=this._targetRay,a=this._grip,c=this._hand;if(A&&e.session.visibilityState!=="visible-blurred"){if(c&&A.hand){r=!0;for(const C of A.hand.values()){const p=e.getJointPose(C,t),f=this._getHandJoint(c,C);p!==null&&(f.matrix.fromArray(p.transform.matrix),f.matrix.decompose(f.position,f.rotation,f.scale),f.matrixWorldNeedsUpdate=!0,f.jointRadius=p.radius),f.visible=p!==null}const l=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],u=l.position.distanceTo(h.position),d=.02,g=.005;c.inputState.pinching&&u>d+g?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:A.handedness,target:this})):!c.inputState.pinching&&u<=d-g&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:A.handedness,target:this}))}else a!==null&&A.gripSpace&&(s=e.getPose(A.gripSpace,t),s!==null&&(a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,s.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(s.linearVelocity)):a.hasLinearVelocity=!1,s.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(s.angularVelocity)):a.hasAngularVelocity=!1));o!==null&&(n=e.getPose(A.targetRaySpace,t),n===null&&s!==null&&(n=s),n!==null&&(o.matrix.fromArray(n.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,n.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(n.linearVelocity)):o.hasLinearVelocity=!1,n.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(n.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(Gp)))}return o!==null&&(o.visible=n!==null),a!==null&&(a.visible=s!==null),c!==null&&(c.visible=r!==null),this}_getHandJoint(A,e){if(A.joints[e.jointName]===void 0){const t=new Zt;t.matrixAutoUpdate=!1,t.visible=!1,A.joints[e.jointName]=t,A.add(t)}return A.joints[e.jointName]}}const Wp=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,Zp=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class Xp{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(A,e,t){if(this.texture===null){const n=new ue,s=A.properties.get(n);s.__webglTexture=e.texture,(e.depthNear!=t.depthNear||e.depthFar!=t.depthFar)&&(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=n}}render(A,e){if(this.texture!==null){if(this.mesh===null){const t=e.cameras[0].viewport,n=new Rt({vertexShader:Wp,fragmentShader:Zp,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new Ee(new ai(20,20),n)}A.render(this.mesh,e)}}reset(){this.texture=null,this.mesh=null}}class Yp extends _t{constructor(A,e){super();const t=this;let n=null,s=1,r=null,o="local-floor",a=1,c=null,l=null,h=null,u=null,d=null,g=null;const C=new Xp,p=e.getContextAttributes();let f=null,E=null;const I=[],x=[],z=new MA;let D=null;const y=new Ie;y.layers.enable(1),y.viewport=new qA;const F=new Ie;F.layers.enable(2),F.viewport=new qA;const v=[y,F],P=new Vp;P.layers.enable(1),P.layers.enable(2);let N=null,V=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(k){let eA=I[k];return eA===void 0&&(eA=new Ls,I[k]=eA),eA.getTargetRaySpace()},this.getControllerGrip=function(k){let eA=I[k];return eA===void 0&&(eA=new Ls,I[k]=eA),eA.getGripSpace()},this.getHand=function(k){let eA=I[k];return eA===void 0&&(eA=new Ls,I[k]=eA),eA.getHandSpace()};function b(k){const eA=x.indexOf(k.inputSource);if(eA===-1)return;const lA=I[eA];lA!==void 0&&(lA.update(k.inputSource,k.frame,c||r),lA.dispatchEvent({type:k.type,data:k.inputSource}))}function W(){n.removeEventListener("select",b),n.removeEventListener("selectstart",b),n.removeEventListener("selectend",b),n.removeEventListener("squeeze",b),n.removeEventListener("squeezestart",b),n.removeEventListener("squeezeend",b),n.removeEventListener("end",W),n.removeEventListener("inputsourceschange",G);for(let k=0;k<I.length;k++){const eA=x[k];eA!==null&&(x[k]=null,I[k].disconnect(eA))}N=null,V=null,C.reset(),A.setRenderTarget(f),d=null,u=null,h=null,n=null,E=null,ZA.stop(),t.isPresenting=!1,A.setPixelRatio(D),A.setSize(z.width,z.height,!1),t.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(k){s=k,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(k){o=k,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||r},this.setReferenceSpace=function(k){c=k},this.getBaseLayer=function(){return u!==null?u:d},this.getBinding=function(){return h},this.getFrame=function(){return g},this.getSession=function(){return n},this.setSession=async function(k){if(n=k,n!==null){if(f=A.getRenderTarget(),n.addEventListener("select",b),n.addEventListener("selectstart",b),n.addEventListener("selectend",b),n.addEventListener("squeeze",b),n.addEventListener("squeezestart",b),n.addEventListener("squeezeend",b),n.addEventListener("end",W),n.addEventListener("inputsourceschange",G),p.xrCompatible!==!0&&await e.makeXRCompatible(),D=A.getPixelRatio(),A.getSize(z),n.renderState.layers===void 0){const eA={antialias:p.antialias,alpha:!0,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(n,e,eA),n.updateRenderState({baseLayer:d}),A.setPixelRatio(1),A.setSize(d.framebufferWidth,d.framebufferHeight,!1),E=new Xt(d.framebufferWidth,d.framebufferHeight,{format:je,type:Bt,colorSpace:A.outputColorSpace,stencilBuffer:p.stencil})}else{let eA=null,lA=null,iA=null;p.depth&&(iA=p.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,eA=p.stencil?ti:vn,lA=p.stencil?si:Sn);const OA={colorFormat:e.RGBA8,depthFormat:iA,scaleFactor:s};h=new XRWebGLBinding(n,e),u=h.createProjectionLayer(OA),n.updateRenderState({layers:[u]}),A.setPixelRatio(1),A.setSize(u.textureWidth,u.textureHeight,!1),E=new Xt(u.textureWidth,u.textureHeight,{format:je,type:Bt,depthTexture:new Ka(u.textureWidth,u.textureHeight,lA,void 0,void 0,void 0,void 0,void 0,void 0,eA),stencilBuffer:p.stencil,colorSpace:A.outputColorSpace,samples:p.antialias?4:0,resolveDepthBuffer:u.ignoreDepthValues===!1})}E.isXRRenderTarget=!0,this.setFoveation(a),c=null,r=await n.requestReferenceSpace(o),ZA.setContext(n),ZA.start(),t.isPresenting=!0,t.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(n!==null)return n.environmentBlendMode};function G(k){for(let eA=0;eA<k.removed.length;eA++){const lA=k.removed[eA],iA=x.indexOf(lA);iA>=0&&(x[iA]=null,I[iA].disconnect(lA))}for(let eA=0;eA<k.added.length;eA++){const lA=k.added[eA];let iA=x.indexOf(lA);if(iA===-1){for(let zA=0;zA<I.length;zA++)if(zA>=x.length){x.push(lA),iA=zA;break}else if(x[zA]===null){x[zA]=lA,iA=zA;break}if(iA===-1)break}const OA=I[iA];OA&&OA.connect(lA)}}const K=new S,q=new S;function H(k,eA,lA){K.setFromMatrixPosition(eA.matrixWorld),q.setFromMatrixPosition(lA.matrixWorld);const iA=K.distanceTo(q),OA=eA.projectionMatrix.elements,zA=lA.projectionMatrix.elements,_=OA[14]/(OA[10]-1),YA=OA[14]/(OA[10]+1),gA=(OA[9]+1)/OA[5],JA=(OA[9]-1)/OA[5],CA=(OA[8]-1)/OA[0],FA=(zA[8]+1)/zA[0],xA=_*CA,jA=_*FA,ee=iA/(-CA+FA),T=ee*-CA;eA.matrixWorld.decompose(k.position,k.quaternion,k.scale),k.translateX(T),k.translateZ(ee),k.matrixWorld.compose(k.position,k.quaternion,k.scale),k.matrixWorldInverse.copy(k.matrixWorld).invert();const M=_+ee,j=YA+ee,Z=xA-T,Y=jA+(iA-T),J=gA*YA/j*M,pA=JA*YA/j*M;k.projectionMatrix.makePerspective(Z,Y,J,pA,M,j),k.projectionMatrixInverse.copy(k.projectionMatrix).invert()}function AA(k,eA){eA===null?k.matrixWorld.copy(k.matrix):k.matrixWorld.multiplyMatrices(eA.matrixWorld,k.matrix),k.matrixWorldInverse.copy(k.matrixWorld).invert()}this.updateCamera=function(k){if(n===null)return;C.texture!==null&&(k.near=C.depthNear,k.far=C.depthFar),P.near=F.near=y.near=k.near,P.far=F.far=y.far=k.far,(N!==P.near||V!==P.far)&&(n.updateRenderState({depthNear:P.near,depthFar:P.far}),N=P.near,V=P.far,y.near=N,y.far=V,F.near=N,F.far=V,y.updateProjectionMatrix(),F.updateProjectionMatrix(),k.updateProjectionMatrix());const eA=k.parent,lA=P.cameras;AA(P,eA);for(let iA=0;iA<lA.length;iA++)AA(lA[iA],eA);lA.length===2?H(P,y,F):P.projectionMatrix.copy(y.projectionMatrix),$(k,P,eA)};function $(k,eA,lA){lA===null?k.matrix.copy(eA.matrixWorld):(k.matrix.copy(lA.matrixWorld),k.matrix.invert(),k.matrix.multiply(eA.matrixWorld)),k.matrix.decompose(k.position,k.quaternion,k.scale),k.updateMatrixWorld(!0),k.projectionMatrix.copy(eA.projectionMatrix),k.projectionMatrixInverse.copy(eA.projectionMatrixInverse),k.isPerspectiveCamera&&(k.fov=Bn*2*Math.atan(1/k.projectionMatrix.elements[5]),k.zoom=1)}this.getCamera=function(){return P},this.getFoveation=function(){if(!(u===null&&d===null))return a},this.setFoveation=function(k){a=k,u!==null&&(u.fixedFoveation=k),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=k)},this.hasDepthSensing=function(){return C.texture!==null};let uA=null;function LA(k,eA){if(l=eA.getViewerPose(c||r),g=eA,l!==null){const lA=l.views;d!==null&&(A.setRenderTargetFramebuffer(E,d.framebuffer),A.setRenderTarget(E));let iA=!1;lA.length!==P.cameras.length&&(P.cameras.length=0,iA=!0);for(let zA=0;zA<lA.length;zA++){const _=lA[zA];let YA=null;if(d!==null)YA=d.getViewport(_);else{const JA=h.getViewSubImage(u,_);YA=JA.viewport,zA===0&&(A.setRenderTargetTextures(E,JA.colorTexture,u.ignoreDepthValues?void 0:JA.depthStencilTexture),A.setRenderTarget(E))}let gA=v[zA];gA===void 0&&(gA=new Ie,gA.layers.enable(zA),gA.viewport=new qA,v[zA]=gA),gA.matrix.fromArray(_.transform.matrix),gA.matrix.decompose(gA.position,gA.quaternion,gA.scale),gA.projectionMatrix.fromArray(_.projectionMatrix),gA.projectionMatrixInverse.copy(gA.projectionMatrix).invert(),gA.viewport.set(YA.x,YA.y,YA.width,YA.height),zA===0&&(P.matrix.copy(gA.matrix),P.matrix.decompose(P.position,P.quaternion,P.scale)),iA===!0&&P.cameras.push(gA)}const OA=n.enabledFeatures;if(OA&&OA.includes("depth-sensing")){const zA=h.getDepthInformation(lA[0]);zA&&zA.isValid&&zA.texture&&C.init(A,zA,n.renderState)}}for(let lA=0;lA<I.length;lA++){const iA=x[lA],OA=I[lA];iA!==null&&OA!==void 0&&OA.update(iA,eA,c||r)}C.render(A,P),uA&&uA(k,eA),eA.detectedPlanes&&t.dispatchEvent({type:"planesdetected",data:eA}),g=null}const ZA=new Ja;ZA.setAnimationLoop(LA),this.setAnimationLoop=function(k){uA=k},this.dispose=function(){}}}const jt=new Je,Jp=new RA;function Kp(i,A){function e(p,f){p.matrixAutoUpdate===!0&&p.updateMatrix(),f.value.copy(p.matrix)}function t(p,f){f.color.getRGB(p.fogColor.value,Za(i)),f.isFog?(p.fogNear.value=f.near,p.fogFar.value=f.far):f.isFogExp2&&(p.fogDensity.value=f.density)}function n(p,f,E,I,x){f.isMeshBasicMaterial||f.isMeshLambertMaterial?s(p,f):f.isMeshToonMaterial?(s(p,f),h(p,f)):f.isMeshPhongMaterial?(s(p,f),l(p,f)):f.isMeshStandardMaterial?(s(p,f),u(p,f),f.isMeshPhysicalMaterial&&d(p,f,x)):f.isMeshMatcapMaterial?(s(p,f),g(p,f)):f.isMeshDepthMaterial?s(p,f):f.isMeshDistanceMaterial?(s(p,f),C(p,f)):f.isMeshNormalMaterial?s(p,f):f.isLineBasicMaterial?(r(p,f),f.isLineDashedMaterial&&o(p,f)):f.isPointsMaterial?a(p,f,E,I):f.isSpriteMaterial?c(p,f):f.isShadowMaterial?(p.color.value.copy(f.color),p.opacity.value=f.opacity):f.isShaderMaterial&&(f.uniformsNeedUpdate=!1)}function s(p,f){p.opacity.value=f.opacity,f.color&&p.diffuse.value.copy(f.color),f.emissive&&p.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),f.map&&(p.map.value=f.map,e(f.map,p.mapTransform)),f.alphaMap&&(p.alphaMap.value=f.alphaMap,e(f.alphaMap,p.alphaMapTransform)),f.bumpMap&&(p.bumpMap.value=f.bumpMap,e(f.bumpMap,p.bumpMapTransform),p.bumpScale.value=f.bumpScale,f.side===Te&&(p.bumpScale.value*=-1)),f.normalMap&&(p.normalMap.value=f.normalMap,e(f.normalMap,p.normalMapTransform),p.normalScale.value.copy(f.normalScale),f.side===Te&&p.normalScale.value.negate()),f.displacementMap&&(p.displacementMap.value=f.displacementMap,e(f.displacementMap,p.displacementMapTransform),p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias),f.emissiveMap&&(p.emissiveMap.value=f.emissiveMap,e(f.emissiveMap,p.emissiveMapTransform)),f.specularMap&&(p.specularMap.value=f.specularMap,e(f.specularMap,p.specularMapTransform)),f.alphaTest>0&&(p.alphaTest.value=f.alphaTest);const E=A.get(f),I=E.envMap,x=E.envMapRotation;if(I&&(p.envMap.value=I,jt.copy(x),jt.x*=-1,jt.y*=-1,jt.z*=-1,I.isCubeTexture&&I.isRenderTargetTexture===!1&&(jt.y*=-1,jt.z*=-1),p.envMapRotation.value.setFromMatrix4(Jp.makeRotationFromEuler(jt)),p.flipEnvMap.value=I.isCubeTexture&&I.isRenderTargetTexture===!1?-1:1,p.reflectivity.value=f.reflectivity,p.ior.value=f.ior,p.refractionRatio.value=f.refractionRatio),f.lightMap){p.lightMap.value=f.lightMap;const z=i._useLegacyLights===!0?Math.PI:1;p.lightMapIntensity.value=f.lightMapIntensity*z,e(f.lightMap,p.lightMapTransform)}f.aoMap&&(p.aoMap.value=f.aoMap,p.aoMapIntensity.value=f.aoMapIntensity,e(f.aoMap,p.aoMapTransform))}function r(p,f){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity,f.map&&(p.map.value=f.map,e(f.map,p.mapTransform))}function o(p,f){p.dashSize.value=f.dashSize,p.totalSize.value=f.dashSize+f.gapSize,p.scale.value=f.scale}function a(p,f,E,I){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity,p.size.value=f.size*E,p.scale.value=I*.5,f.map&&(p.map.value=f.map,e(f.map,p.uvTransform)),f.alphaMap&&(p.alphaMap.value=f.alphaMap,e(f.alphaMap,p.alphaMapTransform)),f.alphaTest>0&&(p.alphaTest.value=f.alphaTest)}function c(p,f){p.diffuse.value.copy(f.color),p.opacity.value=f.opacity,p.rotation.value=f.rotation,f.map&&(p.map.value=f.map,e(f.map,p.mapTransform)),f.alphaMap&&(p.alphaMap.value=f.alphaMap,e(f.alphaMap,p.alphaMapTransform)),f.alphaTest>0&&(p.alphaTest.value=f.alphaTest)}function l(p,f){p.specular.value.copy(f.specular),p.shininess.value=Math.max(f.shininess,1e-4)}function h(p,f){f.gradientMap&&(p.gradientMap.value=f.gradientMap)}function u(p,f){p.metalness.value=f.metalness,f.metalnessMap&&(p.metalnessMap.value=f.metalnessMap,e(f.metalnessMap,p.metalnessMapTransform)),p.roughness.value=f.roughness,f.roughnessMap&&(p.roughnessMap.value=f.roughnessMap,e(f.roughnessMap,p.roughnessMapTransform)),f.envMap&&(p.envMapIntensity.value=f.envMapIntensity)}function d(p,f,E){p.ior.value=f.ior,f.sheen>0&&(p.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),p.sheenRoughness.value=f.sheenRoughness,f.sheenColorMap&&(p.sheenColorMap.value=f.sheenColorMap,e(f.sheenColorMap,p.sheenColorMapTransform)),f.sheenRoughnessMap&&(p.sheenRoughnessMap.value=f.sheenRoughnessMap,e(f.sheenRoughnessMap,p.sheenRoughnessMapTransform))),f.clearcoat>0&&(p.clearcoat.value=f.clearcoat,p.clearcoatRoughness.value=f.clearcoatRoughness,f.clearcoatMap&&(p.clearcoatMap.value=f.clearcoatMap,e(f.clearcoatMap,p.clearcoatMapTransform)),f.clearcoatRoughnessMap&&(p.clearcoatRoughnessMap.value=f.clearcoatRoughnessMap,e(f.clearcoatRoughnessMap,p.clearcoatRoughnessMapTransform)),f.clearcoatNormalMap&&(p.clearcoatNormalMap.value=f.clearcoatNormalMap,e(f.clearcoatNormalMap,p.clearcoatNormalMapTransform),p.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),f.side===Te&&p.clearcoatNormalScale.value.negate())),f.dispersion>0&&(p.dispersion.value=f.dispersion),f.iridescence>0&&(p.iridescence.value=f.iridescence,p.iridescenceIOR.value=f.iridescenceIOR,p.iridescenceThicknessMinimum.value=f.iridescenceThicknessRange[0],p.iridescenceThicknessMaximum.value=f.iridescenceThicknessRange[1],f.iridescenceMap&&(p.iridescenceMap.value=f.iridescenceMap,e(f.iridescenceMap,p.iridescenceMapTransform)),f.iridescenceThicknessMap&&(p.iridescenceThicknessMap.value=f.iridescenceThicknessMap,e(f.iridescenceThicknessMap,p.iridescenceThicknessMapTransform))),f.transmission>0&&(p.transmission.value=f.transmission,p.transmissionSamplerMap.value=E.texture,p.transmissionSamplerSize.value.set(E.width,E.height),f.transmissionMap&&(p.transmissionMap.value=f.transmissionMap,e(f.transmissionMap,p.transmissionMapTransform)),p.thickness.value=f.thickness,f.thicknessMap&&(p.thicknessMap.value=f.thicknessMap,e(f.thicknessMap,p.thicknessMapTransform)),p.attenuationDistance.value=f.attenuationDistance,p.attenuationColor.value.copy(f.attenuationColor)),f.anisotropy>0&&(p.anisotropyVector.value.set(f.anisotropy*Math.cos(f.anisotropyRotation),f.anisotropy*Math.sin(f.anisotropyRotation)),f.anisotropyMap&&(p.anisotropyMap.value=f.anisotropyMap,e(f.anisotropyMap,p.anisotropyMapTransform))),p.specularIntensity.value=f.specularIntensity,p.specularColor.value.copy(f.specularColor),f.specularColorMap&&(p.specularColorMap.value=f.specularColorMap,e(f.specularColorMap,p.specularColorMapTransform)),f.specularIntensityMap&&(p.specularIntensityMap.value=f.specularIntensityMap,e(f.specularIntensityMap,p.specularIntensityMapTransform))}function g(p,f){f.matcap&&(p.matcap.value=f.matcap)}function C(p,f){const E=A.get(f).light;p.referencePosition.value.setFromMatrixPosition(E.matrixWorld),p.nearDistance.value=E.shadow.camera.near,p.farDistance.value=E.shadow.camera.far}return{refreshFogUniforms:t,refreshMaterialUniforms:n}}function qp(i,A,e,t){let n={},s={},r=[];const o=i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);function a(E,I){const x=I.program;t.uniformBlockBinding(E,x)}function c(E,I){let x=n[E.id];x===void 0&&(g(E),x=l(E),n[E.id]=x,E.addEventListener("dispose",p));const z=I.program;t.updateUBOMapping(E,z);const D=A.render.frame;s[E.id]!==D&&(u(E),s[E.id]=D)}function l(E){const I=h();E.__bindingPointIndex=I;const x=i.createBuffer(),z=E.__size,D=E.usage;return i.bindBuffer(i.UNIFORM_BUFFER,x),i.bufferData(i.UNIFORM_BUFFER,z,D),i.bindBuffer(i.UNIFORM_BUFFER,null),i.bindBufferBase(i.UNIFORM_BUFFER,I,x),x}function h(){for(let E=0;E<o;E++)if(r.indexOf(E)===-1)return r.push(E),E;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function u(E){const I=n[E.id],x=E.uniforms,z=E.__cache;i.bindBuffer(i.UNIFORM_BUFFER,I);for(let D=0,y=x.length;D<y;D++){const F=Array.isArray(x[D])?x[D]:[x[D]];for(let v=0,P=F.length;v<P;v++){const N=F[v];if(d(N,D,v,z)===!0){const V=N.__offset,b=Array.isArray(N.value)?N.value:[N.value];let W=0;for(let G=0;G<b.length;G++){const K=b[G],q=C(K);typeof K=="number"||typeof K=="boolean"?(N.__data[0]=K,i.bufferSubData(i.UNIFORM_BUFFER,V+W,N.__data)):K.isMatrix3?(N.__data[0]=K.elements[0],N.__data[1]=K.elements[1],N.__data[2]=K.elements[2],N.__data[3]=0,N.__data[4]=K.elements[3],N.__data[5]=K.elements[4],N.__data[6]=K.elements[5],N.__data[7]=0,N.__data[8]=K.elements[6],N.__data[9]=K.elements[7],N.__data[10]=K.elements[8],N.__data[11]=0):(K.toArray(N.__data,W),W+=q.storage/Float32Array.BYTES_PER_ELEMENT)}i.bufferSubData(i.UNIFORM_BUFFER,V,N.__data)}}}i.bindBuffer(i.UNIFORM_BUFFER,null)}function d(E,I,x,z){const D=E.value,y=I+"_"+x;if(z[y]===void 0)return typeof D=="number"||typeof D=="boolean"?z[y]=D:z[y]=D.clone(),!0;{const F=z[y];if(typeof D=="number"||typeof D=="boolean"){if(F!==D)return z[y]=D,!0}else if(F.equals(D)===!1)return F.copy(D),!0}return!1}function g(E){const I=E.uniforms;let x=0;const z=16;for(let y=0,F=I.length;y<F;y++){const v=Array.isArray(I[y])?I[y]:[I[y]];for(let P=0,N=v.length;P<N;P++){const V=v[P],b=Array.isArray(V.value)?V.value:[V.value];for(let W=0,G=b.length;W<G;W++){const K=b[W],q=C(K),H=x%z;H!==0&&z-H<q.boundary&&(x+=z-H),V.__data=new Float32Array(q.storage/Float32Array.BYTES_PER_ELEMENT),V.__offset=x,x+=q.storage}}}const D=x%z;return D>0&&(x+=z-D),E.__size=x,E.__cache={},this}function C(E){const I={boundary:0,storage:0};return typeof E=="number"||typeof E=="boolean"?(I.boundary=4,I.storage=4):E.isVector2?(I.boundary=8,I.storage=8):E.isVector3||E.isColor?(I.boundary=16,I.storage=12):E.isVector4?(I.boundary=16,I.storage=16):E.isMatrix3?(I.boundary=48,I.storage=48):E.isMatrix4?(I.boundary=64,I.storage=64):E.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",E),I}function p(E){const I=E.target;I.removeEventListener("dispose",p);const x=r.indexOf(I.__bindingPointIndex);r.splice(x,1),i.deleteBuffer(n[I.id]),delete n[I.id],delete s[I.id]}function f(){for(const E in n)i.deleteBuffer(n[E]);r=[],n={},s={}}return{bind:a,update:c,dispose:f}}class $p{constructor(A={}){const{canvas:e=Gl(),context:t=null,depth:n=!0,stencil:s=!1,alpha:r=!1,antialias:o=!1,premultipliedAlpha:a=!0,preserveDrawingBuffer:c=!1,powerPreference:l="default",failIfMajorPerformanceCaveat:h=!1}=A;this.isWebGLRenderer=!0;let u;if(t!==null){if(typeof WebGLRenderingContext<"u"&&t instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");u=t.getContextAttributes().alpha}else u=r;const d=new Uint32Array(4),g=new Int32Array(4);let C=null,p=null;const f=[],E=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=Me,this._useLegacyLights=!1,this.toneMapping=bt,this.toneMappingExposure=1;const I=this;let x=!1,z=0,D=0,y=null,F=-1,v=null;const P=new qA,N=new qA;let V=null;const b=new wA(0);let W=0,G=e.width,K=e.height,q=1,H=null,AA=null;const $=new qA(0,0,G,K),uA=new qA(0,0,G,K);let LA=!1;const ZA=new lr;let k=!1,eA=!1;const lA=new RA,iA=new S,OA={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function zA(){return y===null?q:1}let _=t;function YA(w,R){return e.getContext(w,R)}try{const w={alpha:!0,depth:n,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:c,powerPreference:l,failIfMajorPerformanceCaveat:h};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${sr}`),e.addEventListener("webglcontextlost",m,!1),e.addEventListener("webglcontextrestored",B,!1),e.addEventListener("webglcontextcreationerror",U,!1),_===null){const R="webgl2";if(_=YA(R,w),_===null)throw YA(R)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(w){throw console.error("THREE.WebGLRenderer: "+w.message),w}let gA,JA,CA,FA,xA,jA,ee,T,M,j,Z,Y,J,pA,oA,rA,IA,nA,fA,HA,mA,cA,TA,_A;function KA(){gA=new of(_),gA.init(),cA=new kp(_,gA),JA=new Af(_,gA,A,cA),CA=new jp(_),FA=new lf(_),xA=new yp,jA=new Hp(_,gA,CA,xA,JA,cA,FA),ee=new tf(I),T=new rf(I),M=new gh(_),TA=new qd(_,M),j=new af(_,M,FA,TA),Z=new uf(_,j,M,FA),fA=new hf(_,JA,jA),rA=new ef(xA),Y=new Tp(I,ee,T,gA,JA,TA,rA),J=new Kp(I,xA),pA=new Sp,oA=new Up(gA),nA=new Kd(I,ee,T,CA,Z,u,a),IA=new Qp(I,Z,JA),_A=new qp(_,FA,JA,CA),HA=new $d(_,gA,FA),mA=new cf(_,gA,FA),FA.programs=Y.programs,I.capabilities=JA,I.extensions=gA,I.properties=xA,I.renderLists=pA,I.shadowMap=IA,I.state=CA,I.info=FA}KA();const DA=new Yp(I,_);this.xr=DA,this.getContext=function(){return _},this.getContextAttributes=function(){return _.getContextAttributes()},this.forceContextLoss=function(){const w=gA.get("WEBGL_lose_context");w&&w.loseContext()},this.forceContextRestore=function(){const w=gA.get("WEBGL_lose_context");w&&w.restoreContext()},this.getPixelRatio=function(){return q},this.setPixelRatio=function(w){w!==void 0&&(q=w,this.setSize(G,K,!1))},this.getSize=function(w){return w.set(G,K)},this.setSize=function(w,R,Q=!0){if(DA.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}G=w,K=R,e.width=Math.floor(w*q),e.height=Math.floor(R*q),Q===!0&&(e.style.width=w+"px",e.style.height=R+"px"),this.setViewport(0,0,w,R)},this.getDrawingBufferSize=function(w){return w.set(G*q,K*q).floor()},this.setDrawingBufferSize=function(w,R,Q){G=w,K=R,q=Q,e.width=Math.floor(w*Q),e.height=Math.floor(R*Q),this.setViewport(0,0,w,R)},this.getCurrentViewport=function(w){return w.copy(P)},this.getViewport=function(w){return w.copy($)},this.setViewport=function(w,R,Q,L){w.isVector4?$.set(w.x,w.y,w.z,w.w):$.set(w,R,Q,L),CA.viewport(P.copy($).multiplyScalar(q).round())},this.getScissor=function(w){return w.copy(uA)},this.setScissor=function(w,R,Q,L){w.isVector4?uA.set(w.x,w.y,w.z,w.w):uA.set(w,R,Q,L),CA.scissor(N.copy(uA).multiplyScalar(q).round())},this.getScissorTest=function(){return LA},this.setScissorTest=function(w){CA.setScissorTest(LA=w)},this.setOpaqueSort=function(w){H=w},this.setTransparentSort=function(w){AA=w},this.getClearColor=function(w){return w.copy(nA.getClearColor())},this.setClearColor=function(){nA.setClearColor.apply(nA,arguments)},this.getClearAlpha=function(){return nA.getClearAlpha()},this.setClearAlpha=function(){nA.setClearAlpha.apply(nA,arguments)},this.clear=function(w=!0,R=!0,Q=!0){let L=0;if(w){let O=!1;if(y!==null){const aA=y.texture.format;O=aA===Ua||aA===_a||aA===za}if(O){const aA=y.texture.type,hA=aA===Bt||aA===Sn||aA===Da||aA===si||aA===ba||aA===Ba,dA=nA.getClearColor(),PA=nA.getClearAlpha(),vA=dA.r,SA=dA.g,NA=dA.b;hA?(d[0]=vA,d[1]=SA,d[2]=NA,d[3]=PA,_.clearBufferuiv(_.COLOR,0,d)):(g[0]=vA,g[1]=SA,g[2]=NA,g[3]=PA,_.clearBufferiv(_.COLOR,0,g))}else L|=_.COLOR_BUFFER_BIT}R&&(L|=_.DEPTH_BUFFER_BIT),Q&&(L|=_.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),_.clear(L)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",m,!1),e.removeEventListener("webglcontextrestored",B,!1),e.removeEventListener("webglcontextcreationerror",U,!1),pA.dispose(),oA.dispose(),xA.dispose(),ee.dispose(),T.dispose(),Z.dispose(),TA.dispose(),_A.dispose(),Y.dispose(),DA.dispose(),DA.removeEventListener("sessionstart",kA),DA.removeEventListener("sessionend",se),$A.stop()};function m(w){w.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),x=!0}function B(){console.log("THREE.WebGLRenderer: Context Restored."),x=!1;const w=FA.autoReset,R=IA.enabled,Q=IA.autoUpdate,L=IA.needsUpdate,O=IA.type;KA(),FA.autoReset=w,IA.enabled=R,IA.autoUpdate=Q,IA.needsUpdate=L,IA.type=O}function U(w){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",w.statusMessage)}function X(w){const R=w.target;R.removeEventListener("dispose",X),tA(R)}function tA(w){yA(w),xA.remove(w)}function yA(w){const R=xA.get(w).programs;R!==void 0&&(R.forEach(function(Q){Y.releaseProgram(Q)}),w.isShaderMaterial&&Y.releaseShaderCache(w))}this.renderBufferDirect=function(w,R,Q,L,O,aA){R===null&&(R=OA);const hA=O.isMesh&&O.matrixWorld.determinant()<0,dA=Cc(w,R,Q,L,O);CA.setMaterial(L,hA);let PA=Q.index,vA=1;if(L.wireframe===!0){if(PA=j.getWireframeAttribute(Q),PA===void 0)return;vA=2}const SA=Q.drawRange,NA=Q.attributes.position;let re=SA.start*vA,pe=(SA.start+SA.count)*vA;aA!==null&&(re=Math.max(re,aA.start*vA),pe=Math.min(pe,(aA.start+aA.count)*vA)),PA!==null?(re=Math.max(re,0),pe=Math.min(pe,PA.count)):NA!=null&&(re=Math.max(re,0),pe=Math.min(pe,NA.count));const ye=pe-re;if(ye<0||ye===1/0)return;TA.setup(O,L,dA,Q,PA);let et,VA=HA;if(PA!==null&&(et=M.get(PA),VA=mA,VA.setIndex(et)),O.isMesh)L.wireframe===!0?(CA.setLineWidth(L.wireframeLinewidth*zA()),VA.setMode(_.LINES)):VA.setMode(_.TRIANGLES);else if(O.isLine){let EA=L.linewidth;EA===void 0&&(EA=1),CA.setLineWidth(EA*zA()),O.isLineSegments?VA.setMode(_.LINES):O.isLineLoop?VA.setMode(_.LINE_LOOP):VA.setMode(_.LINE_STRIP)}else O.isPoints?VA.setMode(_.POINTS):O.isSprite&&VA.setMode(_.TRIANGLES);if(O.isBatchedMesh)O._multiDrawInstances!==null?VA.renderMultiDrawInstances(O._multiDrawStarts,O._multiDrawCounts,O._multiDrawCount,O._multiDrawInstances):VA.renderMultiDraw(O._multiDrawStarts,O._multiDrawCounts,O._multiDrawCount);else if(O.isInstancedMesh)VA.renderInstances(re,ye,O.count);else if(Q.isInstancedBufferGeometry){const EA=Q._maxInstanceCount!==void 0?Q._maxInstanceCount:1/0,Qn=Math.min(Q.instanceCount,EA);VA.renderInstances(re,ye,Qn)}else VA.render(re,ye)};function UA(w,R,Q){w.transparent===!0&&w.side===Ze&&w.forceSinglePass===!1?(w.side=Te,w.needsUpdate=!0,li(w,R,Q),w.side=ht,w.needsUpdate=!0,li(w,R,Q),w.side=Ze):li(w,R,Q)}this.compile=function(w,R,Q=null){Q===null&&(Q=w),p=oA.get(Q),p.init(R),E.push(p),Q.traverseVisible(function(O){O.isLight&&O.layers.test(R.layers)&&(p.pushLight(O),O.castShadow&&p.pushShadow(O))}),w!==Q&&w.traverseVisible(function(O){O.isLight&&O.layers.test(R.layers)&&(p.pushLight(O),O.castShadow&&p.pushShadow(O))}),p.setupLights(I._useLegacyLights);const L=new Set;return w.traverse(function(O){const aA=O.material;if(aA)if(Array.isArray(aA))for(let hA=0;hA<aA.length;hA++){const dA=aA[hA];UA(dA,Q,O),L.add(dA)}else UA(aA,Q,O),L.add(aA)}),E.pop(),p=null,L},this.compileAsync=function(w,R,Q=null){const L=this.compile(w,R,Q);return new Promise(O=>{function aA(){if(L.forEach(function(hA){xA.get(hA).currentProgram.isReady()&&L.delete(hA)}),L.size===0){O(w);return}setTimeout(aA,10)}gA.get("KHR_parallel_shader_compile")!==null?aA():setTimeout(aA,10)})};let ne=null;function le(w){ne&&ne(w)}function kA(){$A.stop()}function se(){$A.start()}const $A=new Ja;$A.setAnimationLoop(le),typeof self<"u"&&$A.setContext(self),this.setAnimationLoop=function(w){ne=w,DA.setAnimationLoop(w),w===null?$A.stop():$A.start()},DA.addEventListener("sessionstart",kA),DA.addEventListener("sessionend",se),this.render=function(w,R){if(R!==void 0&&R.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(x===!0)return;w.matrixWorldAutoUpdate===!0&&w.updateMatrixWorld(),R.parent===null&&R.matrixWorldAutoUpdate===!0&&R.updateMatrixWorld(),DA.enabled===!0&&DA.isPresenting===!0&&(DA.cameraAutoUpdate===!0&&DA.updateCamera(R),R=DA.getCamera()),w.isScene===!0&&w.onBeforeRender(I,w,R,y),p=oA.get(w,E.length),p.init(R),E.push(p),lA.multiplyMatrices(R.projectionMatrix,R.matrixWorldInverse),ZA.setFromProjectionMatrix(lA),eA=this.localClippingEnabled,k=rA.init(this.clippingPlanes,eA),C=pA.get(w,f.length),C.init(),f.push(C),ft(w,R,0,I.sortObjects),C.finish(),I.sortObjects===!0&&C.sort(H,AA);const Q=DA.enabled===!1||DA.isPresenting===!1||DA.hasDepthSensing()===!1;Q&&nA.addToRenderList(C,w),this.info.render.frame++,k===!0&&rA.beginShadows();const L=p.state.shadowsArray;IA.render(L,w,R),k===!0&&rA.endShadows(),this.info.autoReset===!0&&this.info.reset();const O=C.opaque,aA=C.transmissive;if(p.setupLights(I._useLegacyLights),R.isArrayCamera){const hA=R.cameras;if(aA.length>0)for(let dA=0,PA=hA.length;dA<PA;dA++){const vA=hA[dA];pt(O,aA,w,vA)}Q&&nA.render(w);for(let dA=0,PA=hA.length;dA<PA;dA++){const vA=hA[dA];Re(C,w,vA,vA.viewport)}}else aA.length>0&&pt(O,aA,w,R),Q&&nA.render(w),Re(C,w,R);y!==null&&(jA.updateMultisampleRenderTarget(y),jA.updateRenderTargetMipmap(y)),w.isScene===!0&&w.onAfterRender(I,w,R),TA.resetDefaultState(),F=-1,v=null,E.pop(),E.length>0?(p=E[E.length-1],k===!0&&rA.setGlobalState(I.clippingPlanes,p.state.camera)):p=null,f.pop(),f.length>0?C=f[f.length-1]:C=null};function ft(w,R,Q,L){if(w.visible===!1)return;if(w.layers.test(R.layers)){if(w.isGroup)Q=w.renderOrder;else if(w.isLOD)w.autoUpdate===!0&&w.update(R);else if(w.isLight)p.pushLight(w),w.castShadow&&p.pushShadow(w);else if(w.isSprite){if(!w.frustumCulled||ZA.intersectsSprite(w)){L&&iA.setFromMatrixPosition(w.matrixWorld).applyMatrix4(lA);const hA=Z.update(w),dA=w.material;dA.visible&&C.push(w,hA,dA,Q,iA.z,null)}}else if((w.isMesh||w.isLine||w.isPoints)&&(!w.frustumCulled||ZA.intersectsObject(w))){const hA=Z.update(w),dA=w.material;if(L&&(w.boundingSphere!==void 0?(w.boundingSphere===null&&w.computeBoundingSphere(),iA.copy(w.boundingSphere.center)):(hA.boundingSphere===null&&hA.computeBoundingSphere(),iA.copy(hA.boundingSphere.center)),iA.applyMatrix4(w.matrixWorld).applyMatrix4(lA)),Array.isArray(dA)){const PA=hA.groups;for(let vA=0,SA=PA.length;vA<SA;vA++){const NA=PA[vA],re=dA[NA.materialIndex];re&&re.visible&&C.push(w,hA,re,Q,iA.z,NA)}}else dA.visible&&C.push(w,hA,dA,Q,iA.z,null)}}const aA=w.children;for(let hA=0,dA=aA.length;hA<dA;hA++)ft(aA[hA],R,Q,L)}function Re(w,R,Q,L){const O=w.opaque,aA=w.transmissive,hA=w.transparent;p.setupLightsView(Q),k===!0&&rA.setGlobalState(I.clippingPlanes,Q),L&&CA.viewport(P.copy(L)),O.length>0&&At(O,R,Q),aA.length>0&&At(aA,R,Q),hA.length>0&&At(hA,R,Q),CA.buffers.depth.setTest(!0),CA.buffers.depth.setMask(!0),CA.buffers.color.setMask(!0),CA.setPolygonOffset(!1)}function pt(w,R,Q,L){if((Q.isScene===!0?Q.overrideMaterial:null)!==null)return;p.state.transmissionRenderTarget[L.id]===void 0&&(p.state.transmissionRenderTarget[L.id]=new Xt(1,1,{generateMipmaps:!0,type:gA.has("EXT_color_buffer_half_float")||gA.has("EXT_color_buffer_float")?$i:Bt,minFilter:ct,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1}));const aA=p.state.transmissionRenderTarget[L.id],hA=L.viewport||P;aA.setSize(hA.z,hA.w);const dA=I.getRenderTarget();I.setRenderTarget(aA),I.getClearColor(b),W=I.getClearAlpha(),W<1&&I.setClearColor(16777215,.5),I.clear();const PA=I.toneMapping;I.toneMapping=bt;const vA=L.viewport;if(L.viewport!==void 0&&(L.viewport=void 0),p.setupLightsView(L),k===!0&&rA.setGlobalState(I.clippingPlanes,L),At(w,Q,L),jA.updateMultisampleRenderTarget(aA),jA.updateRenderTargetMipmap(aA),gA.has("WEBGL_multisampled_render_to_texture")===!1){let SA=!1;for(let NA=0,re=R.length;NA<re;NA++){const pe=R[NA],ye=pe.object,et=pe.geometry,VA=pe.material,EA=pe.group;if(VA.side===Ze&&ye.layers.test(L.layers)){const Qn=VA.side;VA.side=Te,VA.needsUpdate=!0,Fn(ye,Q,L,et,VA,EA),VA.side=Qn,VA.needsUpdate=!0,SA=!0}}SA===!0&&(jA.updateMultisampleRenderTarget(aA),jA.updateRenderTargetMipmap(aA))}I.setRenderTarget(dA),I.setClearColor(b,W),vA!==void 0&&(L.viewport=vA),I.toneMapping=PA}function At(w,R,Q){const L=R.isScene===!0?R.overrideMaterial:null;for(let O=0,aA=w.length;O<aA;O++){const hA=w[O],dA=hA.object,PA=hA.geometry,vA=L===null?hA.material:L,SA=hA.group;dA.layers.test(Q.layers)&&Fn(dA,R,Q,PA,vA,SA)}}function Fn(w,R,Q,L,O,aA){w.onBeforeRender(I,R,Q,L,O,aA),w.modelViewMatrix.multiplyMatrices(Q.matrixWorldInverse,w.matrixWorld),w.normalMatrix.getNormalMatrix(w.modelViewMatrix),O.onBeforeRender(I,R,Q,L,w,aA),O.transparent===!0&&O.side===Ze&&O.forceSinglePass===!1?(O.side=Te,O.needsUpdate=!0,I.renderBufferDirect(Q,R,L,O,w,aA),O.side=ht,O.needsUpdate=!0,I.renderBufferDirect(Q,R,L,O,w,aA),O.side=Ze):I.renderBufferDirect(Q,R,L,O,w,aA),w.onAfterRender(I,R,Q,L,O,aA)}function li(w,R,Q){R.isScene!==!0&&(R=OA);const L=xA.get(w),O=p.state.lights,aA=p.state.shadowsArray,hA=O.state.version,dA=Y.getParameters(w,O.state,aA,R,Q),PA=Y.getProgramCacheKey(dA);let vA=L.programs;L.environment=w.isMeshStandardMaterial?R.environment:null,L.fog=R.fog,L.envMap=(w.isMeshStandardMaterial?T:ee).get(w.envMap||L.environment),L.envMapRotation=L.environment!==null&&w.envMap===null?R.environmentRotation:w.envMapRotation,vA===void 0&&(w.addEventListener("dispose",X),vA=new Map,L.programs=vA);let SA=vA.get(PA);if(SA!==void 0){if(L.currentProgram===SA&&L.lightsStateVersion===hA)return vr(w,dA),SA}else dA.uniforms=Y.getUniforms(w),w.onBuild(Q,dA,I),w.onBeforeCompile(dA,I),SA=Y.acquireProgram(dA,PA),vA.set(PA,SA),L.uniforms=dA.uniforms;const NA=L.uniforms;return(!w.isShaderMaterial&&!w.isRawShaderMaterial||w.clipping===!0)&&(NA.clippingPlanes=rA.uniform),vr(w,dA),L.needsLights=Pc(w),L.lightsStateVersion=hA,L.needsLights&&(NA.ambientLightColor.value=O.state.ambient,NA.lightProbe.value=O.state.probe,NA.directionalLights.value=O.state.directional,NA.directionalLightShadows.value=O.state.directionalShadow,NA.spotLights.value=O.state.spot,NA.spotLightShadows.value=O.state.spotShadow,NA.rectAreaLights.value=O.state.rectArea,NA.ltc_1.value=O.state.rectAreaLTC1,NA.ltc_2.value=O.state.rectAreaLTC2,NA.pointLights.value=O.state.point,NA.pointLightShadows.value=O.state.pointShadow,NA.hemisphereLights.value=O.state.hemi,NA.directionalShadowMap.value=O.state.directionalShadowMap,NA.directionalShadowMatrix.value=O.state.directionalShadowMatrix,NA.spotShadowMap.value=O.state.spotShadowMap,NA.spotLightMatrix.value=O.state.spotLightMatrix,NA.spotLightMap.value=O.state.spotLightMap,NA.pointShadowMap.value=O.state.pointShadowMap,NA.pointShadowMatrix.value=O.state.pointShadowMatrix),L.currentProgram=SA,L.uniformsList=null,SA}function Ir(w){if(w.uniformsList===null){const R=w.currentProgram.getUniforms();w.uniformsList=ji.seqWithValue(R.seq,w.uniforms)}return w.uniformsList}function vr(w,R){const Q=xA.get(w);Q.outputColorSpace=R.outputColorSpace,Q.batching=R.batching,Q.instancing=R.instancing,Q.instancingColor=R.instancingColor,Q.instancingMorph=R.instancingMorph,Q.skinning=R.skinning,Q.morphTargets=R.morphTargets,Q.morphNormals=R.morphNormals,Q.morphColors=R.morphColors,Q.morphTargetsCount=R.morphTargetsCount,Q.numClippingPlanes=R.numClippingPlanes,Q.numIntersection=R.numClipIntersection,Q.vertexAlphas=R.vertexAlphas,Q.vertexTangents=R.vertexTangents,Q.toneMapping=R.toneMapping}function Cc(w,R,Q,L,O){R.isScene!==!0&&(R=OA),jA.resetTextureUnits();const aA=R.fog,hA=L.isMeshStandardMaterial?R.environment:null,dA=y===null?I.outputColorSpace:y.isXRRenderTarget===!0?y.texture.colorSpace:fe,PA=(L.isMeshStandardMaterial?T:ee).get(L.envMap||hA),vA=L.vertexColors===!0&&!!Q.attributes.color&&Q.attributes.color.itemSize===4,SA=!!Q.attributes.tangent&&(!!L.normalMap||L.anisotropy>0),NA=!!Q.morphAttributes.position,re=!!Q.morphAttributes.normal,pe=!!Q.morphAttributes.color;let ye=bt;L.toneMapped&&(y===null||y.isXRRenderTarget===!0)&&(ye=I.toneMapping);const et=Q.morphAttributes.position||Q.morphAttributes.normal||Q.morphAttributes.color,VA=et!==void 0?et.length:0,EA=xA.get(L),Qn=p.state.lights;if(k===!0&&(eA===!0||w!==v)){const ze=w===v&&L.id===F;rA.setState(L,w,ze)}let te=!1;L.version===EA.__version?(EA.needsLights&&EA.lightsStateVersion!==Qn.state.version||EA.outputColorSpace!==dA||O.isBatchedMesh&&EA.batching===!1||!O.isBatchedMesh&&EA.batching===!0||O.isInstancedMesh&&EA.instancing===!1||!O.isInstancedMesh&&EA.instancing===!0||O.isSkinnedMesh&&EA.skinning===!1||!O.isSkinnedMesh&&EA.skinning===!0||O.isInstancedMesh&&EA.instancingColor===!0&&O.instanceColor===null||O.isInstancedMesh&&EA.instancingColor===!1&&O.instanceColor!==null||O.isInstancedMesh&&EA.instancingMorph===!0&&O.morphTexture===null||O.isInstancedMesh&&EA.instancingMorph===!1&&O.morphTexture!==null||EA.envMap!==PA||L.fog===!0&&EA.fog!==aA||EA.numClippingPlanes!==void 0&&(EA.numClippingPlanes!==rA.numPlanes||EA.numIntersection!==rA.numIntersection)||EA.vertexAlphas!==vA||EA.vertexTangents!==SA||EA.morphTargets!==NA||EA.morphNormals!==re||EA.morphColors!==pe||EA.toneMapping!==ye||EA.morphTargetsCount!==VA)&&(te=!0):(te=!0,EA.__version=L.version);let Ut=EA.currentProgram;te===!0&&(Ut=li(L,R,O));let Er=!1,jn=!1,is=!1;const ge=Ut.getUniforms(),gt=EA.uniforms;if(CA.useProgram(Ut.program)&&(Er=!0,jn=!0,is=!0),L.id!==F&&(F=L.id,jn=!0),Er||v!==w){ge.setValue(_,"projectionMatrix",w.projectionMatrix),ge.setValue(_,"viewMatrix",w.matrixWorldInverse);const ze=ge.map.cameraPosition;ze!==void 0&&ze.setValue(_,iA.setFromMatrixPosition(w.matrixWorld)),JA.logarithmicDepthBuffer&&ge.setValue(_,"logDepthBufFC",2/(Math.log(w.far+1)/Math.LN2)),(L.isMeshPhongMaterial||L.isMeshToonMaterial||L.isMeshLambertMaterial||L.isMeshBasicMaterial||L.isMeshStandardMaterial||L.isShaderMaterial)&&ge.setValue(_,"isOrthographic",w.isOrthographicCamera===!0),v!==w&&(v=w,jn=!0,is=!0)}if(O.isSkinnedMesh){ge.setOptional(_,O,"bindMatrix"),ge.setOptional(_,O,"bindMatrixInverse");const ze=O.skeleton;ze&&(ze.boneTexture===null&&ze.computeBoneTexture(),ge.setValue(_,"boneTexture",ze.boneTexture,jA))}O.isBatchedMesh&&(ge.setOptional(_,O,"batchingTexture"),ge.setValue(_,"batchingTexture",O._matricesTexture,jA));const ss=Q.morphAttributes;if((ss.position!==void 0||ss.normal!==void 0||ss.color!==void 0)&&fA.update(O,Q,Ut),(jn||EA.receiveShadow!==O.receiveShadow)&&(EA.receiveShadow=O.receiveShadow,ge.setValue(_,"receiveShadow",O.receiveShadow)),L.isMeshGouraudMaterial&&L.envMap!==null&&(gt.envMap.value=PA,gt.flipEnvMap.value=PA.isCubeTexture&&PA.isRenderTargetTexture===!1?-1:1),L.isMeshStandardMaterial&&L.envMap===null&&R.environment!==null&&(gt.envMapIntensity.value=R.environmentIntensity),jn&&(ge.setValue(_,"toneMappingExposure",I.toneMappingExposure),EA.needsLights&&Mc(gt,is),aA&&L.fog===!0&&J.refreshFogUniforms(gt,aA),J.refreshMaterialUniforms(gt,L,q,K,p.state.transmissionRenderTarget[w.id]),ji.upload(_,Ir(EA),gt,jA)),L.isShaderMaterial&&L.uniformsNeedUpdate===!0&&(ji.upload(_,Ir(EA),gt,jA),L.uniformsNeedUpdate=!1),L.isSpriteMaterial&&ge.setValue(_,"center",O.center),ge.setValue(_,"modelViewMatrix",O.modelViewMatrix),ge.setValue(_,"normalMatrix",O.normalMatrix),ge.setValue(_,"modelMatrix",O.matrixWorld),L.isShaderMaterial||L.isRawShaderMaterial){const ze=L.uniformsGroups;for(let rs=0,wc=ze.length;rs<wc;rs++){const xr=ze[rs];_A.update(xr,Ut),_A.bind(xr,Ut)}}return Ut}function Mc(w,R){w.ambientLightColor.needsUpdate=R,w.lightProbe.needsUpdate=R,w.directionalLights.needsUpdate=R,w.directionalLightShadows.needsUpdate=R,w.pointLights.needsUpdate=R,w.pointLightShadows.needsUpdate=R,w.spotLights.needsUpdate=R,w.spotLightShadows.needsUpdate=R,w.rectAreaLights.needsUpdate=R,w.hemisphereLights.needsUpdate=R}function Pc(w){return w.isMeshLambertMaterial||w.isMeshToonMaterial||w.isMeshPhongMaterial||w.isMeshStandardMaterial||w.isShadowMaterial||w.isShaderMaterial&&w.lights===!0}this.getActiveCubeFace=function(){return z},this.getActiveMipmapLevel=function(){return D},this.getRenderTarget=function(){return y},this.setRenderTargetTextures=function(w,R,Q){xA.get(w.texture).__webglTexture=R,xA.get(w.depthTexture).__webglTexture=Q;const L=xA.get(w);L.__hasExternalTextures=!0,L.__autoAllocateDepthBuffer=Q===void 0,L.__autoAllocateDepthBuffer||gA.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),L.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(w,R){const Q=xA.get(w);Q.__webglFramebuffer=R,Q.__useDefaultFramebuffer=R===void 0},this.setRenderTarget=function(w,R=0,Q=0){y=w,z=R,D=Q;let L=!0,O=null,aA=!1,hA=!1;if(w){const PA=xA.get(w);PA.__useDefaultFramebuffer!==void 0?(CA.bindFramebuffer(_.FRAMEBUFFER,null),L=!1):PA.__webglFramebuffer===void 0?jA.setupRenderTarget(w):PA.__hasExternalTextures&&jA.rebindTextures(w,xA.get(w.texture).__webglTexture,xA.get(w.depthTexture).__webglTexture);const vA=w.texture;(vA.isData3DTexture||vA.isDataArrayTexture||vA.isCompressedArrayTexture)&&(hA=!0);const SA=xA.get(w).__webglFramebuffer;w.isWebGLCubeRenderTarget?(Array.isArray(SA[R])?O=SA[R][Q]:O=SA[R],aA=!0):w.samples>0&&jA.useMultisampledRTT(w)===!1?O=xA.get(w).__webglMultisampledFramebuffer:Array.isArray(SA)?O=SA[Q]:O=SA,P.copy(w.viewport),N.copy(w.scissor),V=w.scissorTest}else P.copy($).multiplyScalar(q).floor(),N.copy(uA).multiplyScalar(q).floor(),V=LA;if(CA.bindFramebuffer(_.FRAMEBUFFER,O)&&L&&CA.drawBuffers(w,O),CA.viewport(P),CA.scissor(N),CA.setScissorTest(V),aA){const PA=xA.get(w.texture);_.framebufferTexture2D(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,_.TEXTURE_CUBE_MAP_POSITIVE_X+R,PA.__webglTexture,Q)}else if(hA){const PA=xA.get(w.texture),vA=R||0;_.framebufferTextureLayer(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,PA.__webglTexture,Q||0,vA)}F=-1},this.readRenderTargetPixels=function(w,R,Q,L,O,aA,hA){if(!(w&&w.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let dA=xA.get(w).__webglFramebuffer;if(w.isWebGLCubeRenderTarget&&hA!==void 0&&(dA=dA[hA]),dA){CA.bindFramebuffer(_.FRAMEBUFFER,dA);try{const PA=w.texture,vA=PA.format,SA=PA.type;if(!JA.textureFormatReadable(vA)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!JA.textureTypeReadable(SA)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}R>=0&&R<=w.width-L&&Q>=0&&Q<=w.height-O&&_.readPixels(R,Q,L,O,cA.convert(vA),cA.convert(SA),aA)}finally{const PA=y!==null?xA.get(y).__webglFramebuffer:null;CA.bindFramebuffer(_.FRAMEBUFFER,PA)}}},this.copyFramebufferToTexture=function(w,R,Q=0){const L=Math.pow(2,-Q),O=Math.floor(R.image.width*L),aA=Math.floor(R.image.height*L);jA.setTexture2D(R,0),_.copyTexSubImage2D(_.TEXTURE_2D,Q,0,0,w.x,w.y,O,aA),CA.unbindTexture()},this.copyTextureToTexture=function(w,R,Q,L=0){const O=R.image.width,aA=R.image.height,hA=cA.convert(Q.format),dA=cA.convert(Q.type);jA.setTexture2D(Q,0),_.pixelStorei(_.UNPACK_FLIP_Y_WEBGL,Q.flipY),_.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Q.premultiplyAlpha),_.pixelStorei(_.UNPACK_ALIGNMENT,Q.unpackAlignment),R.isDataTexture?_.texSubImage2D(_.TEXTURE_2D,L,w.x,w.y,O,aA,hA,dA,R.image.data):R.isCompressedTexture?_.compressedTexSubImage2D(_.TEXTURE_2D,L,w.x,w.y,R.mipmaps[0].width,R.mipmaps[0].height,hA,R.mipmaps[0].data):_.texSubImage2D(_.TEXTURE_2D,L,w.x,w.y,hA,dA,R.image),L===0&&Q.generateMipmaps&&_.generateMipmap(_.TEXTURE_2D),CA.unbindTexture()},this.copyTextureToTexture3D=function(w,R,Q,L,O=0){const aA=w.max.x-w.min.x,hA=w.max.y-w.min.y,dA=w.max.z-w.min.z,PA=cA.convert(L.format),vA=cA.convert(L.type);let SA;if(L.isData3DTexture)jA.setTexture3D(L,0),SA=_.TEXTURE_3D;else if(L.isDataArrayTexture||L.isCompressedArrayTexture)jA.setTexture2DArray(L,0),SA=_.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}_.pixelStorei(_.UNPACK_FLIP_Y_WEBGL,L.flipY),_.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL,L.premultiplyAlpha),_.pixelStorei(_.UNPACK_ALIGNMENT,L.unpackAlignment);const NA=_.getParameter(_.UNPACK_ROW_LENGTH),re=_.getParameter(_.UNPACK_IMAGE_HEIGHT),pe=_.getParameter(_.UNPACK_SKIP_PIXELS),ye=_.getParameter(_.UNPACK_SKIP_ROWS),et=_.getParameter(_.UNPACK_SKIP_IMAGES),VA=Q.isCompressedTexture?Q.mipmaps[O]:Q.image;_.pixelStorei(_.UNPACK_ROW_LENGTH,VA.width),_.pixelStorei(_.UNPACK_IMAGE_HEIGHT,VA.height),_.pixelStorei(_.UNPACK_SKIP_PIXELS,w.min.x),_.pixelStorei(_.UNPACK_SKIP_ROWS,w.min.y),_.pixelStorei(_.UNPACK_SKIP_IMAGES,w.min.z),Q.isDataTexture||Q.isData3DTexture?_.texSubImage3D(SA,O,R.x,R.y,R.z,aA,hA,dA,PA,vA,VA.data):L.isCompressedArrayTexture?_.compressedTexSubImage3D(SA,O,R.x,R.y,R.z,aA,hA,dA,PA,VA.data):_.texSubImage3D(SA,O,R.x,R.y,R.z,aA,hA,dA,PA,vA,VA),_.pixelStorei(_.UNPACK_ROW_LENGTH,NA),_.pixelStorei(_.UNPACK_IMAGE_HEIGHT,re),_.pixelStorei(_.UNPACK_SKIP_PIXELS,pe),_.pixelStorei(_.UNPACK_SKIP_ROWS,ye),_.pixelStorei(_.UNPACK_SKIP_IMAGES,et),O===0&&L.generateMipmaps&&_.generateMipmap(SA),CA.unbindTexture()},this.initTexture=function(w){w.isCubeTexture?jA.setTextureCube(w,0):w.isData3DTexture?jA.setTexture3D(w,0):w.isDataArrayTexture||w.isCompressedArrayTexture?jA.setTexture2DArray(w,0):jA.setTexture2D(w,0),CA.unbindTexture()},this.resetState=function(){z=0,D=0,y=null,CA.reset(),TA.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return lt}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(A){this._outputColorSpace=A;const e=this.getContext();e.drawingBufferColorSpace=A===ar?"display-p3":"srgb",e.unpackColorSpace=WA.workingColorSpace===As?"display-p3":"srgb"}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(A){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=A}}class Ag extends ie{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Je,this.environmentIntensity=1,this.environmentRotation=new Je,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(A,e){return super.copy(A,e),A.background!==null&&(this.background=A.background.clone()),A.environment!==null&&(this.environment=A.environment.clone()),A.fog!==null&&(this.fog=A.fog.clone()),this.backgroundBlurriness=A.backgroundBlurriness,this.backgroundIntensity=A.backgroundIntensity,this.backgroundRotation.copy(A.backgroundRotation),this.environmentIntensity=A.environmentIntensity,this.environmentRotation.copy(A.environmentRotation),A.overrideMaterial!==null&&(this.overrideMaterial=A.overrideMaterial.clone()),this.matrixAutoUpdate=A.matrixAutoUpdate,this}toJSON(A){const e=super.toJSON(A);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class eg{constructor(A,e){this.isInterleavedBuffer=!0,this.array=A,this.stride=e,this.count=A!==void 0?A.length/e:0,this.usage=qs,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=He()}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}get updateRange(){return Qa("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(A){return this.usage=A,this}addUpdateRange(A,e){this.updateRanges.push({start:A,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(A){return this.array=new A.array.constructor(A.array),this.count=A.count,this.stride=A.stride,this.usage=A.usage,this}copyAt(A,e,t){A*=this.stride,t*=e.stride;for(let n=0,s=this.stride;n<s;n++)this.array[A+n]=e.array[t+n];return this}set(A,e=0){return this.array.set(A,e),this}clone(A){A.arrayBuffers===void 0&&(A.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=He()),A.arrayBuffers[this.array.buffer._uuid]===void 0&&(A.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(A.arrayBuffers[this.array.buffer._uuid]),t=new this.constructor(e,this.stride);return t.setUsage(this.usage),t}onUpload(A){return this.onUploadCallback=A,this}toJSON(A){return A.arrayBuffers===void 0&&(A.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=He()),A.arrayBuffers[this.array.buffer._uuid]===void 0&&(A.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Pe=new S;class dr{constructor(A,e,t,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=A,this.itemSize=e,this.offset=t,this.normalized=n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(A){this.data.needsUpdate=A}applyMatrix4(A){for(let e=0,t=this.data.count;e<t;e++)Pe.fromBufferAttribute(this,e),Pe.applyMatrix4(A),this.setXYZ(e,Pe.x,Pe.y,Pe.z);return this}applyNormalMatrix(A){for(let e=0,t=this.count;e<t;e++)Pe.fromBufferAttribute(this,e),Pe.applyNormalMatrix(A),this.setXYZ(e,Pe.x,Pe.y,Pe.z);return this}transformDirection(A){for(let e=0,t=this.count;e<t;e++)Pe.fromBufferAttribute(this,e),Pe.transformDirection(A),this.setXYZ(e,Pe.x,Pe.y,Pe.z);return this}getComponent(A,e){let t=this.array[A*this.data.stride+this.offset+e];return this.normalized&&(t=Qe(t,this.array)),t}setComponent(A,e,t){return this.normalized&&(t=XA(t,this.array)),this.data.array[A*this.data.stride+this.offset+e]=t,this}setX(A,e){return this.normalized&&(e=XA(e,this.array)),this.data.array[A*this.data.stride+this.offset]=e,this}setY(A,e){return this.normalized&&(e=XA(e,this.array)),this.data.array[A*this.data.stride+this.offset+1]=e,this}setZ(A,e){return this.normalized&&(e=XA(e,this.array)),this.data.array[A*this.data.stride+this.offset+2]=e,this}setW(A,e){return this.normalized&&(e=XA(e,this.array)),this.data.array[A*this.data.stride+this.offset+3]=e,this}getX(A){let e=this.data.array[A*this.data.stride+this.offset];return this.normalized&&(e=Qe(e,this.array)),e}getY(A){let e=this.data.array[A*this.data.stride+this.offset+1];return this.normalized&&(e=Qe(e,this.array)),e}getZ(A){let e=this.data.array[A*this.data.stride+this.offset+2];return this.normalized&&(e=Qe(e,this.array)),e}getW(A){let e=this.data.array[A*this.data.stride+this.offset+3];return this.normalized&&(e=Qe(e,this.array)),e}setXY(A,e,t){return A=A*this.data.stride+this.offset,this.normalized&&(e=XA(e,this.array),t=XA(t,this.array)),this.data.array[A+0]=e,this.data.array[A+1]=t,this}setXYZ(A,e,t,n){return A=A*this.data.stride+this.offset,this.normalized&&(e=XA(e,this.array),t=XA(t,this.array),n=XA(n,this.array)),this.data.array[A+0]=e,this.data.array[A+1]=t,this.data.array[A+2]=n,this}setXYZW(A,e,t,n,s){return A=A*this.data.stride+this.offset,this.normalized&&(e=XA(e,this.array),t=XA(t,this.array),n=XA(n,this.array),s=XA(s,this.array)),this.data.array[A+0]=e,this.data.array[A+1]=t,this.data.array[A+2]=n,this.data.array[A+3]=s,this}clone(A){if(A===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[n+s])}return new xe(new this.array.constructor(e),this.itemSize,this.normalized)}else return A.interleavedBuffers===void 0&&(A.interleavedBuffers={}),A.interleavedBuffers[this.data.uuid]===void 0&&(A.interleavedBuffers[this.data.uuid]=this.data.clone(A)),new dr(A.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(A){if(A===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[n+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return A.interleavedBuffers===void 0&&(A.interleavedBuffers={}),A.interleavedBuffers[this.data.uuid]===void 0&&(A.interleavedBuffers[this.data.uuid]=this.data.toJSON(A)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const Xo=new S,Yo=new qA,Jo=new qA,tg=new S,Ko=new RA,Ri=new S,Os=new Ke,qo=new RA,Fs=new ri;class ng extends Ee{constructor(A,e){super(A,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=br,this.bindMatrix=new RA,this.bindMatrixInverse=new RA,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const A=this.geometry;this.boundingBox===null&&(this.boundingBox=new ut),this.boundingBox.makeEmpty();const e=A.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,Ri),this.boundingBox.expandByPoint(Ri)}computeBoundingSphere(){const A=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Ke),this.boundingSphere.makeEmpty();const e=A.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,Ri),this.boundingSphere.expandByPoint(Ri)}copy(A,e){return super.copy(A,e),this.bindMode=A.bindMode,this.bindMatrix.copy(A.bindMatrix),this.bindMatrixInverse.copy(A.bindMatrixInverse),this.skeleton=A.skeleton,A.boundingBox!==null&&(this.boundingBox=A.boundingBox.clone()),A.boundingSphere!==null&&(this.boundingSphere=A.boundingSphere.clone()),this}raycast(A,e){const t=this.material,n=this.matrixWorld;t!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Os.copy(this.boundingSphere),Os.applyMatrix4(n),A.ray.intersectsSphere(Os)!==!1&&(qo.copy(n).invert(),Fs.copy(A.ray).applyMatrix4(qo),!(this.boundingBox!==null&&Fs.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(A,e,Fs)))}getVertexPosition(A,e){return super.getVertexPosition(A,e),this.applyBoneTransform(A,e),e}bind(A,e){this.skeleton=A,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const A=new qA,e=this.geometry.attributes.skinWeight;for(let t=0,n=e.count;t<n;t++){A.fromBufferAttribute(e,t);const s=1/A.manhattanLength();s!==1/0?A.multiplyScalar(s):A.set(1,0,0,0),e.setXYZW(t,A.x,A.y,A.z,A.w)}}updateMatrixWorld(A){super.updateMatrixWorld(A),this.bindMode===br?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===il?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(A,e){const t=this.skeleton,n=this.geometry;Yo.fromBufferAttribute(n.attributes.skinIndex,A),Jo.fromBufferAttribute(n.attributes.skinWeight,A),Xo.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const r=Jo.getComponent(s);if(r!==0){const o=Yo.getComponent(s);Ko.multiplyMatrices(t.bones[o].matrixWorld,t.boneInverses[o]),e.addScaledVector(tg.copy(Xo).applyMatrix4(Ko),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}class nc extends ie{constructor(){super(),this.isBone=!0,this.type="Bone"}}class ic extends ue{constructor(A=null,e=1,t=1,n,s,r,o,a,c=ve,l=ve,h,u){super(null,r,o,a,c,l,n,s,h,u),this.isDataTexture=!0,this.image={data:A,width:e,height:t},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const $o=new RA,ig=new RA;class fr{constructor(A=[],e=[]){this.uuid=He(),this.bones=A.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const A=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(A.length*16),e.length===0)this.calculateInverses();else if(A.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,n=this.bones.length;t<n;t++)this.boneInverses.push(new RA)}}calculateInverses(){this.boneInverses.length=0;for(let A=0,e=this.bones.length;A<e;A++){const t=new RA;this.bones[A]&&t.copy(this.bones[A].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){for(let A=0,e=this.bones.length;A<e;A++){const t=this.bones[A];t&&t.matrixWorld.copy(this.boneInverses[A]).invert()}for(let A=0,e=this.bones.length;A<e;A++){const t=this.bones[A];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){const A=this.bones,e=this.boneInverses,t=this.boneMatrices,n=this.boneTexture;for(let s=0,r=A.length;s<r;s++){const o=A[s]?A[s].matrixWorld:ig;$o.multiplyMatrices(o,e[s]),$o.toArray(t,s*16)}n!==null&&(n.needsUpdate=!0)}clone(){return new fr(this.bones,this.boneInverses)}computeBoneTexture(){let A=Math.sqrt(this.bones.length*4);A=Math.ceil(A/4)*4,A=Math.max(A,4);const e=new Float32Array(A*A*4);e.set(this.boneMatrices);const t=new ic(e,A,A,je,Ye);return t.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=t,this}getBoneByName(A){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];if(n.name===A)return n}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(A,e){this.uuid=A.uuid;for(let t=0,n=A.bones.length;t<n;t++){const s=A.bones[t];let r=e[s];r===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),r=new nc),this.bones.push(r),this.boneInverses.push(new RA().fromArray(A.boneInverses[t]))}return this.init(),this}toJSON(){const A={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};A.uuid=this.uuid;const e=this.bones,t=this.boneInverses;for(let n=0,s=e.length;n<s;n++){const r=e[n];A.bones.push(r.uuid);const o=t[n];A.boneInverses.push(o.toArray())}return A}}class Ar extends xe{constructor(A,e,t,n=1){super(A,e,t),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(A){return super.copy(A),this.meshPerAttribute=A.meshPerAttribute,this}toJSON(){const A=super.toJSON();return A.meshPerAttribute=this.meshPerAttribute,A.isInstancedBufferAttribute=!0,A}}const Cn=new RA,Aa=new RA,zi=[],ea=new ut,sg=new RA,Wn=new Ee,Zn=new Ke;class rg extends Ee{constructor(A,e,t){super(A,e),this.isInstancedMesh=!0,this.instanceMatrix=new Ar(new Float32Array(t*16),16),this.instanceColor=null,this.morphTexture=null,this.count=t,this.boundingBox=null,this.boundingSphere=null;for(let n=0;n<t;n++)this.setMatrixAt(n,sg)}computeBoundingBox(){const A=this.geometry,e=this.count;this.boundingBox===null&&(this.boundingBox=new ut),A.boundingBox===null&&A.computeBoundingBox(),this.boundingBox.makeEmpty();for(let t=0;t<e;t++)this.getMatrixAt(t,Cn),ea.copy(A.boundingBox).applyMatrix4(Cn),this.boundingBox.union(ea)}computeBoundingSphere(){const A=this.geometry,e=this.count;this.boundingSphere===null&&(this.boundingSphere=new Ke),A.boundingSphere===null&&A.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let t=0;t<e;t++)this.getMatrixAt(t,Cn),Zn.copy(A.boundingSphere).applyMatrix4(Cn),this.boundingSphere.union(Zn)}copy(A,e){return super.copy(A,e),this.instanceMatrix.copy(A.instanceMatrix),A.morphTexture!==null&&(this.morphTexture=A.morphTexture.clone()),A.instanceColor!==null&&(this.instanceColor=A.instanceColor.clone()),this.count=A.count,A.boundingBox!==null&&(this.boundingBox=A.boundingBox.clone()),A.boundingSphere!==null&&(this.boundingSphere=A.boundingSphere.clone()),this}getColorAt(A,e){e.fromArray(this.instanceColor.array,A*3)}getMatrixAt(A,e){e.fromArray(this.instanceMatrix.array,A*16)}getMorphAt(A,e){const t=e.morphTargetInfluences,n=this.morphTexture.source.data.data,s=t.length+1,r=A*s+1;for(let o=0;o<t.length;o++)t[o]=n[r+o]}raycast(A,e){const t=this.matrixWorld,n=this.count;if(Wn.geometry=this.geometry,Wn.material=this.material,Wn.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Zn.copy(this.boundingSphere),Zn.applyMatrix4(t),A.ray.intersectsSphere(Zn)!==!1))for(let s=0;s<n;s++){this.getMatrixAt(s,Cn),Aa.multiplyMatrices(t,Cn),Wn.matrixWorld=Aa,Wn.raycast(A,zi);for(let r=0,o=zi.length;r<o;r++){const a=zi[r];a.instanceId=s,a.object=this,e.push(a)}zi.length=0}}setColorAt(A,e){this.instanceColor===null&&(this.instanceColor=new Ar(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,A*3)}setMatrixAt(A,e){e.toArray(this.instanceMatrix.array,A*16)}setMorphAt(A,e){const t=e.morphTargetInfluences,n=t.length+1;this.morphTexture===null&&(this.morphTexture=new ic(new Float32Array(n*this.count),n,this.count,Ra,Ye));const s=this.morphTexture.source.data.data;let r=0;for(let c=0;c<t.length;c++)r+=t[c];const o=this.geometry.morphTargetsRelative?1:1-r,a=n*A;s[a]=o,s.set(t,a+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}class sc extends ke{constructor(A){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new wA(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.linewidth=A.linewidth,this.linecap=A.linecap,this.linejoin=A.linejoin,this.fog=A.fog,this}}const Yi=new S,Ji=new S,ta=new RA,Xn=new ri,_i=new Ke,Qs=new S,na=new S;class pr extends ie{constructor(A=new Ve,e=new sc){super(),this.isLine=!0,this.type="Line",this.geometry=A,this.material=e,this.updateMorphTargets()}copy(A,e){return super.copy(A,e),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}computeLineDistances(){const A=this.geometry;if(A.index===null){const e=A.attributes.position,t=[0];for(let n=1,s=e.count;n<s;n++)Yi.fromBufferAttribute(e,n-1),Ji.fromBufferAttribute(e,n),t[n]=t[n-1],t[n]+=Yi.distanceTo(Ji);A.setAttribute("lineDistance",new Ne(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(A,e){const t=this.geometry,n=this.matrixWorld,s=A.params.Line.threshold,r=t.drawRange;if(t.boundingSphere===null&&t.computeBoundingSphere(),_i.copy(t.boundingSphere),_i.applyMatrix4(n),_i.radius+=s,A.ray.intersectsSphere(_i)===!1)return;ta.copy(n).invert(),Xn.copy(A.ray).applyMatrix4(ta);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,c=this.isLineSegments?2:1,l=t.index,u=t.attributes.position;if(l!==null){const d=Math.max(0,r.start),g=Math.min(l.count,r.start+r.count);for(let C=d,p=g-1;C<p;C+=c){const f=l.getX(C),E=l.getX(C+1),I=Ui(this,A,Xn,a,f,E);I&&e.push(I)}if(this.isLineLoop){const C=l.getX(g-1),p=l.getX(d),f=Ui(this,A,Xn,a,C,p);f&&e.push(f)}}else{const d=Math.max(0,r.start),g=Math.min(u.count,r.start+r.count);for(let C=d,p=g-1;C<p;C+=c){const f=Ui(this,A,Xn,a,C,C+1);f&&e.push(f)}if(this.isLineLoop){const C=Ui(this,A,Xn,a,g-1,d);C&&e.push(C)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,r=n.length;s<r;s++){const o=n[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}function Ui(i,A,e,t,n,s){const r=i.geometry.attributes.position;if(Yi.fromBufferAttribute(r,n),Ji.fromBufferAttribute(r,s),e.distanceSqToSegment(Yi,Ji,Qs,na)>t)return;Qs.applyMatrix4(i.matrixWorld);const a=A.ray.origin.distanceTo(Qs);if(!(a<A.near||a>A.far))return{distance:a,point:na.clone().applyMatrix4(i.matrixWorld),index:n,face:null,faceIndex:null,object:i}}const ia=new S,sa=new S;class og extends pr{constructor(A,e){super(A,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const A=this.geometry;if(A.index===null){const e=A.attributes.position,t=[];for(let n=0,s=e.count;n<s;n+=2)ia.fromBufferAttribute(e,n),sa.fromBufferAttribute(e,n+1),t[n]=n===0?0:t[n-1],t[n+1]=t[n]+ia.distanceTo(sa);A.setAttribute("lineDistance",new Ne(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class ag extends pr{constructor(A,e){super(A,e),this.isLineLoop=!0,this.type="LineLoop"}}class rc extends ke{constructor(A){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new wA(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.alphaMap=A.alphaMap,this.size=A.size,this.sizeAttenuation=A.sizeAttenuation,this.fog=A.fog,this}}const ra=new RA,er=new ri,Ni=new Ke,Li=new S;class cg extends ie{constructor(A=new Ve,e=new rc){super(),this.isPoints=!0,this.type="Points",this.geometry=A,this.material=e,this.updateMorphTargets()}copy(A,e){return super.copy(A,e),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}raycast(A,e){const t=this.geometry,n=this.matrixWorld,s=A.params.Points.threshold,r=t.drawRange;if(t.boundingSphere===null&&t.computeBoundingSphere(),Ni.copy(t.boundingSphere),Ni.applyMatrix4(n),Ni.radius+=s,A.ray.intersectsSphere(Ni)===!1)return;ra.copy(n).invert(),er.copy(A.ray).applyMatrix4(ra);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,c=t.index,h=t.attributes.position;if(c!==null){const u=Math.max(0,r.start),d=Math.min(c.count,r.start+r.count);for(let g=u,C=d;g<C;g++){const p=c.getX(g);Li.fromBufferAttribute(h,p),oa(Li,p,a,n,A,e,this)}}else{const u=Math.max(0,r.start),d=Math.min(h.count,r.start+r.count);for(let g=u,C=d;g<C;g++)Li.fromBufferAttribute(h,g),oa(Li,g,a,n,A,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,r=n.length;s<r;s++){const o=n[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}function oa(i,A,e,t,n,s,r){const o=er.distanceSqToPoint(i);if(o<e){const a=new S;er.closestPointToPoint(i,a),a.applyMatrix4(t);const c=n.ray.origin.distanceTo(a);if(c<n.near||c>n.far)return;s.push({distance:c,distanceToRay:Math.sqrt(o),point:a,index:A,face:null,object:r})}}class gr extends Ve{constructor(A=1,e=.4,t=12,n=48,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:A,tube:e,radialSegments:t,tubularSegments:n,arc:s},t=Math.floor(t),n=Math.floor(n);const r=[],o=[],a=[],c=[],l=new S,h=new S,u=new S;for(let d=0;d<=t;d++)for(let g=0;g<=n;g++){const C=g/n*s,p=d/t*Math.PI*2;h.x=(A+e*Math.cos(p))*Math.cos(C),h.y=(A+e*Math.cos(p))*Math.sin(C),h.z=e*Math.sin(p),o.push(h.x,h.y,h.z),l.x=A*Math.cos(C),l.y=A*Math.sin(C),u.subVectors(h,l).normalize(),a.push(u.x,u.y,u.z),c.push(g/n),c.push(d/t)}for(let d=1;d<=t;d++)for(let g=1;g<=n;g++){const C=(n+1)*d+g-1,p=(n+1)*(d-1)+g-1,f=(n+1)*(d-1)+g,E=(n+1)*d+g;r.push(C,p,E),r.push(p,f,E)}this.setIndex(r),this.setAttribute("position",new Ne(o,3)),this.setAttribute("normal",new Ne(a,3)),this.setAttribute("uv",new Ne(c,2))}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new gr(A.radius,A.tube,A.radialSegments,A.tubularSegments,A.arc)}}class ts extends ke{constructor(A){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new wA(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new wA(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=or,this.normalScale=new MA(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Je,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.defines={STANDARD:""},this.color.copy(A.color),this.roughness=A.roughness,this.metalness=A.metalness,this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.emissive.copy(A.emissive),this.emissiveMap=A.emissiveMap,this.emissiveIntensity=A.emissiveIntensity,this.bumpMap=A.bumpMap,this.bumpScale=A.bumpScale,this.normalMap=A.normalMap,this.normalMapType=A.normalMapType,this.normalScale.copy(A.normalScale),this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.roughnessMap=A.roughnessMap,this.metalnessMap=A.metalnessMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.envMapRotation.copy(A.envMapRotation),this.envMapIntensity=A.envMapIntensity,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.flatShading=A.flatShading,this.fog=A.fog,this}}class qe extends ts{constructor(A){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new MA(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return de(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new wA(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new wA(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new wA(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(A)}get anisotropy(){return this._anisotropy}set anisotropy(A){this._anisotropy>0!=A>0&&this.version++,this._anisotropy=A}get clearcoat(){return this._clearcoat}set clearcoat(A){this._clearcoat>0!=A>0&&this.version++,this._clearcoat=A}get iridescence(){return this._iridescence}set iridescence(A){this._iridescence>0!=A>0&&this.version++,this._iridescence=A}get dispersion(){return this._dispersion}set dispersion(A){this._dispersion>0!=A>0&&this.version++,this._dispersion=A}get sheen(){return this._sheen}set sheen(A){this._sheen>0!=A>0&&this.version++,this._sheen=A}get transmission(){return this._transmission}set transmission(A){this._transmission>0!=A>0&&this.version++,this._transmission=A}copy(A){return super.copy(A),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=A.anisotropy,this.anisotropyRotation=A.anisotropyRotation,this.anisotropyMap=A.anisotropyMap,this.clearcoat=A.clearcoat,this.clearcoatMap=A.clearcoatMap,this.clearcoatRoughness=A.clearcoatRoughness,this.clearcoatRoughnessMap=A.clearcoatRoughnessMap,this.clearcoatNormalMap=A.clearcoatNormalMap,this.clearcoatNormalScale.copy(A.clearcoatNormalScale),this.dispersion=A.dispersion,this.ior=A.ior,this.iridescence=A.iridescence,this.iridescenceMap=A.iridescenceMap,this.iridescenceIOR=A.iridescenceIOR,this.iridescenceThicknessRange=[...A.iridescenceThicknessRange],this.iridescenceThicknessMap=A.iridescenceThicknessMap,this.sheen=A.sheen,this.sheenColor.copy(A.sheenColor),this.sheenColorMap=A.sheenColorMap,this.sheenRoughness=A.sheenRoughness,this.sheenRoughnessMap=A.sheenRoughnessMap,this.transmission=A.transmission,this.transmissionMap=A.transmissionMap,this.thickness=A.thickness,this.thicknessMap=A.thicknessMap,this.attenuationDistance=A.attenuationDistance,this.attenuationColor.copy(A.attenuationColor),this.specularIntensity=A.specularIntensity,this.specularIntensityMap=A.specularIntensityMap,this.specularColor.copy(A.specularColor),this.specularColorMap=A.specularColorMap,this}}class lg extends ke{constructor(A){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new wA(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=or,this.normalScale=new MA(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.defines={MATCAP:""},this.color.copy(A.color),this.matcap=A.matcap,this.map=A.map,this.bumpMap=A.bumpMap,this.bumpScale=A.bumpScale,this.normalMap=A.normalMap,this.normalMapType=A.normalMapType,this.normalScale.copy(A.normalScale),this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.alphaMap=A.alphaMap,this.flatShading=A.flatShading,this.fog=A.fog,this}}function Oi(i,A,e){return!i||!e&&i.constructor===A?i:typeof A.BYTES_PER_ELEMENT=="number"?new A(i):Array.prototype.slice.call(i)}function hg(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)}function ug(i){function A(n,s){return i[n]-i[s]}const e=i.length,t=new Array(e);for(let n=0;n!==e;++n)t[n]=n;return t.sort(A),t}function aa(i,A,e){const t=i.length,n=new i.constructor(t);for(let s=0,r=0;r!==t;++s){const o=e[s]*A;for(let a=0;a!==A;++a)n[r++]=i[o+a]}return n}function oc(i,A,e,t){let n=1,s=i[0];for(;s!==void 0&&s[t]===void 0;)s=i[n++];if(s===void 0)return;let r=s[t];if(r!==void 0)if(Array.isArray(r))do r=s[t],r!==void 0&&(A.push(s.time),e.push.apply(e,r)),s=i[n++];while(s!==void 0);else if(r.toArray!==void 0)do r=s[t],r!==void 0&&(A.push(s.time),r.toArray(e,e.length)),s=i[n++];while(s!==void 0);else do r=s[t],r!==void 0&&(A.push(s.time),e.push(r)),s=i[n++];while(s!==void 0)}class ci{constructor(A,e,t,n){this.parameterPositions=A,this._cachedIndex=0,this.resultBuffer=n!==void 0?n:new e.constructor(t),this.sampleValues=e,this.valueSize=t,this.settings=null,this.DefaultSettings_={}}evaluate(A){const e=this.parameterPositions;let t=this._cachedIndex,n=e[t],s=e[t-1];A:{e:{let r;t:{n:if(!(A<n)){for(let o=t+2;;){if(n===void 0){if(A<s)break n;return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}if(t===o)break;if(s=n,n=e[++t],A<n)break e}r=e.length;break t}if(!(A>=s)){const o=e[1];A<o&&(t=2,s=o);for(let a=t-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(t===a)break;if(n=s,s=e[--t-1],A>=s)break e}r=t,t=0;break t}break A}for(;t<r;){const o=t+r>>>1;A<e[o]?r=o:t=o+1}if(n=e[t],s=e[t-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===void 0)return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}this._cachedIndex=t,this.intervalChanged_(t,s,n)}return this.interpolate_(t,s,A,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(A){const e=this.resultBuffer,t=this.sampleValues,n=this.valueSize,s=A*n;for(let r=0;r!==n;++r)e[r]=t[s+r];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class dg extends ci{constructor(A,e,t,n){super(A,e,t,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Mn,endingEnd:Mn}}intervalChanged_(A,e,t){const n=this.parameterPositions;let s=A-2,r=A+1,o=n[s],a=n[r];if(o===void 0)switch(this.getSettings_().endingStart){case Pn:s=A,o=2*e-t;break;case Vi:s=n.length-2,o=e+n[s]-n[s+1];break;default:s=A,o=t}if(a===void 0)switch(this.getSettings_().endingEnd){case Pn:r=A,a=2*t-e;break;case Vi:r=1,a=t+n[1]-n[0];break;default:r=A-1,a=e}const c=(t-e)*.5,l=this.valueSize;this._weightPrev=c/(e-o),this._weightNext=c/(a-t),this._offsetPrev=s*l,this._offsetNext=r*l}interpolate_(A,e,t,n){const s=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=A*o,c=a-o,l=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,g=(t-e)/(n-e),C=g*g,p=C*g,f=-u*p+2*u*C-u*g,E=(1+u)*p+(-1.5-2*u)*C+(-.5+u)*g+1,I=(-1-d)*p+(1.5+d)*C+.5*g,x=d*p-d*C;for(let z=0;z!==o;++z)s[z]=f*r[l+z]+E*r[c+z]+I*r[a+z]+x*r[h+z];return s}}class ac extends ci{constructor(A,e,t,n){super(A,e,t,n)}interpolate_(A,e,t,n){const s=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=A*o,c=a-o,l=(t-e)/(n-e),h=1-l;for(let u=0;u!==o;++u)s[u]=r[c+u]*h+r[a+u]*l;return s}}class fg extends ci{constructor(A,e,t,n){super(A,e,t,n)}interpolate_(A){return this.copySampleValue_(A-1)}}class $e{constructor(A,e,t,n){if(A===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+A);this.name=A,this.times=Oi(e,this.TimeBufferType),this.values=Oi(t,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}static toJSON(A){const e=A.constructor;let t;if(e.toJSON!==this.toJSON)t=e.toJSON(A);else{t={name:A.name,times:Oi(A.times,Array),values:Oi(A.values,Array)};const n=A.getInterpolation();n!==A.DefaultInterpolation&&(t.interpolation=n)}return t.type=A.ValueTypeName,t}InterpolantFactoryMethodDiscrete(A){return new fg(this.times,this.values,this.getValueSize(),A)}InterpolantFactoryMethodLinear(A){return new ac(this.times,this.values,this.getValueSize(),A)}InterpolantFactoryMethodSmooth(A){return new dg(this.times,this.values,this.getValueSize(),A)}setInterpolation(A){let e;switch(A){case ni:e=this.InterpolantFactoryMethodDiscrete;break;case bn:e=this.InterpolantFactoryMethodLinear;break;case us:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(A!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(t);return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ni;case this.InterpolantFactoryMethodLinear:return bn;case this.InterpolantFactoryMethodSmooth:return us}}getValueSize(){return this.values.length/this.times.length}shift(A){if(A!==0){const e=this.times;for(let t=0,n=e.length;t!==n;++t)e[t]+=A}return this}scale(A){if(A!==1){const e=this.times;for(let t=0,n=e.length;t!==n;++t)e[t]*=A}return this}trim(A,e){const t=this.times,n=t.length;let s=0,r=n-1;for(;s!==n&&t[s]<A;)++s;for(;r!==-1&&t[r]>e;)--r;if(++r,s!==0||r!==n){s>=r&&(r=Math.max(r,1),s=r-1);const o=this.getValueSize();this.times=t.slice(s,r),this.values=this.values.slice(s*o,r*o)}return this}validate(){let A=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),A=!1);const t=this.times,n=this.values,s=t.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),A=!1);let r=null;for(let o=0;o!==s;o++){const a=t[o];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,a),A=!1;break}if(r!==null&&r>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,a,r),A=!1;break}r=a}if(n!==void 0&&hg(n))for(let o=0,a=n.length;o!==a;++o){const c=n[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),A=!1;break}}return A}optimize(){const A=this.times.slice(),e=this.values.slice(),t=this.getValueSize(),n=this.getInterpolation()===us,s=A.length-1;let r=1;for(let o=1;o<s;++o){let a=!1;const c=A[o],l=A[o+1];if(c!==l&&(o!==1||c!==A[0]))if(n)a=!0;else{const h=o*t,u=h-t,d=h+t;for(let g=0;g!==t;++g){const C=e[h+g];if(C!==e[u+g]||C!==e[d+g]){a=!0;break}}}if(a){if(o!==r){A[r]=A[o];const h=o*t,u=r*t;for(let d=0;d!==t;++d)e[u+d]=e[h+d]}++r}}if(s>0){A[r]=A[s];for(let o=s*t,a=r*t,c=0;c!==t;++c)e[a+c]=e[o+c];++r}return r!==A.length?(this.times=A.slice(0,r),this.values=e.slice(0,r*t)):(this.times=A,this.values=e),this}clone(){const A=this.times.slice(),e=this.values.slice(),t=this.constructor,n=new t(this.name,A,e);return n.createInterpolant=this.createInterpolant,n}}$e.prototype.TimeBufferType=Float32Array;$e.prototype.ValueBufferType=Float32Array;$e.prototype.DefaultInterpolation=bn;class Nn extends $e{}Nn.prototype.ValueTypeName="bool";Nn.prototype.ValueBufferType=Array;Nn.prototype.DefaultInterpolation=ni;Nn.prototype.InterpolantFactoryMethodLinear=void 0;Nn.prototype.InterpolantFactoryMethodSmooth=void 0;class cc extends $e{}cc.prototype.ValueTypeName="color";class zn extends $e{}zn.prototype.ValueTypeName="number";class pg extends ci{constructor(A,e,t,n){super(A,e,t,n)}interpolate_(A,e,t,n){const s=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=(t-e)/(n-e);let c=A*o;for(let l=c+o;c!==l;c+=4)Be.slerpFlat(s,0,r,c-o,r,c,a);return s}}class Yt extends $e{InterpolantFactoryMethodLinear(A){return new pg(this.times,this.values,this.getValueSize(),A)}}Yt.prototype.ValueTypeName="quaternion";Yt.prototype.DefaultInterpolation=bn;Yt.prototype.InterpolantFactoryMethodSmooth=void 0;class Ln extends $e{}Ln.prototype.ValueTypeName="string";Ln.prototype.ValueBufferType=Array;Ln.prototype.DefaultInterpolation=ni;Ln.prototype.InterpolantFactoryMethodLinear=void 0;Ln.prototype.InterpolantFactoryMethodSmooth=void 0;class _n extends $e{}_n.prototype.ValueTypeName="vector";class tr{constructor(A="",e=-1,t=[],n=rr){this.name=A,this.tracks=t,this.duration=e,this.blendMode=n,this.uuid=He(),this.duration<0&&this.resetDuration()}static parse(A){const e=[],t=A.tracks,n=1/(A.fps||1);for(let r=0,o=t.length;r!==o;++r)e.push(mg(t[r]).scale(n));const s=new this(A.name,A.duration,e,A.blendMode);return s.uuid=A.uuid,s}static toJSON(A){const e=[],t=A.tracks,n={name:A.name,duration:A.duration,tracks:e,uuid:A.uuid,blendMode:A.blendMode};for(let s=0,r=t.length;s!==r;++s)e.push($e.toJSON(t[s]));return n}static CreateFromMorphTargetSequence(A,e,t,n){const s=e.length,r=[];for(let o=0;o<s;o++){let a=[],c=[];a.push((o+s-1)%s,o,(o+1)%s),c.push(0,1,0);const l=ug(a);a=aa(a,1,l),c=aa(c,1,l),!n&&a[0]===0&&(a.push(s),c.push(c[0])),r.push(new zn(".morphTargetInfluences["+e[o].name+"]",a,c).scale(1/t))}return new this(A,-1,r)}static findByName(A,e){let t=A;if(!Array.isArray(A)){const n=A;t=n.geometry&&n.geometry.animations||n.animations}for(let n=0;n<t.length;n++)if(t[n].name===e)return t[n];return null}static CreateClipsFromMorphTargetSequences(A,e,t){const n={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,a=A.length;o<a;o++){const c=A[o],l=c.name.match(s);if(l&&l.length>1){const h=l[1];let u=n[h];u||(n[h]=u=[]),u.push(c)}}const r=[];for(const o in n)r.push(this.CreateFromMorphTargetSequence(o,n[o],e,t));return r}static parseAnimation(A,e){if(!A)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const t=function(h,u,d,g,C){if(d.length!==0){const p=[],f=[];oc(d,p,f,g),p.length!==0&&C.push(new h(u,p,f))}},n=[],s=A.name||"default",r=A.fps||30,o=A.blendMode;let a=A.length||-1;const c=A.hierarchy||[];for(let h=0;h<c.length;h++){const u=c[h].keys;if(!(!u||u.length===0))if(u[0].morphTargets){const d={};let g;for(g=0;g<u.length;g++)if(u[g].morphTargets)for(let C=0;C<u[g].morphTargets.length;C++)d[u[g].morphTargets[C]]=-1;for(const C in d){const p=[],f=[];for(let E=0;E!==u[g].morphTargets.length;++E){const I=u[g];p.push(I.time),f.push(I.morphTarget===C?1:0)}n.push(new zn(".morphTargetInfluence["+C+"]",p,f))}a=d.length*r}else{const d=".bones["+e[h].name+"]";t(_n,d+".position",u,"pos",n),t(Yt,d+".quaternion",u,"rot",n),t(_n,d+".scale",u,"scl",n)}}return n.length===0?null:new this(s,a,n,o)}resetDuration(){const A=this.tracks;let e=0;for(let t=0,n=A.length;t!==n;++t){const s=this.tracks[t];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let A=0;A<this.tracks.length;A++)this.tracks[A].trim(0,this.duration);return this}validate(){let A=!0;for(let e=0;e<this.tracks.length;e++)A=A&&this.tracks[e].validate();return A}optimize(){for(let A=0;A<this.tracks.length;A++)this.tracks[A].optimize();return this}clone(){const A=[];for(let e=0;e<this.tracks.length;e++)A.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,A,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function gg(i){switch(i.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return zn;case"vector":case"vector2":case"vector3":case"vector4":return _n;case"color":return cc;case"quaternion":return Yt;case"bool":case"boolean":return Nn;case"string":return Ln}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+i)}function mg(i){if(i.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const A=gg(i.type);if(i.times===void 0){const e=[],t=[];oc(i.keys,e,t,"value"),i.times=e,i.values=t}return A.parse!==void 0?A.parse(i):new A(i.name,i.times,i.values,i.interpolation)}const Dt={enabled:!1,files:{},add:function(i,A){this.enabled!==!1&&(this.files[i]=A)},get:function(i){if(this.enabled!==!1)return this.files[i]},remove:function(i){delete this.files[i]},clear:function(){this.files={}}};class Cg{constructor(A,e,t){const n=this;let s=!1,r=0,o=0,a;const c=[];this.onStart=void 0,this.onLoad=A,this.onProgress=e,this.onError=t,this.itemStart=function(l){o++,s===!1&&n.onStart!==void 0&&n.onStart(l,r,o),s=!0},this.itemEnd=function(l){r++,n.onProgress!==void 0&&n.onProgress(l,r,o),r===o&&(s=!1,n.onLoad!==void 0&&n.onLoad())},this.itemError=function(l){n.onError!==void 0&&n.onError(l)},this.resolveURL=function(l){return a?a(l):l},this.setURLModifier=function(l){return a=l,this},this.addHandler=function(l,h){return c.push(l,h),this},this.removeHandler=function(l){const h=c.indexOf(l);return h!==-1&&c.splice(h,2),this},this.getHandler=function(l){for(let h=0,u=c.length;h<u;h+=2){const d=c[h],g=c[h+1];if(d.global&&(d.lastIndex=0),d.test(l))return g}return null}}}const Mg=new Cg;class On{constructor(A){this.manager=A!==void 0?A:Mg,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(A,e){const t=this;return new Promise(function(n,s){t.load(A,n,e,s)})}parse(){}setCrossOrigin(A){return this.crossOrigin=A,this}setWithCredentials(A){return this.withCredentials=A,this}setPath(A){return this.path=A,this}setResourcePath(A){return this.resourcePath=A,this}setRequestHeader(A){return this.requestHeader=A,this}}On.DEFAULT_MATERIAL_NAME="__DEFAULT";const ot={};class Pg extends Error{constructor(A,e){super(A),this.response=e}}class lc extends On{constructor(A){super(A)}load(A,e,t,n){A===void 0&&(A=""),this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const s=Dt.get(A);if(s!==void 0)return this.manager.itemStart(A),setTimeout(()=>{e&&e(s),this.manager.itemEnd(A)},0),s;if(ot[A]!==void 0){ot[A].push({onLoad:e,onProgress:t,onError:n});return}ot[A]=[],ot[A].push({onLoad:e,onProgress:t,onError:n});const r=new Request(A,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,a=this.responseType;fetch(r).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const l=ot[A],h=c.body.getReader(),u=c.headers.get("X-File-Size")||c.headers.get("Content-Length"),d=u?parseInt(u):0,g=d!==0;let C=0;const p=new ReadableStream({start(f){E();function E(){h.read().then(({done:I,value:x})=>{if(I)f.close();else{C+=x.byteLength;const z=new ProgressEvent("progress",{lengthComputable:g,loaded:C,total:d});for(let D=0,y=l.length;D<y;D++){const F=l[D];F.onProgress&&F.onProgress(z)}f.enqueue(x),E()}})}}});return new Response(p)}else throw new Pg(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(a){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(l=>new DOMParser().parseFromString(l,o));case"json":return c.json();default:if(o===void 0)return c.text();{const h=/charset="?([^;"\s]*)"?/i.exec(o),u=h&&h[1]?h[1].toLowerCase():void 0,d=new TextDecoder(u);return c.arrayBuffer().then(g=>d.decode(g))}}}).then(c=>{Dt.add(A,c);const l=ot[A];delete ot[A];for(let h=0,u=l.length;h<u;h++){const d=l[h];d.onLoad&&d.onLoad(c)}}).catch(c=>{const l=ot[A];if(l===void 0)throw this.manager.itemError(A),c;delete ot[A];for(let h=0,u=l.length;h<u;h++){const d=l[h];d.onError&&d.onError(c)}this.manager.itemError(A)}).finally(()=>{this.manager.itemEnd(A)}),this.manager.itemStart(A)}setResponseType(A){return this.responseType=A,this}setMimeType(A){return this.mimeType=A,this}}class wg extends On{constructor(A){super(A)}load(A,e,t,n){this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const s=this,r=Dt.get(A);if(r!==void 0)return s.manager.itemStart(A),setTimeout(function(){e&&e(r),s.manager.itemEnd(A)},0),r;const o=ii("img");function a(){l(),Dt.add(A,this),e&&e(this),s.manager.itemEnd(A)}function c(h){l(),n&&n(h),s.manager.itemError(A),s.manager.itemEnd(A)}function l(){o.removeEventListener("load",a,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",a,!1),o.addEventListener("error",c,!1),A.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(A),o.src=A,o}}class hc extends On{constructor(A){super(A)}load(A,e,t,n){const s=new ue,r=new wg(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(A,function(o){s.image=o,s.needsUpdate=!0,e!==void 0&&e(s)},t,n),s}}class ns extends ie{constructor(A,e=1){super(),this.isLight=!0,this.type="Light",this.color=new wA(A),this.intensity=e}dispose(){}copy(A,e){return super.copy(A,e),this.color.copy(A.color),this.intensity=A.intensity,this}toJSON(A){const e=super.toJSON(A);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}const js=new RA,ca=new S,la=new S;class mr{constructor(A){this.camera=A,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new MA(512,512),this.map=null,this.mapPass=null,this.matrix=new RA,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new lr,this._frameExtents=new MA(1,1),this._viewportCount=1,this._viewports=[new qA(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(A){const e=this.camera,t=this.matrix;ca.setFromMatrixPosition(A.matrixWorld),e.position.copy(ca),la.setFromMatrixPosition(A.target.matrixWorld),e.lookAt(la),e.updateMatrixWorld(),js.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(js),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(js)}getViewport(A){return this._viewports[A]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(A){return this.camera=A.camera.clone(),this.bias=A.bias,this.radius=A.radius,this.mapSize.copy(A.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const A={};return this.bias!==0&&(A.bias=this.bias),this.normalBias!==0&&(A.normalBias=this.normalBias),this.radius!==1&&(A.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(A.mapSize=this.mapSize.toArray()),A.camera=this.camera.toJSON(!1).object,delete A.camera.matrix,A}}class Ig extends mr{constructor(){super(new Ie(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(A){const e=this.camera,t=Bn*2*A.angle*this.focus,n=this.mapSize.width/this.mapSize.height,s=A.distance||e.far;(t!==e.fov||n!==e.aspect||s!==e.far)&&(e.fov=t,e.aspect=n,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(A)}copy(A){return super.copy(A),this.focus=A.focus,this}}class vg extends ns{constructor(A,e,t=0,n=Math.PI/3,s=0,r=2){super(A,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(ie.DEFAULT_UP),this.updateMatrix(),this.target=new ie,this.distance=t,this.angle=n,this.penumbra=s,this.decay=r,this.map=null,this.shadow=new Ig}get power(){return this.intensity*Math.PI}set power(A){this.intensity=A/Math.PI}dispose(){this.shadow.dispose()}copy(A,e){return super.copy(A,e),this.distance=A.distance,this.angle=A.angle,this.penumbra=A.penumbra,this.decay=A.decay,this.target=A.target.clone(),this.shadow=A.shadow.clone(),this}}const ha=new RA,Yn=new S,Hs=new S;class Eg extends mr{constructor(){super(new Ie(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new MA(4,2),this._viewportCount=6,this._viewports=[new qA(2,1,1,1),new qA(0,1,1,1),new qA(3,1,1,1),new qA(1,1,1,1),new qA(3,0,1,1),new qA(1,0,1,1)],this._cubeDirections=[new S(1,0,0),new S(-1,0,0),new S(0,0,1),new S(0,0,-1),new S(0,1,0),new S(0,-1,0)],this._cubeUps=[new S(0,1,0),new S(0,1,0),new S(0,1,0),new S(0,1,0),new S(0,0,1),new S(0,0,-1)]}updateMatrices(A,e=0){const t=this.camera,n=this.matrix,s=A.distance||t.far;s!==t.far&&(t.far=s,t.updateProjectionMatrix()),Yn.setFromMatrixPosition(A.matrixWorld),t.position.copy(Yn),Hs.copy(t.position),Hs.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(Hs),t.updateMatrixWorld(),n.makeTranslation(-Yn.x,-Yn.y,-Yn.z),ha.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ha)}}class xg extends ns{constructor(A,e,t=0,n=2){super(A,e),this.isPointLight=!0,this.type="PointLight",this.distance=t,this.decay=n,this.shadow=new Eg}get power(){return this.intensity*4*Math.PI}set power(A){this.intensity=A/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(A,e){return super.copy(A,e),this.distance=A.distance,this.decay=A.decay,this.shadow=A.shadow.clone(),this}}class Tg extends mr{constructor(){super(new hr(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class uc extends ns{constructor(A,e){super(A,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(ie.DEFAULT_UP),this.updateMatrix(),this.target=new ie,this.shadow=new Tg}dispose(){this.shadow.dispose()}copy(A){return super.copy(A),this.target=A.target.clone(),this.shadow=A.shadow.clone(),this}}class yg extends ns{constructor(A,e){super(A,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class ei{static decodeText(A){if(typeof TextDecoder<"u")return new TextDecoder().decode(A);let e="";for(let t=0,n=A.length;t<n;t++)e+=String.fromCharCode(A[t]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(A){const e=A.lastIndexOf("/");return e===-1?"./":A.slice(0,e+1)}static resolveURL(A,e){return typeof A!="string"||A===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(A)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(A)||/^data:.*,.*$/i.test(A)||/^blob:.*$/i.test(A)?A:e+A)}}class Dg extends On{constructor(A){super(A),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(A){return this.options=A,this}load(A,e,t,n){A===void 0&&(A=""),this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const s=this,r=Dt.get(A);if(r!==void 0){if(s.manager.itemStart(A),r.then){r.then(c=>{e&&e(c),s.manager.itemEnd(A)}).catch(c=>{n&&n(c)});return}return setTimeout(function(){e&&e(r),s.manager.itemEnd(A)},0),r}const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader;const a=fetch(A,o).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(c){return Dt.add(A,c),e&&e(c),s.manager.itemEnd(A),c}).catch(function(c){n&&n(c),Dt.remove(A),s.manager.itemError(A),s.manager.itemEnd(A)});Dt.add(A,a),s.manager.itemStart(A)}}class Sg{constructor(A=!0){this.autoStart=A,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=ua(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let A=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=ua();A=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=A}return A}}function ua(){return(typeof performance>"u"?Date:performance).now()}class bg{constructor(A,e,t){this.binding=A,this.valueSize=t;let n,s,r;switch(e){case"quaternion":n=this._slerp,s=this._slerpAdditive,r=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(t*6),this._workIndex=5;break;case"string":case"bool":n=this._select,s=this._select,r=this._setAdditiveIdentityOther,this.buffer=new Array(t*5);break;default:n=this._lerp,s=this._lerpAdditive,r=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(t*5)}this._mixBufferRegion=n,this._mixBufferRegionAdditive=s,this._setIdentity=r,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(A,e){const t=this.buffer,n=this.valueSize,s=A*n+n;let r=this.cumulativeWeight;if(r===0){for(let o=0;o!==n;++o)t[s+o]=t[o];r=e}else{r+=e;const o=e/r;this._mixBufferRegion(t,s,0,o,n)}this.cumulativeWeight=r}accumulateAdditive(A){const e=this.buffer,t=this.valueSize,n=t*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,n,0,A,t),this.cumulativeWeightAdditive+=A}apply(A){const e=this.valueSize,t=this.buffer,n=A*e+e,s=this.cumulativeWeight,r=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const a=e*this._origIndex;this._mixBufferRegion(t,n,a,1-s,e)}r>0&&this._mixBufferRegionAdditive(t,n,this._addIndex*e,1,e);for(let a=e,c=e+e;a!==c;++a)if(t[a]!==t[a+e]){o.setValue(t,n);break}}saveOriginalState(){const A=this.binding,e=this.buffer,t=this.valueSize,n=t*this._origIndex;A.getValue(e,n);for(let s=t,r=n;s!==r;++s)e[s]=e[n+s%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const A=this.valueSize*3;this.binding.setValue(this.buffer,A)}_setAdditiveIdentityNumeric(){const A=this._addIndex*this.valueSize,e=A+this.valueSize;for(let t=A;t<e;t++)this.buffer[t]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const A=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[A+t]}_select(A,e,t,n,s){if(n>=.5)for(let r=0;r!==s;++r)A[e+r]=A[t+r]}_slerp(A,e,t,n){Be.slerpFlat(A,e,A,e,A,t,n)}_slerpAdditive(A,e,t,n,s){const r=this._workIndex*s;Be.multiplyQuaternionsFlat(A,r,A,e,A,t),Be.slerpFlat(A,e,A,e,A,r,n)}_lerp(A,e,t,n,s){const r=1-n;for(let o=0;o!==s;++o){const a=e+o;A[a]=A[a]*r+A[t+o]*n}}_lerpAdditive(A,e,t,n,s){for(let r=0;r!==s;++r){const o=e+r;A[o]=A[o]+A[t+r]*n}}}const Cr="\\[\\]\\.:\\/",Bg=new RegExp("["+Cr+"]","g"),Mr="[^"+Cr+"]",Rg="[^"+Cr.replace("\\.","")+"]",zg=/((?:WC+[\/:])*)/.source.replace("WC",Mr),_g=/(WCOD+)?/.source.replace("WCOD",Rg),Ug=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Mr),Ng=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Mr),Lg=new RegExp("^"+zg+_g+Ug+Ng+"$"),Og=["material","materials","bones","map"];class Fg{constructor(A,e,t){const n=t||GA.parseTrackName(e);this._targetGroup=A,this._bindings=A.subscribe_(e,n)}getValue(A,e){this.bind();const t=this._targetGroup.nCachedObjects_,n=this._bindings[t];n!==void 0&&n.getValue(A,e)}setValue(A,e){const t=this._bindings;for(let n=this._targetGroup.nCachedObjects_,s=t.length;n!==s;++n)t[n].setValue(A,e)}bind(){const A=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=A.length;e!==t;++e)A[e].bind()}unbind(){const A=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=A.length;e!==t;++e)A[e].unbind()}}class GA{constructor(A,e,t){this.path=e,this.parsedPath=t||GA.parseTrackName(e),this.node=GA.findNode(A,this.parsedPath.nodeName),this.rootNode=A,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(A,e,t){return A&&A.isAnimationObjectGroup?new GA.Composite(A,e,t):new GA(A,e,t)}static sanitizeNodeName(A){return A.replace(/\s/g,"_").replace(Bg,"")}static parseTrackName(A){const e=Lg.exec(A);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+A);const t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},n=t.nodeName&&t.nodeName.lastIndexOf(".");if(n!==void 0&&n!==-1){const s=t.nodeName.substring(n+1);Og.indexOf(s)!==-1&&(t.nodeName=t.nodeName.substring(0,n),t.objectName=s)}if(t.propertyName===null||t.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+A);return t}static findNode(A,e){if(e===void 0||e===""||e==="."||e===-1||e===A.name||e===A.uuid)return A;if(A.skeleton){const t=A.skeleton.getBoneByName(e);if(t!==void 0)return t}if(A.children){const t=function(s){for(let r=0;r<s.length;r++){const o=s[r];if(o.name===e||o.uuid===e)return o;const a=t(o.children);if(a)return a}return null},n=t(A.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(A,e){A[e]=this.targetObject[this.propertyName]}_getValue_array(A,e){const t=this.resolvedProperty;for(let n=0,s=t.length;n!==s;++n)A[e++]=t[n]}_getValue_arrayElement(A,e){A[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(A,e){this.resolvedProperty.toArray(A,e)}_setValue_direct(A,e){this.targetObject[this.propertyName]=A[e]}_setValue_direct_setNeedsUpdate(A,e){this.targetObject[this.propertyName]=A[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(A,e){this.targetObject[this.propertyName]=A[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(A,e){const t=this.resolvedProperty;for(let n=0,s=t.length;n!==s;++n)t[n]=A[e++]}_setValue_array_setNeedsUpdate(A,e){const t=this.resolvedProperty;for(let n=0,s=t.length;n!==s;++n)t[n]=A[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(A,e){const t=this.resolvedProperty;for(let n=0,s=t.length;n!==s;++n)t[n]=A[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(A,e){this.resolvedProperty[this.propertyIndex]=A[e]}_setValue_arrayElement_setNeedsUpdate(A,e){this.resolvedProperty[this.propertyIndex]=A[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(A,e){this.resolvedProperty[this.propertyIndex]=A[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(A,e){this.resolvedProperty.fromArray(A,e)}_setValue_fromArray_setNeedsUpdate(A,e){this.resolvedProperty.fromArray(A,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(A,e){this.resolvedProperty.fromArray(A,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(A,e){this.bind(),this.getValue(A,e)}_setValue_unbound(A,e){this.bind(),this.setValue(A,e)}bind(){let A=this.node;const e=this.parsedPath,t=e.objectName,n=e.propertyName;let s=e.propertyIndex;if(A||(A=GA.findNode(this.rootNode,e.nodeName),this.node=A),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!A){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(t){let c=e.objectIndex;switch(t){case"materials":if(!A.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!A.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}A=A.material.materials;break;case"bones":if(!A.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}A=A.skeleton.bones;for(let l=0;l<A.length;l++)if(A[l].name===c){c=l;break}break;case"map":if("map"in A){A=A.map;break}if(!A.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!A.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}A=A.material.map;break;default:if(A[t]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}A=A[t]}if(c!==void 0){if(A[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,A);return}A=A[c]}}const r=A[n];if(r===void 0){const c=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+n+" but it wasn't found.",A);return}let o=this.Versioning.None;this.targetObject=A,A.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:A.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(s!==void 0){if(n==="morphTargetInfluences"){if(!A.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!A.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}A.morphTargetDictionary[s]!==void 0&&(s=A.morphTargetDictionary[s])}a=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=s}else r.fromArray!==void 0&&r.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(a=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=n;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}GA.Composite=Fg;GA.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};GA.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};GA.prototype.GetterByBindingType=[GA.prototype._getValue_direct,GA.prototype._getValue_array,GA.prototype._getValue_arrayElement,GA.prototype._getValue_toArray];GA.prototype.SetterByBindingTypeAndVersioning=[[GA.prototype._setValue_direct,GA.prototype._setValue_direct_setNeedsUpdate,GA.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[GA.prototype._setValue_array,GA.prototype._setValue_array_setNeedsUpdate,GA.prototype._setValue_array_setMatrixWorldNeedsUpdate],[GA.prototype._setValue_arrayElement,GA.prototype._setValue_arrayElement_setNeedsUpdate,GA.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[GA.prototype._setValue_fromArray,GA.prototype._setValue_fromArray_setNeedsUpdate,GA.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Qg{constructor(A,e,t=null,n=e.blendMode){this._mixer=A,this._clip=e,this._localRoot=t,this.blendMode=n;const s=e.tracks,r=s.length,o=new Array(r),a={endingStart:Mn,endingEnd:Mn};for(let c=0;c!==r;++c){const l=s[c].createInterpolant(null);o[c]=l,l.settings=a}this._interpolantSettings=a,this._interpolants=o,this._propertyBindings=new Array(r),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=pl,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(A){return this._startTime=A,this}setLoop(A,e){return this.loop=A,this.repetitions=e,this}setEffectiveWeight(A){return this.weight=A,this._effectiveWeight=this.enabled?A:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(A){return this._scheduleFading(A,0,1)}fadeOut(A){return this._scheduleFading(A,1,0)}crossFadeFrom(A,e,t){if(A.fadeOut(e),this.fadeIn(e),t){const n=this._clip.duration,s=A._clip.duration,r=s/n,o=n/s;A.warp(1,r,e),this.warp(o,1,e)}return this}crossFadeTo(A,e,t){return A.crossFadeFrom(this,e,t)}stopFading(){const A=this._weightInterpolant;return A!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(A)),this}setEffectiveTimeScale(A){return this.timeScale=A,this._effectiveTimeScale=this.paused?0:A,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(A){return this.timeScale=this._clip.duration/A,this.stopWarping()}syncWith(A){return this.time=A.time,this.timeScale=A.timeScale,this.stopWarping()}halt(A){return this.warp(this._effectiveTimeScale,0,A)}warp(A,e,t){const n=this._mixer,s=n.time,r=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=n._lendControlInterpolant(),this._timeScaleInterpolant=o);const a=o.parameterPositions,c=o.sampleValues;return a[0]=s,a[1]=s+t,c[0]=A/r,c[1]=e/r,this}stopWarping(){const A=this._timeScaleInterpolant;return A!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(A)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(A,e,t,n){if(!this.enabled){this._updateWeight(A);return}const s=this._startTime;if(s!==null){const a=(A-s)*t;a<0||t===0?e=0:(this._startTime=null,e=t*a)}e*=this._updateTimeScale(A);const r=this._updateTime(e),o=this._updateWeight(A);if(o>0){const a=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case ml:for(let l=0,h=a.length;l!==h;++l)a[l].evaluate(r),c[l].accumulateAdditive(o);break;case rr:default:for(let l=0,h=a.length;l!==h;++l)a[l].evaluate(r),c[l].accumulate(n,o)}}}_updateWeight(A){let e=0;if(this.enabled){e=this.weight;const t=this._weightInterpolant;if(t!==null){const n=t.evaluate(A)[0];e*=n,A>t.parameterPositions[1]&&(this.stopFading(),n===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(A){let e=0;if(!this.paused){e=this.timeScale;const t=this._timeScaleInterpolant;if(t!==null){const n=t.evaluate(A)[0];e*=n,A>t.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(A){const e=this._clip.duration,t=this.loop;let n=this.time+A,s=this._loopCount;const r=t===gl;if(A===0)return s===-1?n:r&&(s&1)===1?e-n:n;if(t===fl){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));A:{if(n>=e)n=e;else if(n<0)n=0;else{this.time=n;break A}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:A<0?-1:1})}}else{if(s===-1&&(A>=0?(s=0,this._setEndings(!0,this.repetitions===0,r)):this._setEndings(this.repetitions===0,!0,r)),n>=e||n<0){const o=Math.floor(n/e);n-=e*o,s+=Math.abs(o);const a=this.repetitions-s;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,n=A>0?e:0,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:A>0?1:-1});else{if(a===1){const c=A<0;this._setEndings(c,!c,r)}else this._setEndings(!1,!1,r);this._loopCount=s,this.time=n,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=n;if(r&&(s&1)===1)return e-n}return n}_setEndings(A,e,t){const n=this._interpolantSettings;t?(n.endingStart=Pn,n.endingEnd=Pn):(A?n.endingStart=this.zeroSlopeAtStart?Pn:Mn:n.endingStart=Vi,e?n.endingEnd=this.zeroSlopeAtEnd?Pn:Mn:n.endingEnd=Vi)}_scheduleFading(A,e,t){const n=this._mixer,s=n.time;let r=this._weightInterpolant;r===null&&(r=n._lendControlInterpolant(),this._weightInterpolant=r);const o=r.parameterPositions,a=r.sampleValues;return o[0]=s,a[0]=e,o[1]=s+A,a[1]=t,this}}const jg=new Float32Array(1);class Hg extends _t{constructor(A){super(),this._root=A,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(A,e){const t=A._localRoot||this._root,n=A._clip.tracks,s=n.length,r=A._propertyBindings,o=A._interpolants,a=t.uuid,c=this._bindingsByRootAndName;let l=c[a];l===void 0&&(l={},c[a]=l);for(let h=0;h!==s;++h){const u=n[h],d=u.name;let g=l[d];if(g!==void 0)++g.referenceCount,r[h]=g;else{if(g=r[h],g!==void 0){g._cacheIndex===null&&(++g.referenceCount,this._addInactiveBinding(g,a,d));continue}const C=e&&e._propertyBindings[h].binding.parsedPath;g=new bg(GA.create(t,d,C),u.ValueTypeName,u.getValueSize()),++g.referenceCount,this._addInactiveBinding(g,a,d),r[h]=g}o[h].resultBuffer=g.buffer}}_activateAction(A){if(!this._isActiveAction(A)){if(A._cacheIndex===null){const t=(A._localRoot||this._root).uuid,n=A._clip.uuid,s=this._actionsByClip[n];this._bindAction(A,s&&s.knownActions[0]),this._addInactiveAction(A,n,t)}const e=A._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const s=e[t];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(A)}}_deactivateAction(A){if(this._isActiveAction(A)){const e=A._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const s=e[t];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(A)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const A=this;this.stats={actions:{get total(){return A._actions.length},get inUse(){return A._nActiveActions}},bindings:{get total(){return A._bindings.length},get inUse(){return A._nActiveBindings}},controlInterpolants:{get total(){return A._controlInterpolants.length},get inUse(){return A._nActiveControlInterpolants}}}}_isActiveAction(A){const e=A._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(A,e,t){const n=this._actions,s=this._actionsByClip;let r=s[e];if(r===void 0)r={knownActions:[A],actionByRoot:{}},A._byClipCacheIndex=0,s[e]=r;else{const o=r.knownActions;A._byClipCacheIndex=o.length,o.push(A)}A._cacheIndex=n.length,n.push(A),r.actionByRoot[t]=A}_removeInactiveAction(A){const e=this._actions,t=e[e.length-1],n=A._cacheIndex;t._cacheIndex=n,e[n]=t,e.pop(),A._cacheIndex=null;const s=A._clip.uuid,r=this._actionsByClip,o=r[s],a=o.knownActions,c=a[a.length-1],l=A._byClipCacheIndex;c._byClipCacheIndex=l,a[l]=c,a.pop(),A._byClipCacheIndex=null;const h=o.actionByRoot,u=(A._localRoot||this._root).uuid;delete h[u],a.length===0&&delete r[s],this._removeInactiveBindingsForAction(A)}_removeInactiveBindingsForAction(A){const e=A._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const s=e[t];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(A){const e=this._actions,t=A._cacheIndex,n=this._nActiveActions++,s=e[n];A._cacheIndex=n,e[n]=A,s._cacheIndex=t,e[t]=s}_takeBackAction(A){const e=this._actions,t=A._cacheIndex,n=--this._nActiveActions,s=e[n];A._cacheIndex=n,e[n]=A,s._cacheIndex=t,e[t]=s}_addInactiveBinding(A,e,t){const n=this._bindingsByRootAndName,s=this._bindings;let r=n[e];r===void 0&&(r={},n[e]=r),r[t]=A,A._cacheIndex=s.length,s.push(A)}_removeInactiveBinding(A){const e=this._bindings,t=A.binding,n=t.rootNode.uuid,s=t.path,r=this._bindingsByRootAndName,o=r[n],a=e[e.length-1],c=A._cacheIndex;a._cacheIndex=c,e[c]=a,e.pop(),delete o[s],Object.keys(o).length===0&&delete r[n]}_lendBinding(A){const e=this._bindings,t=A._cacheIndex,n=this._nActiveBindings++,s=e[n];A._cacheIndex=n,e[n]=A,s._cacheIndex=t,e[t]=s}_takeBackBinding(A){const e=this._bindings,t=A._cacheIndex,n=--this._nActiveBindings,s=e[n];A._cacheIndex=n,e[n]=A,s._cacheIndex=t,e[t]=s}_lendControlInterpolant(){const A=this._controlInterpolants,e=this._nActiveControlInterpolants++;let t=A[e];return t===void 0&&(t=new ac(new Float32Array(2),new Float32Array(2),1,jg),t.__cacheIndex=e,A[e]=t),t}_takeBackControlInterpolant(A){const e=this._controlInterpolants,t=A.__cacheIndex,n=--this._nActiveControlInterpolants,s=e[n];A.__cacheIndex=n,e[n]=A,s.__cacheIndex=t,e[t]=s}clipAction(A,e,t){const n=e||this._root,s=n.uuid;let r=typeof A=="string"?tr.findByName(n,A):A;const o=r!==null?r.uuid:A,a=this._actionsByClip[o];let c=null;if(t===void 0&&(r!==null?t=r.blendMode:t=rr),a!==void 0){const h=a.actionByRoot[s];if(h!==void 0&&h.blendMode===t)return h;c=a.knownActions[0],r===null&&(r=c._clip)}if(r===null)return null;const l=new Qg(this,r,e,t);return this._bindAction(l,c),this._addInactiveAction(l,o,s),l}existingAction(A,e){const t=e||this._root,n=t.uuid,s=typeof A=="string"?tr.findByName(t,A):A,r=s?s.uuid:A,o=this._actionsByClip[r];return o!==void 0&&o.actionByRoot[n]||null}stopAllAction(){const A=this._actions,e=this._nActiveActions;for(let t=e-1;t>=0;--t)A[t].stop();return this}update(A){A*=this.timeScale;const e=this._actions,t=this._nActiveActions,n=this.time+=A,s=Math.sign(A),r=this._accuIndex^=1;for(let c=0;c!==t;++c)e[c]._update(n,A,s,r);const o=this._bindings,a=this._nActiveBindings;for(let c=0;c!==a;++c)o[c].apply(r);return this}setTime(A){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(A)}getRoot(){return this._root}uncacheClip(A){const e=this._actions,t=A.uuid,n=this._actionsByClip,s=n[t];if(s!==void 0){const r=s.knownActions;for(let o=0,a=r.length;o!==a;++o){const c=r[o];this._deactivateAction(c);const l=c._cacheIndex,h=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=l,e[l]=h,e.pop(),this._removeInactiveBindingsForAction(c)}delete n[t]}}uncacheRoot(A){const e=A.uuid,t=this._actionsByClip;for(const r in t){const o=t[r].actionByRoot,a=o[e];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const n=this._bindingsByRootAndName,s=n[e];if(s!==void 0)for(const r in s){const o=s[r];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(A,e){const t=this.existingAction(A,e);t!==null&&(this._deactivateAction(t),this._removeInactiveAction(t))}}class da{constructor(A=1,e=0,t=0){return this.radius=A,this.phi=e,this.theta=t,this}set(A,e,t){return this.radius=A,this.phi=e,this.theta=t,this}copy(A){return this.radius=A.radius,this.phi=A.phi,this.theta=A.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(A){return this.setFromCartesianCoords(A.x,A.y,A.z)}setFromCartesianCoords(A,e,t){return this.radius=Math.sqrt(A*A+e*e+t*t),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(A,t),this.phi=Math.acos(de(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:sr}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=sr);const fa={type:"change"},ks={type:"start"},pa={type:"end"},Fi=new ri,ga=new Et,kg=Math.cos(70*Oa.DEG2RAD);class Vg extends _t{constructor(A,e){super(),this.object=A,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new S,this.cursor=new S,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:qt.ROTATE,MIDDLE:qt.DOLLY,RIGHT:qt.PAN},this.touches={ONE:$t.ROTATE,TWO:$t.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return o.phi},this.getAzimuthalAngle=function(){return o.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(m){m.addEventListener("keydown",IA),this._domElementKeyEvents=m},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",IA),this._domElementKeyEvents=null},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,t.object.updateProjectionMatrix(),t.dispatchEvent(fa),t.update(),s=n.NONE},this.update=function(){const m=new S,B=new Be().setFromUnitVectors(A.up,new S(0,1,0)),U=B.clone().invert(),X=new S,tA=new Be,yA=new S,UA=2*Math.PI;return function(le=null){const kA=t.object.position;m.copy(kA).sub(t.target),m.applyQuaternion(B),o.setFromVector3(m),t.autoRotate&&s===n.NONE&&V(P(le)),t.enableDamping?(o.theta+=a.theta*t.dampingFactor,o.phi+=a.phi*t.dampingFactor):(o.theta+=a.theta,o.phi+=a.phi);let se=t.minAzimuthAngle,$A=t.maxAzimuthAngle;isFinite(se)&&isFinite($A)&&(se<-Math.PI?se+=UA:se>Math.PI&&(se-=UA),$A<-Math.PI?$A+=UA:$A>Math.PI&&($A-=UA),se<=$A?o.theta=Math.max(se,Math.min($A,o.theta)):o.theta=o.theta>(se+$A)/2?Math.max(se,o.theta):Math.min($A,o.theta)),o.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,o.phi)),o.makeSafe(),t.enableDamping===!0?t.target.addScaledVector(l,t.dampingFactor):t.target.add(l),t.target.sub(t.cursor),t.target.clampLength(t.minTargetRadius,t.maxTargetRadius),t.target.add(t.cursor);let ft=!1;if(t.zoomToCursor&&D||t.object.isOrthographicCamera)o.radius=$(o.radius);else{const Re=o.radius;o.radius=$(o.radius*c),ft=Re!=o.radius}if(m.setFromSpherical(o),m.applyQuaternion(U),kA.copy(t.target).add(m),t.object.lookAt(t.target),t.enableDamping===!0?(a.theta*=1-t.dampingFactor,a.phi*=1-t.dampingFactor,l.multiplyScalar(1-t.dampingFactor)):(a.set(0,0,0),l.set(0,0,0)),t.zoomToCursor&&D){let Re=null;if(t.object.isPerspectiveCamera){const pt=m.length();Re=$(pt*c);const At=pt-Re;t.object.position.addScaledVector(x,At),t.object.updateMatrixWorld(),ft=!!At}else if(t.object.isOrthographicCamera){const pt=new S(z.x,z.y,0);pt.unproject(t.object);const At=t.object.zoom;t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/c)),t.object.updateProjectionMatrix(),ft=At!==t.object.zoom;const Fn=new S(z.x,z.y,0);Fn.unproject(t.object),t.object.position.sub(Fn).add(pt),t.object.updateMatrixWorld(),Re=m.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),t.zoomToCursor=!1;Re!==null&&(this.screenSpacePanning?t.target.set(0,0,-1).transformDirection(t.object.matrix).multiplyScalar(Re).add(t.object.position):(Fi.origin.copy(t.object.position),Fi.direction.set(0,0,-1).transformDirection(t.object.matrix),Math.abs(t.object.up.dot(Fi.direction))<kg?A.lookAt(t.target):(ga.setFromNormalAndCoplanarPoint(t.object.up,t.target),Fi.intersectPlane(ga,t.target))))}else if(t.object.isOrthographicCamera){const Re=t.object.zoom;t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/c)),Re!==t.object.zoom&&(t.object.updateProjectionMatrix(),ft=!0)}return c=1,D=!1,ft||X.distanceToSquared(t.object.position)>r||8*(1-tA.dot(t.object.quaternion))>r||yA.distanceToSquared(t.target)>r?(t.dispatchEvent(fa),X.copy(t.object.position),tA.copy(t.object.quaternion),yA.copy(t.target),!0):!1}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",HA),t.domElement.removeEventListener("pointerdown",T),t.domElement.removeEventListener("pointercancel",j),t.domElement.removeEventListener("wheel",J),t.domElement.removeEventListener("pointermove",M),t.domElement.removeEventListener("pointerup",j),t.domElement.getRootNode().removeEventListener("keydown",oA,{capture:!0}),t._domElementKeyEvents!==null&&(t._domElementKeyEvents.removeEventListener("keydown",IA),t._domElementKeyEvents=null)};const t=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=n.NONE;const r=1e-6,o=new da,a=new da;let c=1;const l=new S,h=new MA,u=new MA,d=new MA,g=new MA,C=new MA,p=new MA,f=new MA,E=new MA,I=new MA,x=new S,z=new MA;let D=!1;const y=[],F={};let v=!1;function P(m){return m!==null?2*Math.PI/60*t.autoRotateSpeed*m:2*Math.PI/60/60*t.autoRotateSpeed}function N(m){const B=Math.abs(m*.01);return Math.pow(.95,t.zoomSpeed*B)}function V(m){a.theta-=m}function b(m){a.phi-=m}const W=function(){const m=new S;return function(U,X){m.setFromMatrixColumn(X,0),m.multiplyScalar(-U),l.add(m)}}(),G=function(){const m=new S;return function(U,X){t.screenSpacePanning===!0?m.setFromMatrixColumn(X,1):(m.setFromMatrixColumn(X,0),m.crossVectors(t.object.up,m)),m.multiplyScalar(U),l.add(m)}}(),K=function(){const m=new S;return function(U,X){const tA=t.domElement;if(t.object.isPerspectiveCamera){const yA=t.object.position;m.copy(yA).sub(t.target);let UA=m.length();UA*=Math.tan(t.object.fov/2*Math.PI/180),W(2*U*UA/tA.clientHeight,t.object.matrix),G(2*X*UA/tA.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(W(U*(t.object.right-t.object.left)/t.object.zoom/tA.clientWidth,t.object.matrix),G(X*(t.object.top-t.object.bottom)/t.object.zoom/tA.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}}();function q(m){t.object.isPerspectiveCamera||t.object.isOrthographicCamera?c/=m:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function H(m){t.object.isPerspectiveCamera||t.object.isOrthographicCamera?c*=m:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function AA(m,B){if(!t.zoomToCursor)return;D=!0;const U=t.domElement.getBoundingClientRect(),X=m-U.left,tA=B-U.top,yA=U.width,UA=U.height;z.x=X/yA*2-1,z.y=-(tA/UA)*2+1,x.set(z.x,z.y,1).unproject(t.object).sub(t.object.position).normalize()}function $(m){return Math.max(t.minDistance,Math.min(t.maxDistance,m))}function uA(m){h.set(m.clientX,m.clientY)}function LA(m){AA(m.clientX,m.clientX),f.set(m.clientX,m.clientY)}function ZA(m){g.set(m.clientX,m.clientY)}function k(m){u.set(m.clientX,m.clientY),d.subVectors(u,h).multiplyScalar(t.rotateSpeed);const B=t.domElement;V(2*Math.PI*d.x/B.clientHeight),b(2*Math.PI*d.y/B.clientHeight),h.copy(u),t.update()}function eA(m){E.set(m.clientX,m.clientY),I.subVectors(E,f),I.y>0?q(N(I.y)):I.y<0&&H(N(I.y)),f.copy(E),t.update()}function lA(m){C.set(m.clientX,m.clientY),p.subVectors(C,g).multiplyScalar(t.panSpeed),K(p.x,p.y),g.copy(C),t.update()}function iA(m){AA(m.clientX,m.clientY),m.deltaY<0?H(N(m.deltaY)):m.deltaY>0&&q(N(m.deltaY)),t.update()}function OA(m){let B=!1;switch(m.code){case t.keys.UP:m.ctrlKey||m.metaKey||m.shiftKey?b(2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):K(0,t.keyPanSpeed),B=!0;break;case t.keys.BOTTOM:m.ctrlKey||m.metaKey||m.shiftKey?b(-2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):K(0,-t.keyPanSpeed),B=!0;break;case t.keys.LEFT:m.ctrlKey||m.metaKey||m.shiftKey?V(2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):K(t.keyPanSpeed,0),B=!0;break;case t.keys.RIGHT:m.ctrlKey||m.metaKey||m.shiftKey?V(-2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):K(-t.keyPanSpeed,0),B=!0;break}B&&(m.preventDefault(),t.update())}function zA(m){if(y.length===1)h.set(m.pageX,m.pageY);else{const B=KA(m),U=.5*(m.pageX+B.x),X=.5*(m.pageY+B.y);h.set(U,X)}}function _(m){if(y.length===1)g.set(m.pageX,m.pageY);else{const B=KA(m),U=.5*(m.pageX+B.x),X=.5*(m.pageY+B.y);g.set(U,X)}}function YA(m){const B=KA(m),U=m.pageX-B.x,X=m.pageY-B.y,tA=Math.sqrt(U*U+X*X);f.set(0,tA)}function gA(m){t.enableZoom&&YA(m),t.enablePan&&_(m)}function JA(m){t.enableZoom&&YA(m),t.enableRotate&&zA(m)}function CA(m){if(y.length==1)u.set(m.pageX,m.pageY);else{const U=KA(m),X=.5*(m.pageX+U.x),tA=.5*(m.pageY+U.y);u.set(X,tA)}d.subVectors(u,h).multiplyScalar(t.rotateSpeed);const B=t.domElement;V(2*Math.PI*d.x/B.clientHeight),b(2*Math.PI*d.y/B.clientHeight),h.copy(u)}function FA(m){if(y.length===1)C.set(m.pageX,m.pageY);else{const B=KA(m),U=.5*(m.pageX+B.x),X=.5*(m.pageY+B.y);C.set(U,X)}p.subVectors(C,g).multiplyScalar(t.panSpeed),K(p.x,p.y),g.copy(C)}function xA(m){const B=KA(m),U=m.pageX-B.x,X=m.pageY-B.y,tA=Math.sqrt(U*U+X*X);E.set(0,tA),I.set(0,Math.pow(E.y/f.y,t.zoomSpeed)),q(I.y),f.copy(E);const yA=(m.pageX+B.x)*.5,UA=(m.pageY+B.y)*.5;AA(yA,UA)}function jA(m){t.enableZoom&&xA(m),t.enablePan&&FA(m)}function ee(m){t.enableZoom&&xA(m),t.enableRotate&&CA(m)}function T(m){t.enabled!==!1&&(y.length===0&&(t.domElement.setPointerCapture(m.pointerId),t.domElement.addEventListener("pointermove",M),t.domElement.addEventListener("pointerup",j)),!TA(m)&&(mA(m),m.pointerType==="touch"?nA(m):Z(m)))}function M(m){t.enabled!==!1&&(m.pointerType==="touch"?fA(m):Y(m))}function j(m){switch(cA(m),y.length){case 0:t.domElement.releasePointerCapture(m.pointerId),t.domElement.removeEventListener("pointermove",M),t.domElement.removeEventListener("pointerup",j),t.dispatchEvent(pa),s=n.NONE;break;case 1:const B=y[0],U=F[B];nA({pointerId:B,pageX:U.x,pageY:U.y});break}}function Z(m){let B;switch(m.button){case 0:B=t.mouseButtons.LEFT;break;case 1:B=t.mouseButtons.MIDDLE;break;case 2:B=t.mouseButtons.RIGHT;break;default:B=-1}switch(B){case qt.DOLLY:if(t.enableZoom===!1)return;LA(m),s=n.DOLLY;break;case qt.ROTATE:if(m.ctrlKey||m.metaKey||m.shiftKey){if(t.enablePan===!1)return;ZA(m),s=n.PAN}else{if(t.enableRotate===!1)return;uA(m),s=n.ROTATE}break;case qt.PAN:if(m.ctrlKey||m.metaKey||m.shiftKey){if(t.enableRotate===!1)return;uA(m),s=n.ROTATE}else{if(t.enablePan===!1)return;ZA(m),s=n.PAN}break;default:s=n.NONE}s!==n.NONE&&t.dispatchEvent(ks)}function Y(m){switch(s){case n.ROTATE:if(t.enableRotate===!1)return;k(m);break;case n.DOLLY:if(t.enableZoom===!1)return;eA(m);break;case n.PAN:if(t.enablePan===!1)return;lA(m);break}}function J(m){t.enabled===!1||t.enableZoom===!1||s!==n.NONE||(m.preventDefault(),t.dispatchEvent(ks),iA(pA(m)),t.dispatchEvent(pa))}function pA(m){const B=m.deltaMode,U={clientX:m.clientX,clientY:m.clientY,deltaY:m.deltaY};switch(B){case 1:U.deltaY*=16;break;case 2:U.deltaY*=100;break}return m.ctrlKey&&!v&&(U.deltaY*=10),U}function oA(m){m.key==="Control"&&(v=!0,t.domElement.getRootNode().addEventListener("keyup",rA,{passive:!0,capture:!0}))}function rA(m){m.key==="Control"&&(v=!1,t.domElement.getRootNode().removeEventListener("keyup",rA,{passive:!0,capture:!0}))}function IA(m){t.enabled===!1||t.enablePan===!1||OA(m)}function nA(m){switch(_A(m),y.length){case 1:switch(t.touches.ONE){case $t.ROTATE:if(t.enableRotate===!1)return;zA(m),s=n.TOUCH_ROTATE;break;case $t.PAN:if(t.enablePan===!1)return;_(m),s=n.TOUCH_PAN;break;default:s=n.NONE}break;case 2:switch(t.touches.TWO){case $t.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;gA(m),s=n.TOUCH_DOLLY_PAN;break;case $t.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;JA(m),s=n.TOUCH_DOLLY_ROTATE;break;default:s=n.NONE}break;default:s=n.NONE}s!==n.NONE&&t.dispatchEvent(ks)}function fA(m){switch(_A(m),s){case n.TOUCH_ROTATE:if(t.enableRotate===!1)return;CA(m),t.update();break;case n.TOUCH_PAN:if(t.enablePan===!1)return;FA(m),t.update();break;case n.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;jA(m),t.update();break;case n.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;ee(m),t.update();break;default:s=n.NONE}}function HA(m){t.enabled!==!1&&m.preventDefault()}function mA(m){y.push(m.pointerId)}function cA(m){delete F[m.pointerId];for(let B=0;B<y.length;B++)if(y[B]==m.pointerId){y.splice(B,1);return}}function TA(m){for(let B=0;B<y.length;B++)if(y[B]==m.pointerId)return!0;return!1}function _A(m){let B=F[m.pointerId];B===void 0&&(B=new MA,F[m.pointerId]=B),B.set(m.pageX,m.pageY)}function KA(m){const B=m.pointerId===y[0]?y[1]:y[0];return F[B]}t.domElement.addEventListener("contextmenu",HA),t.domElement.addEventListener("pointerdown",T),t.domElement.addEventListener("pointercancel",j),t.domElement.addEventListener("wheel",J,{passive:!1}),t.domElement.getRootNode().addEventListener("keydown",oA,{passive:!0,capture:!0}),this.update()}}function ma(i,A){if(A===Cl)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),i;if(A===Ks||A===Na){let e=i.getIndex();if(e===null){const r=[],o=i.getAttribute("position");if(o!==void 0){for(let a=0;a<o.count;a++)r.push(a);i.setIndex(r),e=i.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),i}const t=e.count-2,n=[];if(A===Ks)for(let r=1;r<=t;r++)n.push(e.getX(0)),n.push(e.getX(r)),n.push(e.getX(r+1));else for(let r=0;r<t;r++)r%2===0?(n.push(e.getX(r)),n.push(e.getX(r+1)),n.push(e.getX(r+2))):(n.push(e.getX(r+2)),n.push(e.getX(r+1)),n.push(e.getX(r)));n.length/3!==t&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=i.clone();return s.setIndex(n),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",A),i}class Gg extends On{constructor(A){super(A),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new Jg(e)}),this.register(function(e){return new Kg(e)}),this.register(function(e){return new rm(e)}),this.register(function(e){return new om(e)}),this.register(function(e){return new am(e)}),this.register(function(e){return new $g(e)}),this.register(function(e){return new Am(e)}),this.register(function(e){return new em(e)}),this.register(function(e){return new tm(e)}),this.register(function(e){return new Yg(e)}),this.register(function(e){return new nm(e)}),this.register(function(e){return new qg(e)}),this.register(function(e){return new sm(e)}),this.register(function(e){return new im(e)}),this.register(function(e){return new Zg(e)}),this.register(function(e){return new cm(e)}),this.register(function(e){return new lm(e)})}load(A,e,t,n){const s=this;let r;if(this.resourcePath!=="")r=this.resourcePath;else if(this.path!==""){const c=ei.extractUrlBase(A);r=ei.resolveURL(c,this.path)}else r=ei.extractUrlBase(A);this.manager.itemStart(A);const o=function(c){n?n(c):console.error(c),s.manager.itemError(A),s.manager.itemEnd(A)},a=new lc(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(A,function(c){try{s.parse(c,r,function(l){e(l),s.manager.itemEnd(A)},o)}catch(l){o(l)}},t,o)}setDRACOLoader(A){return this.dracoLoader=A,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(A){return this.ktx2Loader=A,this}setMeshoptDecoder(A){return this.meshoptDecoder=A,this}register(A){return this.pluginCallbacks.indexOf(A)===-1&&this.pluginCallbacks.push(A),this}unregister(A){return this.pluginCallbacks.indexOf(A)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(A),1),this}parse(A,e,t,n){let s;const r={},o={},a=new TextDecoder;if(typeof A=="string")s=JSON.parse(A);else if(A instanceof ArrayBuffer)if(a.decode(new Uint8Array(A,0,4))===dc){try{r[QA.KHR_BINARY_GLTF]=new hm(A)}catch(h){n&&n(h);return}s=JSON.parse(r[QA.KHR_BINARY_GLTF].content)}else s=JSON.parse(a.decode(A));else s=A;if(s.asset===void 0||s.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Em(s,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let l=0;l<this.pluginCallbacks.length;l++){const h=this.pluginCallbacks[l](c);h.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[h.name]=h,r[h.name]=!0}if(s.extensionsUsed)for(let l=0;l<s.extensionsUsed.length;++l){const h=s.extensionsUsed[l],u=s.extensionsRequired||[];switch(h){case QA.KHR_MATERIALS_UNLIT:r[h]=new Xg;break;case QA.KHR_DRACO_MESH_COMPRESSION:r[h]=new um(s,this.dracoLoader);break;case QA.KHR_TEXTURE_TRANSFORM:r[h]=new dm;break;case QA.KHR_MESH_QUANTIZATION:r[h]=new fm;break;default:u.indexOf(h)>=0&&o[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}c.setExtensions(r),c.setPlugins(o),c.parse(t,n)}parseAsync(A,e){const t=this;return new Promise(function(n,s){t.parse(A,e,n,s)})}}function Wg(){let i={};return{get:function(A){return i[A]},add:function(A,e){i[A]=e},remove:function(A){delete i[A]},removeAll:function(){i={}}}}const QA={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Zg{constructor(A){this.parser=A,this.name=QA.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const A=this.parser,e=this.parser.json.nodes||[];for(let t=0,n=e.length;t<n;t++){const s=e[t];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&A._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(A){const e=this.parser,t="light:"+A;let n=e.cache.get(t);if(n)return n;const s=e.json,a=((s.extensions&&s.extensions[this.name]||{}).lights||[])[A];let c;const l=new wA(16777215);a.color!==void 0&&l.setRGB(a.color[0],a.color[1],a.color[2],fe);const h=a.range!==void 0?a.range:0;switch(a.type){case"directional":c=new uc(l),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new xg(l),c.distance=h;break;case"spot":c=new vg(l),c.distance=h,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,c.angle=a.spot.outerConeAngle,c.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return c.position.set(0,0,0),c.decay=2,xt(c,a),a.intensity!==void 0&&(c.intensity=a.intensity),c.name=e.createUniqueName(a.name||"light_"+A),n=Promise.resolve(c),e.cache.add(t,n),n}getDependency(A,e){if(A==="light")return this._loadLight(e)}createNodeAttachment(A){const e=this,t=this.parser,s=t.json.nodes[A],o=(s.extensions&&s.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(a){return t._getNodeRef(e.cache,o,a)})}}class Xg{constructor(){this.name=QA.KHR_MATERIALS_UNLIT}getMaterialType(){return Wt}extendParams(A,e,t){const n=[];A.color=new wA(1,1,1),A.opacity=1;const s=e.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const r=s.baseColorFactor;A.color.setRGB(r[0],r[1],r[2],fe),A.opacity=r[3]}s.baseColorTexture!==void 0&&n.push(t.assignTexture(A,"map",s.baseColorTexture,Me))}return Promise.all(n)}}class Yg{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(A,e){const n=this.parser.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=n.extensions[this.name].emissiveStrength;return s!==void 0&&(e.emissiveIntensity=s),Promise.resolve()}}class Jg{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_CLEARCOAT}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];if(r.clearcoatFactor!==void 0&&(e.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&s.push(t.assignTexture(e,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(e.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&s.push(t.assignTexture(e,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(s.push(t.assignTexture(e,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const o=r.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new MA(o,o)}return Promise.all(s)}}class Kg{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_DISPERSION}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const n=this.parser.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=n.extensions[this.name];return e.dispersion=s.dispersion!==void 0?s.dispersion:0,Promise.resolve()}}class qg{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_IRIDESCENCE}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];return r.iridescenceFactor!==void 0&&(e.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&s.push(t.assignTexture(e,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(e.iridescenceIOR=r.iridescenceIor),e.iridescenceThicknessRange===void 0&&(e.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(e.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(e.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&s.push(t.assignTexture(e,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(s)}}class $g{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_SHEEN}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[];e.sheenColor=new wA(0,0,0),e.sheenRoughness=0,e.sheen=1;const r=n.extensions[this.name];if(r.sheenColorFactor!==void 0){const o=r.sheenColorFactor;e.sheenColor.setRGB(o[0],o[1],o[2],fe)}return r.sheenRoughnessFactor!==void 0&&(e.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&s.push(t.assignTexture(e,"sheenColorMap",r.sheenColorTexture,Me)),r.sheenRoughnessTexture!==void 0&&s.push(t.assignTexture(e,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(s)}}class Am{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_TRANSMISSION}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];return r.transmissionFactor!==void 0&&(e.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&s.push(t.assignTexture(e,"transmissionMap",r.transmissionTexture)),Promise.all(s)}}class em{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_VOLUME}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];e.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&s.push(t.assignTexture(e,"thicknessMap",r.thicknessTexture)),e.attenuationDistance=r.attenuationDistance||1/0;const o=r.attenuationColor||[1,1,1];return e.attenuationColor=new wA().setRGB(o[0],o[1],o[2],fe),Promise.all(s)}}class tm{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_IOR}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const n=this.parser.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=n.extensions[this.name];return e.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class nm{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_SPECULAR}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];e.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&s.push(t.assignTexture(e,"specularIntensityMap",r.specularTexture));const o=r.specularColorFactor||[1,1,1];return e.specularColor=new wA().setRGB(o[0],o[1],o[2],fe),r.specularColorTexture!==void 0&&s.push(t.assignTexture(e,"specularColorMap",r.specularColorTexture,Me)),Promise.all(s)}}class im{constructor(A){this.parser=A,this.name=QA.EXT_MATERIALS_BUMP}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];return e.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1,r.bumpTexture!==void 0&&s.push(t.assignTexture(e,"bumpMap",r.bumpTexture)),Promise.all(s)}}class sm{constructor(A){this.parser=A,this.name=QA.KHR_MATERIALS_ANISOTROPY}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:qe}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];return r.anisotropyStrength!==void 0&&(e.anisotropy=r.anisotropyStrength),r.anisotropyRotation!==void 0&&(e.anisotropyRotation=r.anisotropyRotation),r.anisotropyTexture!==void 0&&s.push(t.assignTexture(e,"anisotropyMap",r.anisotropyTexture)),Promise.all(s)}}class rm{constructor(A){this.parser=A,this.name=QA.KHR_TEXTURE_BASISU}loadTexture(A){const e=this.parser,t=e.json,n=t.textures[A];if(!n.extensions||!n.extensions[this.name])return null;const s=n.extensions[this.name],r=e.options.ktx2Loader;if(!r){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(A,s.source,r)}}class om{constructor(A){this.parser=A,this.name=QA.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(A){const e=this.name,t=this.parser,n=t.json,s=n.textures[A];if(!s.extensions||!s.extensions[e])return null;const r=s.extensions[e],o=n.images[r.source];let a=t.textureLoader;if(o.uri){const c=t.options.manager.getHandler(o.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return t.loadTextureImage(A,r.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return t.loadTexture(A)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(A){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){A(e.height===1)}})),this.isSupported}}class am{constructor(A){this.parser=A,this.name=QA.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(A){const e=this.name,t=this.parser,n=t.json,s=n.textures[A];if(!s.extensions||!s.extensions[e])return null;const r=s.extensions[e],o=n.images[r.source];let a=t.textureLoader;if(o.uri){const c=t.options.manager.getHandler(o.uri);c!==null&&(a=c)}return this.detectSupport().then(function(c){if(c)return t.loadTextureImage(A,r.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return t.loadTexture(A)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(A){const e=new Image;e.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",e.onload=e.onerror=function(){A(e.height===1)}})),this.isSupported}}class cm{constructor(A){this.name=QA.EXT_MESHOPT_COMPRESSION,this.parser=A}loadBufferView(A){const e=this.parser.json,t=e.bufferViews[A];if(t.extensions&&t.extensions[this.name]){const n=t.extensions[this.name],s=this.parser.getDependency("buffer",n.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(o){const a=n.byteOffset||0,c=n.byteLength||0,l=n.count,h=n.byteStride,u=new Uint8Array(o,a,c);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(l,h,u,n.mode,n.filter).then(function(d){return d.buffer}):r.ready.then(function(){const d=new ArrayBuffer(l*h);return r.decodeGltfBuffer(new Uint8Array(d),l,h,u,n.mode,n.filter),d})})}else return null}}class lm{constructor(A){this.name=QA.EXT_MESH_GPU_INSTANCING,this.parser=A}createNodeMesh(A){const e=this.parser.json,t=e.nodes[A];if(!t.extensions||!t.extensions[this.name]||t.mesh===void 0)return null;const n=e.meshes[t.mesh];for(const c of n.primitives)if(c.mode!==Ue.TRIANGLES&&c.mode!==Ue.TRIANGLE_STRIP&&c.mode!==Ue.TRIANGLE_FAN&&c.mode!==void 0)return null;const r=t.extensions[this.name].attributes,o=[],a={};for(const c in r)o.push(this.parser.getDependency("accessor",r[c]).then(l=>(a[c]=l,a[c])));return o.length<1?null:(o.push(this.parser.createNodeMesh(A)),Promise.all(o).then(c=>{const l=c.pop(),h=l.isGroup?l.children:[l],u=c[0].count,d=[];for(const g of h){const C=new RA,p=new S,f=new Be,E=new S(1,1,1),I=new rg(g.geometry,g.material,u);for(let x=0;x<u;x++)a.TRANSLATION&&p.fromBufferAttribute(a.TRANSLATION,x),a.ROTATION&&f.fromBufferAttribute(a.ROTATION,x),a.SCALE&&E.fromBufferAttribute(a.SCALE,x),I.setMatrixAt(x,C.compose(p,f,E));for(const x in a)if(x==="_COLOR_0"){const z=a[x];I.instanceColor=new Ar(z.array,z.itemSize,z.normalized)}else x!=="TRANSLATION"&&x!=="ROTATION"&&x!=="SCALE"&&g.geometry.setAttribute(x,a[x]);ie.prototype.copy.call(I,g),this.parser.assignFinalMaterial(I),d.push(I)}return l.isGroup?(l.clear(),l.add(...d),l):d[0]}))}}const dc="glTF",Jn=12,Ca={JSON:1313821514,BIN:5130562};class hm{constructor(A){this.name=QA.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(A,0,Jn),t=new TextDecoder;if(this.header={magic:t.decode(new Uint8Array(A.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==dc)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Jn,s=new DataView(A,Jn);let r=0;for(;r<n;){const o=s.getUint32(r,!0);r+=4;const a=s.getUint32(r,!0);if(r+=4,a===Ca.JSON){const c=new Uint8Array(A,Jn+r,o);this.content=t.decode(c)}else if(a===Ca.BIN){const c=Jn+r;this.body=A.slice(c,c+o)}r+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class um{constructor(A,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=QA.KHR_DRACO_MESH_COMPRESSION,this.json=A,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(A,e){const t=this.json,n=this.dracoLoader,s=A.extensions[this.name].bufferView,r=A.extensions[this.name].attributes,o={},a={},c={};for(const l in r){const h=nr[l]||l.toLowerCase();o[h]=r[l]}for(const l in A.attributes){const h=nr[l]||l.toLowerCase();if(r[l]!==void 0){const u=t.accessors[A.attributes[l]],d=xn[u.componentType];c[h]=d.name,a[h]=u.normalized===!0}}return e.getDependency("bufferView",s).then(function(l){return new Promise(function(h,u){n.decodeDracoFile(l,function(d){for(const g in d.attributes){const C=d.attributes[g],p=a[g];p!==void 0&&(C.normalized=p)}h(d)},o,c,fe,u)})})}}class dm{constructor(){this.name=QA.KHR_TEXTURE_TRANSFORM}extendTexture(A,e){return(e.texCoord===void 0||e.texCoord===A.channel)&&e.offset===void 0&&e.rotation===void 0&&e.scale===void 0||(A=A.clone(),e.texCoord!==void 0&&(A.channel=e.texCoord),e.offset!==void 0&&A.offset.fromArray(e.offset),e.rotation!==void 0&&(A.rotation=e.rotation),e.scale!==void 0&&A.repeat.fromArray(e.scale),A.needsUpdate=!0),A}}class fm{constructor(){this.name=QA.KHR_MESH_QUANTIZATION}}class fc extends ci{constructor(A,e,t,n){super(A,e,t,n)}copySampleValue_(A){const e=this.resultBuffer,t=this.sampleValues,n=this.valueSize,s=A*n*3+n;for(let r=0;r!==n;r++)e[r]=t[s+r];return e}interpolate_(A,e,t,n){const s=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=o*2,c=o*3,l=n-e,h=(t-e)/l,u=h*h,d=u*h,g=A*c,C=g-c,p=-2*d+3*u,f=d-u,E=1-p,I=f-u+h;for(let x=0;x!==o;x++){const z=r[C+x+o],D=r[C+x+a]*l,y=r[g+x+o],F=r[g+x]*l;s[x]=E*z+I*D+p*y+f*F}return s}}const pm=new Be;class gm extends fc{interpolate_(A,e,t,n){const s=super.interpolate_(A,e,t,n);return pm.fromArray(s).normalize().toArray(s),s}}const Ue={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},xn={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Ma={9728:ve,9729:be,9984:ya,9985:Qi,9986:Kn,9987:ct},Pa={33071:yt,33648:ki,10497:Dn},Vs={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},nr={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},vt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},mm={CUBICSPLINE:void 0,LINEAR:bn,STEP:ni},Gs={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Cm(i){return i.DefaultMaterial===void 0&&(i.DefaultMaterial=new ts({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ht})),i.DefaultMaterial}function Ht(i,A,e){for(const t in e.extensions)i[t]===void 0&&(A.userData.gltfExtensions=A.userData.gltfExtensions||{},A.userData.gltfExtensions[t]=e.extensions[t])}function xt(i,A){A.extras!==void 0&&(typeof A.extras=="object"?Object.assign(i.userData,A.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+A.extras))}function Mm(i,A,e){let t=!1,n=!1,s=!1;for(let c=0,l=A.length;c<l;c++){const h=A[c];if(h.POSITION!==void 0&&(t=!0),h.NORMAL!==void 0&&(n=!0),h.COLOR_0!==void 0&&(s=!0),t&&n&&s)break}if(!t&&!n&&!s)return Promise.resolve(i);const r=[],o=[],a=[];for(let c=0,l=A.length;c<l;c++){const h=A[c];if(t){const u=h.POSITION!==void 0?e.getDependency("accessor",h.POSITION):i.attributes.position;r.push(u)}if(n){const u=h.NORMAL!==void 0?e.getDependency("accessor",h.NORMAL):i.attributes.normal;o.push(u)}if(s){const u=h.COLOR_0!==void 0?e.getDependency("accessor",h.COLOR_0):i.attributes.color;a.push(u)}}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(a)]).then(function(c){const l=c[0],h=c[1],u=c[2];return t&&(i.morphAttributes.position=l),n&&(i.morphAttributes.normal=h),s&&(i.morphAttributes.color=u),i.morphTargetsRelative=!0,i})}function Pm(i,A){if(i.updateMorphTargets(),A.weights!==void 0)for(let e=0,t=A.weights.length;e<t;e++)i.morphTargetInfluences[e]=A.weights[e];if(A.extras&&Array.isArray(A.extras.targetNames)){const e=A.extras.targetNames;if(i.morphTargetInfluences.length===e.length){i.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++)i.morphTargetDictionary[e[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function wm(i){let A;const e=i.extensions&&i.extensions[QA.KHR_DRACO_MESH_COMPRESSION];if(e?A="draco:"+e.bufferView+":"+e.indices+":"+Ws(e.attributes):A=i.indices+":"+Ws(i.attributes)+":"+i.mode,i.targets!==void 0)for(let t=0,n=i.targets.length;t<n;t++)A+=":"+Ws(i.targets[t]);return A}function Ws(i){let A="";const e=Object.keys(i).sort();for(let t=0,n=e.length;t<n;t++)A+=e[t]+":"+i[e[t]]+";";return A}function ir(i){switch(i){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Im(i){return i.search(/\.jpe?g($|\?)/i)>0||i.search(/^data\:image\/jpeg/)===0?"image/jpeg":i.search(/\.webp($|\?)/i)>0||i.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const vm=new RA;class Em{constructor(A={},e={}){this.json=A,this.extensions={},this.plugins={},this.options=e,this.cache=new Wg,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let t=!1,n=!1,s=-1;typeof navigator<"u"&&(t=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,s=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||t||n&&s<98?this.textureLoader=new hc(this.options.manager):this.textureLoader=new Dg(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new lc(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(A){this.extensions=A}setPlugins(A){this.plugins=A}parse(A,e){const t=this,n=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([t.getDependencies("scene"),t.getDependencies("animation"),t.getDependencies("camera")])}).then(function(r){const o={scene:r[0][n.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:n.asset,parser:t,userData:{}};return Ht(s,o,n),xt(o,n),Promise.all(t._invokeAll(function(a){return a.afterRoot&&a.afterRoot(o)})).then(function(){for(const a of o.scenes)a.updateMatrixWorld();A(o)})}).catch(e)}_markDefs(){const A=this.json.nodes||[],e=this.json.skins||[],t=this.json.meshes||[];for(let n=0,s=e.length;n<s;n++){const r=e[n].joints;for(let o=0,a=r.length;o<a;o++)A[r[o]].isBone=!0}for(let n=0,s=A.length;n<s;n++){const r=A[n];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(t[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(A,e){e!==void 0&&(A.refs[e]===void 0&&(A.refs[e]=A.uses[e]=0),A.refs[e]++)}_getNodeRef(A,e,t){if(A.refs[e]<=1)return t;const n=t.clone(),s=(r,o)=>{const a=this.associations.get(r);a!=null&&this.associations.set(o,a);for(const[c,l]of r.children.entries())s(l,o.children[c])};return s(t,n),n.name+="_instance_"+A.uses[e]++,n}_invokeOne(A){const e=Object.values(this.plugins);e.push(this);for(let t=0;t<e.length;t++){const n=A(e[t]);if(n)return n}return null}_invokeAll(A){const e=Object.values(this.plugins);e.unshift(this);const t=[];for(let n=0;n<e.length;n++){const s=A(e[n]);s&&t.push(s)}return t}getDependency(A,e){const t=A+":"+e;let n=this.cache.get(t);if(!n){switch(A){case"scene":n=this.loadScene(e);break;case"node":n=this._invokeOne(function(s){return s.loadNode&&s.loadNode(e)});break;case"mesh":n=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(e)});break;case"accessor":n=this.loadAccessor(e);break;case"bufferView":n=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(e)});break;case"buffer":n=this.loadBuffer(e);break;case"material":n=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(e)});break;case"texture":n=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(e)});break;case"skin":n=this.loadSkin(e);break;case"animation":n=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(e)});break;case"camera":n=this.loadCamera(e);break;default:if(n=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(A,e)}),!n)throw new Error("Unknown type: "+A);break}this.cache.add(t,n)}return n}getDependencies(A){let e=this.cache.get(A);if(!e){const t=this,n=this.json[A+(A==="mesh"?"es":"s")]||[];e=Promise.all(n.map(function(s,r){return t.getDependency(A,r)})),this.cache.add(A,e)}return e}loadBuffer(A){const e=this.json.buffers[A],t=this.fileLoader;if(e.type&&e.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(e.uri===void 0&&A===0)return Promise.resolve(this.extensions[QA.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(s,r){t.load(ei.resolveURL(e.uri,n.path),s,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))})})}loadBufferView(A){const e=this.json.bufferViews[A];return this.getDependency("buffer",e.buffer).then(function(t){const n=e.byteLength||0,s=e.byteOffset||0;return t.slice(s,s+n)})}loadAccessor(A){const e=this,t=this.json,n=this.json.accessors[A];if(n.bufferView===void 0&&n.sparse===void 0){const r=Vs[n.type],o=xn[n.componentType],a=n.normalized===!0,c=new o(n.count*r);return Promise.resolve(new xe(c,r,a))}const s=[];return n.bufferView!==void 0?s.push(this.getDependency("bufferView",n.bufferView)):s.push(null),n.sparse!==void 0&&(s.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(s).then(function(r){const o=r[0],a=Vs[n.type],c=xn[n.componentType],l=c.BYTES_PER_ELEMENT,h=l*a,u=n.byteOffset||0,d=n.bufferView!==void 0?t.bufferViews[n.bufferView].byteStride:void 0,g=n.normalized===!0;let C,p;if(d&&d!==h){const f=Math.floor(u/d),E="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+f+":"+n.count;let I=e.cache.get(E);I||(C=new c(o,f*d,n.count*d/l),I=new eg(C,d/l),e.cache.add(E,I)),p=new dr(I,a,u%d/l,g)}else o===null?C=new c(n.count*a):C=new c(o,u,n.count*a),p=new xe(C,a,g);if(n.sparse!==void 0){const f=Vs.SCALAR,E=xn[n.sparse.indices.componentType],I=n.sparse.indices.byteOffset||0,x=n.sparse.values.byteOffset||0,z=new E(r[1],I,n.sparse.count*f),D=new c(r[2],x,n.sparse.count*a);o!==null&&(p=new xe(p.array.slice(),p.itemSize,p.normalized));for(let y=0,F=z.length;y<F;y++){const v=z[y];if(p.setX(v,D[y*a]),a>=2&&p.setY(v,D[y*a+1]),a>=3&&p.setZ(v,D[y*a+2]),a>=4&&p.setW(v,D[y*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return p})}loadTexture(A){const e=this.json,t=this.options,s=e.textures[A].source,r=e.images[s];let o=this.textureLoader;if(r.uri){const a=t.manager.getHandler(r.uri);a!==null&&(o=a)}return this.loadTextureImage(A,s,o)}loadTextureImage(A,e,t){const n=this,s=this.json,r=s.textures[A],o=s.images[e],a=(o.uri||o.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(e,t).then(function(l){l.flipY=!1,l.name=r.name||o.name||"",l.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(l.name=o.uri);const u=(s.samplers||{})[r.sampler]||{};return l.magFilter=Ma[u.magFilter]||be,l.minFilter=Ma[u.minFilter]||ct,l.wrapS=Pa[u.wrapS]||Dn,l.wrapT=Pa[u.wrapT]||Dn,n.associations.set(l,{textures:A}),l}).catch(function(){return null});return this.textureCache[a]=c,c}loadImageSource(A,e){const t=this,n=this.json,s=this.options;if(this.sourceCache[A]!==void 0)return this.sourceCache[A].then(h=>h.clone());const r=n.images[A],o=self.URL||self.webkitURL;let a=r.uri||"",c=!1;if(r.bufferView!==void 0)a=t.getDependency("bufferView",r.bufferView).then(function(h){c=!0;const u=new Blob([h],{type:r.mimeType});return a=o.createObjectURL(u),a});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+A+" is missing URI and bufferView");const l=Promise.resolve(a).then(function(h){return new Promise(function(u,d){let g=u;e.isImageBitmapLoader===!0&&(g=function(C){const p=new ue(C);p.needsUpdate=!0,u(p)}),e.load(ei.resolveURL(h,s.path),g,void 0,d)})}).then(function(h){return c===!0&&o.revokeObjectURL(a),h.userData.mimeType=r.mimeType||Im(r.uri),h}).catch(function(h){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),h});return this.sourceCache[A]=l,l}assignTexture(A,e,t,n){const s=this;return this.getDependency("texture",t.index).then(function(r){if(!r)return null;if(t.texCoord!==void 0&&t.texCoord>0&&(r=r.clone(),r.channel=t.texCoord),s.extensions[QA.KHR_TEXTURE_TRANSFORM]){const o=t.extensions!==void 0?t.extensions[QA.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const a=s.associations.get(r);r=s.extensions[QA.KHR_TEXTURE_TRANSFORM].extendTexture(r,o),s.associations.set(r,a)}}return n!==void 0&&(r.colorSpace=n),A[e]=r,r})}assignFinalMaterial(A){const e=A.geometry;let t=A.material;const n=e.attributes.tangent===void 0,s=e.attributes.color!==void 0,r=e.attributes.normal===void 0;if(A.isPoints){const o="PointsMaterial:"+t.uuid;let a=this.cache.get(o);a||(a=new rc,ke.prototype.copy.call(a,t),a.color.copy(t.color),a.map=t.map,a.sizeAttenuation=!1,this.cache.add(o,a)),t=a}else if(A.isLine){const o="LineBasicMaterial:"+t.uuid;let a=this.cache.get(o);a||(a=new sc,ke.prototype.copy.call(a,t),a.color.copy(t.color),a.map=t.map,this.cache.add(o,a)),t=a}if(n||s||r){let o="ClonedMaterial:"+t.uuid+":";n&&(o+="derivative-tangents:"),s&&(o+="vertex-colors:"),r&&(o+="flat-shading:");let a=this.cache.get(o);a||(a=t.clone(),s&&(a.vertexColors=!0),r&&(a.flatShading=!0),n&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(o,a),this.associations.set(a,this.associations.get(t))),t=a}A.material=t}getMaterialType(){return ts}loadMaterial(A){const e=this,t=this.json,n=this.extensions,s=t.materials[A];let r;const o={},a=s.extensions||{},c=[];if(a[QA.KHR_MATERIALS_UNLIT]){const h=n[QA.KHR_MATERIALS_UNLIT];r=h.getMaterialType(),c.push(h.extendParams(o,s,e))}else{const h=s.pbrMetallicRoughness||{};if(o.color=new wA(1,1,1),o.opacity=1,Array.isArray(h.baseColorFactor)){const u=h.baseColorFactor;o.color.setRGB(u[0],u[1],u[2],fe),o.opacity=u[3]}h.baseColorTexture!==void 0&&c.push(e.assignTexture(o,"map",h.baseColorTexture,Me)),o.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,o.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(c.push(e.assignTexture(o,"metalnessMap",h.metallicRoughnessTexture)),c.push(e.assignTexture(o,"roughnessMap",h.metallicRoughnessTexture))),r=this._invokeOne(function(u){return u.getMaterialType&&u.getMaterialType(A)}),c.push(Promise.all(this._invokeAll(function(u){return u.extendMaterialParams&&u.extendMaterialParams(A,o)})))}s.doubleSided===!0&&(o.side=Ze);const l=s.alphaMode||Gs.OPAQUE;if(l===Gs.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,l===Gs.MASK&&(o.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&r!==Wt&&(c.push(e.assignTexture(o,"normalMap",s.normalTexture)),o.normalScale=new MA(1,1),s.normalTexture.scale!==void 0)){const h=s.normalTexture.scale;o.normalScale.set(h,h)}if(s.occlusionTexture!==void 0&&r!==Wt&&(c.push(e.assignTexture(o,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&r!==Wt){const h=s.emissiveFactor;o.emissive=new wA().setRGB(h[0],h[1],h[2],fe)}return s.emissiveTexture!==void 0&&r!==Wt&&c.push(e.assignTexture(o,"emissiveMap",s.emissiveTexture,Me)),Promise.all(c).then(function(){const h=new r(o);return s.name&&(h.name=s.name),xt(h,s),e.associations.set(h,{materials:A}),s.extensions&&Ht(n,h,s),h})}createUniqueName(A){const e=GA.sanitizeNodeName(A||"");return e in this.nodeNamesUsed?e+"_"+ ++this.nodeNamesUsed[e]:(this.nodeNamesUsed[e]=0,e)}loadGeometries(A){const e=this,t=this.extensions,n=this.primitiveCache;function s(o){return t[QA.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,e).then(function(a){return wa(a,o,e)})}const r=[];for(let o=0,a=A.length;o<a;o++){const c=A[o],l=wm(c),h=n[l];if(h)r.push(h.promise);else{let u;c.extensions&&c.extensions[QA.KHR_DRACO_MESH_COMPRESSION]?u=s(c):u=wa(new Ve,c,e),n[l]={primitive:c,promise:u},r.push(u)}}return Promise.all(r)}loadMesh(A){const e=this,t=this.json,n=this.extensions,s=t.meshes[A],r=s.primitives,o=[];for(let a=0,c=r.length;a<c;a++){const l=r[a].material===void 0?Cm(this.cache):this.getDependency("material",r[a].material);o.push(l)}return o.push(e.loadGeometries(r)),Promise.all(o).then(function(a){const c=a.slice(0,a.length-1),l=a[a.length-1],h=[];for(let d=0,g=l.length;d<g;d++){const C=l[d],p=r[d];let f;const E=c[d];if(p.mode===Ue.TRIANGLES||p.mode===Ue.TRIANGLE_STRIP||p.mode===Ue.TRIANGLE_FAN||p.mode===void 0)f=s.isSkinnedMesh===!0?new ng(C,E):new Ee(C,E),f.isSkinnedMesh===!0&&f.normalizeSkinWeights(),p.mode===Ue.TRIANGLE_STRIP?f.geometry=ma(f.geometry,Na):p.mode===Ue.TRIANGLE_FAN&&(f.geometry=ma(f.geometry,Ks));else if(p.mode===Ue.LINES)f=new og(C,E);else if(p.mode===Ue.LINE_STRIP)f=new pr(C,E);else if(p.mode===Ue.LINE_LOOP)f=new ag(C,E);else if(p.mode===Ue.POINTS)f=new cg(C,E);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+p.mode);Object.keys(f.geometry.morphAttributes).length>0&&Pm(f,s),f.name=e.createUniqueName(s.name||"mesh_"+A),xt(f,s),p.extensions&&Ht(n,f,p),e.assignFinalMaterial(f),h.push(f)}for(let d=0,g=h.length;d<g;d++)e.associations.set(h[d],{meshes:A,primitives:d});if(h.length===1)return s.extensions&&Ht(n,h[0],s),h[0];const u=new Zt;s.extensions&&Ht(n,u,s),e.associations.set(u,{meshes:A});for(let d=0,g=h.length;d<g;d++)u.add(h[d]);return u})}loadCamera(A){let e;const t=this.json.cameras[A],n=t[t.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return t.type==="perspective"?e=new Ie(Oa.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):t.type==="orthographic"&&(e=new hr(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),t.name&&(e.name=this.createUniqueName(t.name)),xt(e,t),Promise.resolve(e)}loadSkin(A){const e=this.json.skins[A],t=[];for(let n=0,s=e.joints.length;n<s;n++)t.push(this._loadNodeShallow(e.joints[n]));return e.inverseBindMatrices!==void 0?t.push(this.getDependency("accessor",e.inverseBindMatrices)):t.push(null),Promise.all(t).then(function(n){const s=n.pop(),r=n,o=[],a=[];for(let c=0,l=r.length;c<l;c++){const h=r[c];if(h){o.push(h);const u=new RA;s!==null&&u.fromArray(s.array,c*16),a.push(u)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',e.joints[c])}return new fr(o,a)})}loadAnimation(A){const e=this.json,t=this,n=e.animations[A],s=n.name?n.name:"animation_"+A,r=[],o=[],a=[],c=[],l=[];for(let h=0,u=n.channels.length;h<u;h++){const d=n.channels[h],g=n.samplers[d.sampler],C=d.target,p=C.node,f=n.parameters!==void 0?n.parameters[g.input]:g.input,E=n.parameters!==void 0?n.parameters[g.output]:g.output;C.node!==void 0&&(r.push(this.getDependency("node",p)),o.push(this.getDependency("accessor",f)),a.push(this.getDependency("accessor",E)),c.push(g),l.push(C))}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(a),Promise.all(c),Promise.all(l)]).then(function(h){const u=h[0],d=h[1],g=h[2],C=h[3],p=h[4],f=[];for(let E=0,I=u.length;E<I;E++){const x=u[E],z=d[E],D=g[E],y=C[E],F=p[E];if(x===void 0)continue;x.updateMatrix&&x.updateMatrix();const v=t._createAnimationTracks(x,z,D,y,F);if(v)for(let P=0;P<v.length;P++)f.push(v[P])}return new tr(s,void 0,f)})}createNodeMesh(A){const e=this.json,t=this,n=e.nodes[A];return n.mesh===void 0?null:t.getDependency("mesh",n.mesh).then(function(s){const r=t._getNodeRef(t.meshCache,n.mesh,s);return n.weights!==void 0&&r.traverse(function(o){if(o.isMesh)for(let a=0,c=n.weights.length;a<c;a++)o.morphTargetInfluences[a]=n.weights[a]}),r})}loadNode(A){const e=this.json,t=this,n=e.nodes[A],s=t._loadNodeShallow(A),r=[],o=n.children||[];for(let c=0,l=o.length;c<l;c++)r.push(t.getDependency("node",o[c]));const a=n.skin===void 0?Promise.resolve(null):t.getDependency("skin",n.skin);return Promise.all([s,Promise.all(r),a]).then(function(c){const l=c[0],h=c[1],u=c[2];u!==null&&l.traverse(function(d){d.isSkinnedMesh&&d.bind(u,vm)});for(let d=0,g=h.length;d<g;d++)l.add(h[d]);return l})}_loadNodeShallow(A){const e=this.json,t=this.extensions,n=this;if(this.nodeCache[A]!==void 0)return this.nodeCache[A];const s=e.nodes[A],r=s.name?n.createUniqueName(s.name):"",o=[],a=n._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(A)});return a&&o.push(a),s.camera!==void 0&&o.push(n.getDependency("camera",s.camera).then(function(c){return n._getNodeRef(n.cameraCache,s.camera,c)})),n._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(A)}).forEach(function(c){o.push(c)}),this.nodeCache[A]=Promise.all(o).then(function(c){let l;if(s.isBone===!0?l=new nc:c.length>1?l=new Zt:c.length===1?l=c[0]:l=new ie,l!==c[0])for(let h=0,u=c.length;h<u;h++)l.add(c[h]);if(s.name&&(l.userData.name=s.name,l.name=r),xt(l,s),s.extensions&&Ht(t,l,s),s.matrix!==void 0){const h=new RA;h.fromArray(s.matrix),l.applyMatrix4(h)}else s.translation!==void 0&&l.position.fromArray(s.translation),s.rotation!==void 0&&l.quaternion.fromArray(s.rotation),s.scale!==void 0&&l.scale.fromArray(s.scale);return n.associations.has(l)||n.associations.set(l,{}),n.associations.get(l).nodes=A,l}),this.nodeCache[A]}loadScene(A){const e=this.extensions,t=this.json.scenes[A],n=this,s=new Zt;t.name&&(s.name=n.createUniqueName(t.name)),xt(s,t),t.extensions&&Ht(e,s,t);const r=t.nodes||[],o=[];for(let a=0,c=r.length;a<c;a++)o.push(n.getDependency("node",r[a]));return Promise.all(o).then(function(a){for(let l=0,h=a.length;l<h;l++)s.add(a[l]);const c=l=>{const h=new Map;for(const[u,d]of n.associations)(u instanceof ke||u instanceof ue)&&h.set(u,d);return l.traverse(u=>{const d=n.associations.get(u);d!=null&&h.set(u,d)}),h};return n.associations=c(s),s})}_createAnimationTracks(A,e,t,n,s){const r=[],o=A.name?A.name:A.uuid,a=[];vt[s.path]===vt.weights?A.traverse(function(u){u.morphTargetInfluences&&a.push(u.name?u.name:u.uuid)}):a.push(o);let c;switch(vt[s.path]){case vt.weights:c=zn;break;case vt.rotation:c=Yt;break;case vt.position:case vt.scale:c=_n;break;default:switch(t.itemSize){case 1:c=zn;break;case 2:case 3:default:c=_n;break}break}const l=n.interpolation!==void 0?mm[n.interpolation]:bn,h=this._getArrayFromAccessor(t);for(let u=0,d=a.length;u<d;u++){const g=new c(a[u]+"."+vt[s.path],e.array,h,l);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(g),r.push(g)}return r}_getArrayFromAccessor(A){let e=A.array;if(A.normalized){const t=ir(e.constructor),n=new Float32Array(e.length);for(let s=0,r=e.length;s<r;s++)n[s]=e[s]*t;e=n}return e}_createCubicSplineTrackInterpolant(A){A.createInterpolant=function(t){const n=this instanceof Yt?gm:fc;return new n(this.times,this.values,this.getValueSize()/3,t)},A.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function xm(i,A,e){const t=A.attributes,n=new ut;if(t.POSITION!==void 0){const o=e.json.accessors[t.POSITION],a=o.min,c=o.max;if(a!==void 0&&c!==void 0){if(n.set(new S(a[0],a[1],a[2]),new S(c[0],c[1],c[2])),o.normalized){const l=ir(xn[o.componentType]);n.min.multiplyScalar(l),n.max.multiplyScalar(l)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=A.targets;if(s!==void 0){const o=new S,a=new S;for(let c=0,l=s.length;c<l;c++){const h=s[c];if(h.POSITION!==void 0){const u=e.json.accessors[h.POSITION],d=u.min,g=u.max;if(d!==void 0&&g!==void 0){if(a.setX(Math.max(Math.abs(d[0]),Math.abs(g[0]))),a.setY(Math.max(Math.abs(d[1]),Math.abs(g[1]))),a.setZ(Math.max(Math.abs(d[2]),Math.abs(g[2]))),u.normalized){const C=ir(xn[u.componentType]);a.multiplyScalar(C)}o.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(o)}i.boundingBox=n;const r=new Ke;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,i.boundingSphere=r}function wa(i,A,e){const t=A.attributes,n=[];function s(r,o){return e.getDependency("accessor",r).then(function(a){i.setAttribute(o,a)})}for(const r in t){const o=nr[r]||r.toLowerCase();o in i.attributes||n.push(s(t[r],o))}if(A.indices!==void 0&&!i.index){const r=e.getDependency("accessor",A.indices).then(function(o){i.setIndex(o)});n.push(r)}return WA.workingColorSpace!==fe&&"COLOR_0"in t&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${WA.workingColorSpace}" not supported.`),xt(i,A),xm(i,A,e),Promise.all(n).then(function(){return A.targets!==void 0?Mm(i,A.targets,e):i})}const Tm="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAIAAADTED8xAAAAAW9yTlQBz6J3mgAAgABJREFUeNqU/emzJVlyHwa6n4h73557ZmXW2vvG7kZvANjYNxIEKcIoimMyiQA1wzF+GBuzsfmTxjgafZBmjKRIikMOKVIkRAggG0Sj96rq6tor98yXb733RhyfD+e4+89PxMuGXr16GTfuie2cn7v/fDkn+F/93/8OMRER1/+JdYuZyhdsf/0j+yEMx9qh02PryWs7a+DXsqvjJRgO9AZ6N6wfoWX5lokosd8MkzAR1+16+XIebjaYmISImIVJmInqscREiYVpFNqMcr7JJ+vxdJ1PV3mdZSPULTvu0o1r27xIt67t7B4sho187hOX9y9vi2QmIpH6S0Qk1gX133p1FmHm7vjk/EdvPui67uxsff/+cc7y8NGJjHlYD4tEi0Q7293uVr+71W0tu0WXOiYSERESIhEmISGi+lG3RfSjtbTt+p/uL7cp2Ng/1s2wU69Aelk4J+FO0lZ1D5GfynYRzbTBJuKdGE9uLbWBhA0iykQ98+Oj855ISBRPQsTlr/jA6M7QSkQhrF/AEbbTThO+jD+MG0HI9AomTgRwJ8AxSAVPYM0qggz7uSC7hX7ZycJEVNBfpIgz0SbT2Tofr4aTdT7byJg4Lbrdve3968uXr2xdv7Lc2+2v7C+6jpY9cxbKmUahPA5HJ6vHz0REskjOjpU6TEwkVTITcUqcuPxuLbqvf+yAukR9Ir4pKa3XORM/ebY6Ods8enz25Mnp0dH5o8PVuDlPItuLtLfd7e30O8uu7zsioSwGfRYh4Yq7LCTC5aMwkVAmEmIhIWJWOFZBYiFhZpWB0sciwuzgZKonIiYWEYeE1PEU+IigcgjX7XJBQHb4froblEm7Od8GBEd6EWJ7bmw6vxOwXEA+Rf8c2JuzMHm/hAbCJlZqItiFooF7s5/ZDwl6vQU6N/o+GdxZCvqZKXEmXmc5Oc/PzofjtayE+mV/cHn31stbN69t37yyuLTXLzpOkmkYaTXk9Xp993TYjGebMY95zJJFqsIFjdmOAdu4MLMUUTUpJSJOnBKnjrs+LRZ9t+xubi/uXO0/feca9Tczpc2Qn51sHjw6u//w5PGjk/eenm5WZ8uO9ra7S7uL3a1+0adEkqswCNfBFSJiEclEIszFdHCRExKxfVUwENJFIgqkiygQCXFt5NpMRGoDgmEVQbCrADFIyEXY5hb/cmFT2FG6HoUIUNrbBxFh5gm+yy37ToQ7T6/GcSNKDvMF4sFhA00Bx88zYoBywuwAShXlrKymqHY2Hc9MiYRZFP1F2Q9Epxt5ep6fnecV8XK7v3p99y/c2rl1bevafre9YBpHOt+Mp2erx8PZehw245hzFskV40AE6j41zoL6Toek1QH6vH7zRMSU6nYRbk6UEvd96pfdcru/tLO8cXvrCx/bp74/X+XHh6v7D08/+PDw3sPj1cOTRZKD3f7y3nJn2fUdqxUSLvyHK+K5SGvmYjS4WoCq+KsMCEkxHTODLVR0KUvV96rLWUVDBYXUrACi/hw/ElT4xXIic7ulOUfd0UeMCnFgN2Wna/qA6SIykQJFvR7bN/AHLwA3uPnfNCJIivOZVtk7FwLcU6rKnqsYcOE/krhynsSbTEcreXyWjwbhvrtydfdzn9x55dbW1b2uZ6H1kE/Pzz/YPFkNmyGPY87GpguvFmXNAspe/7ZdX0lmHFmwafYXBEB1QaoPwszrxHTKnJj5hFMxEd327vLG/taLn9j/yuevbUZ68mz93gfP3n3v6TuPjvNms7fdXd1f7u8sFj2LiOTMudIxFtPzwiKSTTBMDOpHcXlwIqRgpzla0+rdhgjFvxOaEyXk+ehvG8r8t8o4qAcK5zLQ3CjbbVXhdRloHYYW9AHiqMw52gKe4B79VxADpfWOcmopDRMnxo8FNIp1UgFgSrwWPlzL47N8PPBiu79zZ/srd7ZvX+53l0TrIR+fnT3aHK6GzSCV0RS0V3KTiRD95D4g8HxUQe7mlYcSEjZuUYmhaZDKB8Gzd7NAJglcHpYTD5xWaTg5XvHDk5R4sey2dxeXD7Zvfeby17908+RsvPvg9CfvPHn/vSfrB0d7W3z1YHlpd9kvmHKmLALsSEQoCWXzE4QyV77EaiKya1f1EFifUp/AH9ueSsS+dFBNwNMYB+simcM/xhRIlQvK0ay7TEREfYhFuAzYU/CcgHKLbBQbPYm7rob4dl+UjUZQkBkhHwg8HlR+coaDWt/QL4p+SmkgPtrIozM5HGR3d/HKq9uvvrB186BbUqbTzfmDs8dnw2YzjpIr2rOQol6lAOMjHumA0Il3jrm8HEEhVCWhGXWxuJOAOnCNEPuBisAzMXMiTokSc+LNejg73Tx9fNZ1h8utbnd/62NXdz758sur4eUHj8/fee/w7bcfvffg2cFOd+3S1sFO3zHl6hyr98xCIpzLYIpkJTNCkolSpUk1rETBFIBXYJQa/GdycAdv4GL1/xyWNOsXyPy30K7c0b/8v/0eQd86FJ2O65+wn/2jxWwMtmC+OZzQoOwN7FwcxtjBzbYzXUBykssDJdxgCehPkvhspEfn8nhF3VZ/+8bWJ25vvXSl72WU4/Xp8eb0fBjGXJW9gt+Q74ifUJ3q8VnYj2I8jy7cbkcIGaHLA2MfCgR/G7Jnps9CSTWs1CVm5o4Xi253f+vgys7y8u4g3XsfHb/51uMPP3iyOVtd2V9cu7S1veg4Z1Ex4PLEWahqAX38XMmf90e2j/hVMI2TsGmJt2rANDhM4S8BkZyGNSFaGpl+0wy6Owv1qYZBketXMywceI0RpiYKRGrHieGzH9IGQ53agEdRvAtX+cDsIaxjXyLnYY6ILx8FtX79mAbiZwPdO5MzSdeuLH/+01sfu94vWORkffrByZPzseA+i0g2shNVPpGPoY67D8mE8GA0HJQOzX0MTAGEwXqtBDKhZ+0rDelWLZXMPBaVUfokFcvAXRo24/n58PTxab94uru/fOna3sd/6eVNfuWtd599/wf33/jwcLujm1e3DnYXHRFxliIDzBApEs4iXCwDkRBlYiJKJLk+F7uLUwMsqkoVvhwbwh55Di+6yNG9eF+LfminTrDKELNa6dYvqb5uS4TKVmVm1f5xEInAdxovQUcTQvXhK8D+Bd4t2H3n9KKKv6h8SrwifrSihytOy+61l7Y+d3t5dYfobHN27/jZ+bAZchbJOecctD4J1Q3zc2dIDmh6Vz+R63unP08S3NCbKlHcO+hNRXA9pPifNc1HjPIQbWPmROQZhsSJx824Xg2HT84Wy27/0vanXtj/7Cc+/ejp+vs/evjjHz/48OHRtYPFtctbiz5VR7lSG6HsvKcGjsrNidJnixQVryAHUlSjncIaLDJnKCoD/eDfsPpOUTxk2qXPY0sCjJ9IBC2AKhvFtFM49Qpi4N8lNSDdpXnOn77ozkLui1E8gAuBhgP0l2GW5LgvWv9M+P4ZPdmkg/3F119dfvJG1+dxODp7en+z2uRRSvAyi+Ti4ZL+g9zeHVzMYKkwkKk0cqLfjkXZFTiuD706xDb+rPpFL6VGlAz3ZLEC+KhM0ZPWqC8SM+fSUbXHUuIuccfjZlyfD08fnW7t9Feu7f3y12/9xW/ceeOtp9/93t3X3zu+tNvdvLK9vegpZ8qZC5hZOOeaCcjClMWSaFJT3jqqIqn4NPaMQdbVAkSbEdFUBet5P3OUMqgcmX5VLUC1TqbQq+oR5/vPi1gB5iehoEiLEPteD0GNE9FQf9T3CnpmopSU7zKlSnsKxS9a/yTzvTN+ltPVS8vfeHHx4iWm883ZvfOn58OmUJ3CcyryK8ENoUxgr/oHkvqBkKIETAmnRnws/0NU8wPYk9aq8Ilc+6leBmOmHkSDkALXAagxJSCKlvB296DIQ8rFFOTiIXRp2IynJ5vF3aP9y1ufeengC5/5wnsfnvzHP3n/zQ8P97bSC9d2dpadjLnqO06ULQucOFtpA7MSRBKmrDEjv/U5BQ7BAfWlAwd5LvBniGRVFTgqE9EqndrXRhjD8VtV3R40vYWH9CIeFwLvYcr70YCbi+zOXIP7qPiZOCULaBq1NU9XUsqJKaVTSR+d8VFOr1xb/MqLiytbIifrow82Z+txzHmUSncqvS9RDxMA0hoYcvSDU+uSEOGPSt//gbExdcOSVWcHxhQ1lmkKk69ZKmm1Ph5sAO7ELgya/aiMSJxA5kKKKCXumFNKXcrDuF4Ph0/OdnaXN184+M//6qcfP9t86z999NaPH+wu6IXrO7vLLo+ZkzCLZCEW0r/sfhFxZiKRJCRE2XJAgmkxx36lHVACEajOcwKmEoVgRuu3n2N7zQNMsl1AfkAGSMUg6nturhJNRJCB9q/HeHy7Rb8re1aVT8xUVD4nSSxdOqf04Xk6yunla4tfu91dXsp4vDp8uDkf8qig139AzZuba8zH/wtRiaD4G4AG/IPKmVB/O9H8EKkRniir+JlnNnLtQZUBdm0qzMTCTJQ5GoTqKFPKPDKnlBPzkLhLY5eGzXhyvNreObx2c/8v/dqrT7525z/+yUdvvXl/d8l3buxuLbo8ZmZhkwEqXkFWhz2TMBeDkUSEKAsB+kO0FFFZtOtz4v1znfac76d9jc0aH2AmrQuh3Lgnknsy2wtcfzpSAfdhu0K9bgJ/jTKQVABSTkkSU0qrlO6u06Oxe/VK/6svpMtLGY5XTx8Oq2Ecszq4WRrom4+rhIeQ9pCZA8QsliP6llALdGjqPV7YENj30JL1BhQXQWiwE2NZIoEHaQkE7F8VhiIGng7P0UNIzCyUmLvMKeWOeUip68Yhn51ulveOrt/c/0u/+uqTr935D9/68PXX71/Z71+4vr1IqVTYVebGRDlV55gSZ5FUvYImTAQhXqA9CM+mo2bMAmAb90S72lqGWLsnRN3f+bkvkUpdRC2qZa+yiYDVA4HcsNEYaqi8avhUuwOTOGy0Rx21GsdOiVLilIgTpforqctdR103dt39sXtn3e/sLX/xlf6L16Q/XR8+Xh2dDeshj2Meh3Es+n/MkrPkTNk2SCs0SYPcRFnLiVUczAAEza1fObgDWN1rqHvr0UzhNDp6VjsDJ6nlanDByqSQVQnTdL/dkwXRwyEkWU1XttM6D6SsYbAsMoqMkkXGQY6PVs8en+xv8Re+ePvFl6/ee3j+7gfPiGl7p6++io2xmX3Xfw22PL47IRIc1OaU+3lAzPSG+s/uY7XsMv44rzxfj93v/+yXWSDpjhD3MIzthEJ/9hZMIAMYvddQDdJ6pljaBRFrBp7DppkSV/R3ibqUu066TrrukPq31ovNYvELL3VfvyG7q83h4/XR6bAeFfrDmBXuMuY6ulLGmGxDhx9YfgEKZnNUe7gz7P3ZcBozIdjhTC3G4RDG3ZOBIoOFciOB76Q4mewHyAVioFjXu57EtzAhZRmQrL8i41jE4Pj6leXPfPXFW7cv//idZ3fvnyyW3dZWX3PBHtewe55MDsGMa0yWhh/wGIUn38531ORjiE+GcqzErAJgeDVTECUUbjM+jO3gKAAT9d+Edxz9yWoXHPEe3Cwqnyv0JXXl9zz172wWj2j55Zvpl1+QS3lz/GTz7GRYj+Mw5HEoElBAX35NsQlly2s69CPWYcO6TSIHQhhHp8pDOo0VVt4iE+0k1s1zQ3hhCETmNFyVT7Me3AgDNnOP3h0il/xiEj0RXtOEMo5ydHh+cnj6wo3tr3395cXO1o/efPLs+Hx3b9l1ScWAgw0AmzAxD1PfcCIMHM7zvw/3/uBtbyXm89UYMsHKtwD+onrH4qPCbERf+ZR7XBD9jJIyeUQG8+LJS1YWlLSULVHHlArjT7nr7uf+3rp/+VL6y9fGHRlPH40nm3HIUl3drNlc+EGWL4hxIeIm1tn0GPZc1OkUWojgaGNSHofI0p4kEz/PLToW1uj5fposwJa5lOXRYJhsbMnwyUIsWkNFVMhAJqlqSEqChbPImDmlPKTU59SnkzG/fbo+uHT0xU9e+/Qnf+YP/v17b7x+/+aV5Y0r25wzZ+GUiRKREHnRXHWOs1DiEuqt7jBmmsybnHoFbeo8/hiGn0993MaTEHW//40vQYzSZBPjk+Wv2jb8qPYtRDCd/EwVP2KdmJkTRCSM/VdPt9Keqvi7/iT1b43LTb/4pVvyxYONnAyHz8bTTdX6leyPWstgWt9ovc9PUX6v1t+5fqDvqDFlriuBloRv3frPjUWd9mLOKSC/qOxAeLi9nJ6W26tGEXF3MLIgJEuGMHavJnSOtrL0oHZpzkKZ1qvxyaPTjvKXv3Ln9p0rb759eO/Byc5Ov1h0VZ6NDJgM2scQIWkxGDrTd8Tv3R9oEB7hHr8ybcBUKNA3vlSKPfAWiIHbUOT6vjPEbAhqGniO7bAmcY3wGPrZM5TV66WUqGPqCvS7se8/kuV7eeuzl/jXrg8Hw+bo2Xh0Pm7GcRzzOOScs4w1q0s554D+OgMwJHYN9EgLwZucUB2e2wnjQEwMOGM80CTBkY2nhTZNA8YhD2YcOPHcsDdpiVn3ANlRK6fSln20TlGNqGXJIqen68NHx7eub3/9Z18eqfv+jx6NOe/tLvVOuXlMR3LAc+sZY+2l3x9PdMosLzLhjxKAxzLz+Xrofu8bXwICU8UzeAXRA/aPHOAODRrf1zxf+7YQHG4z87VYRWWg63LqqOtO0uLNvEWL/tdvDJ9Ybs6PxsPTfD7msUxMKfOxquLPdd4teLc1vIO5XcjgWhhkxrFtMAHxuDZMqR2Guh+7WtWhHRKaXWAlcHu2PVyFlYZdIBGVxk4iRR5KMg8ZQk8QGFCR0J50W1oMwijPnp6vTtdf+NyNT3zq5ltvP/vw7tHe3qLvk5JDv9sZQh/8BeVqSo9m2lJQARf04QWjqSKdigD8/te/FKo1Fan4EVW+eckeFNL9kfkA9Bv1nxz6zA59qinJRCmVOE/uunu89R5tf2ZffuXyanszHB6Pp5vCd8ZxzFImI46I++zerU1An+h+i6VE90hmnFcyXdkGIlrm037PrsJdwRcuW7tPPGhfCXg099EmTAjSVJYmAjMnCeiImzDpZBjACJQZSzAFHjxQ/7j0+Xo1Pnl4cvmg/8bPvjxS94MfPRKSnd0liTNhA25Dd8InmQKemx2zIzInCheKBjOdr8cewhbKNzEdRv6R3RWedmcrqeD7chhktwJqKZKKRSrJ3YL+tE79O7w1dP1v7Z/f7DZnR3K8kaFqfHB1rWpfwY5bpA4p1mWKBJCLdavEVHxjT9U7CyM1B7HY5YArCHmKQFd51Mh7WOLlJd5QHH5rh2NTFVgTAEH97nV3TNmOZiumILJqyLpd5sUw52K0hVPiLFyNQOoWOef+vZ88OXx89vNfvfmx1y7/T//sjZ98cPTK7f0+MWdiFuJMKRFnGlVIE1Emvyi47RYIuBDSDFCEmIHA36lbrKEyFqHu97/xpVrPDaQftHuj+xsjAK6wMXtwdmubZKRfG3m4Mzn171LR+tR1h2n5Ju/cXtJv7Z/uj8OzEzkZ8lCyWmOh+1ldMfd0a5QTRAB1vKo1xzPGWBxs3HYyzWh3bePmHFkQUa09aA5Dpa6d6JahHs7VS0bleJHWnwmhwj3gdfFuZ59k7m+zaQ7SxI9COiQi69X4+OHJtStbP/vzLz85HH70xqPtnX657CBIShSfELyC4CHDfc9bi/Y5J/fudgz+mhPcQ2Or0XA7oAKpOl43TKeZIWsHAbbQOsxF/RX9KeXUSZc+StsP0tY3ts8/vThfndLhRjY5jzmPo2QJRQ1eygNKX/NY8A9TKXZyIZiMvvcVhGWkEYipbAiqfCQhMz3RHDvvZoSbCxMEmwqKdqRLjBXK5wvsxU9NoAia63O4Qv3LJo+iFryUNhBzXQ4hE6eRUuIskpmz5CxplLyQnOWdHz+6+vTsL//6qy+9dPCv/+cfX9nvX7i+I+PImTglkixV+RMRUa4WiVg4UV1GjLDyLCrzOpSKxUno4qf91J7sfv/rX+IcvG73b5382x+vibAcLrm6t68syglZXo9ysvm71DF3naQkXZKuG/r+rbQ79Ivf3D55ic6Pz+h4IzWvNWZzdj3KryHOaV7T9JT3TsMqaKL+makNXPJFc3YbLT4TyeHJnmkzbhmiN8CsavQl4Cbx43Ma2DNebCim8SLYCdMTxN0AcnE1n0oDDzXyVmafffLjVz77hRdef/PJg4cnly5tY3XN1FeZ631uwE+zd467nfxe9COc+Hw1dr/3tS9yFgg5keMYoB9rHDACRBjsAd8XSREGOtlDPR1zlyh10nfS9Wf94vVu/9qCfmNxuLcZnq7YQj1jiXKOdXG1HEtWLC5BAuEc9wGsTxQDRha9M2a1A4AG0RziemaxI9D5AugzE+tJ7DwcxQZIwgxrApbl4JzjYLWxmJSSKlhckcPFA1mHdRxryXXADtJJqDiCpIqmXDKNY3786Ozy/uJrX3/5/qPVj996fHCw7LokRrK1f8MNIYUQ3NU29EeI99iSWP8r+rx8vh673/v6F1lADXkIaML7aRrxBPZvMuJh/hrsdwcgpWRzkRJzV6M90ndP++Vb/d7nFutv8uG4ocMNrcc8DlKq+DXDFUpTxMsZor8bytQosoiGtExZOjiAMDyC49Go9oasM0/VedkvDCi/ANwtxLkJ6XDEOlx3gv5mMsHEMZgyt/ZbDnaAZ9SpRormw8pSaq6ISJ4drsZh+NlvvCRd/53v3V9uddvLXgTnXXFzO9CtsKmqq73pxnGIMaapRyNUa4F6d4ntREqaqU4QqLMVHD61882AhayMx7sIjQMTJ690qAGfWtZ2r995sNj+BT56bTg9HbuTQQbwdeufprRBrbHmr4Iy8sFoaDd6SXE7sgh81gscyhnwQACHwiVkHmPtaaPeYjRZfpM4CvrdNPSHQw5zo3jSuDp+FxUWAf0GS1MddSEqtf5MiaWuvZElM6ey4F7NlOWcu6U8und8drr5uZ+5dfP67j//F2+s1uPNK9syjpyIKUlZaIVyjQiV3xogqj6ICkzpC72zSI2k3YNEV5rnEqJCgYjUCJkNcAfA2ZoXrjnRJ7AEbLXNVft7oteYT5e484CP9N37y70ny+3fGB+/OJ4/G/rTMQ9jHsdS2yNlic0cFD+1ut/Yvw9/E8CMnAdhauq8KVkMFoCc0riemOjyRvGDvudmPxvLD786nZex14E42TZNqI49CE34kokOkn6ThGi+JpHf6QeozGSKNduogbAaXKgwVRqG/Pjh6cdeu/Spz9z80+88ODvf7O9tVY5W+51NKuvFwk2S5tunQjz3M/H9CLQfc/EBvvoXWHxNVqc66AAQ4N7HVqkQ0n3bEX50PYIucdcZ+nPfv7V9QF36nc2Dg3E4HLrzMQ8lu1UnsljlSU3uustLFvHx55vHfehAUMaM8UdDOdBRyzrxPKwNx9yg376a4p5TOXUrLQ2gWSnTBXCHGOsc3KfuAZPMNHPFMEeHWuCwoTlmwr3T1U92ema15USSq4w8enR25dLy537+lR+9+fTeg+PLl7ZQ/Ua4N7ejLo2BHu9k4j20qI9+gApAsAAt3S/7bV3KNsgDVT2MkpAA9KD7qUtc81z9sOjf2j7Y7fg3zu8vBnmau1WtYs7Z1H+o6YwZeIQ+Fu03Tx4QjyPedLihhCLcKVA8tjh9NZPgzqYZ6KOCrxad1I2uklClIugWouAbJL9DVPA8QTwUcrWMTuBwac6GMkONlQi9KY1jEBvA1FGIVSr7goprJjk8XPWJvv6Nlz746PT9D59dOthiwx9ertHsdtE5b8S2nhcMBRlQJ/irX+SsxXAaA/WOZMS9SYWndZOGhFDXV8KPy5LpxK4S8Fkv+jd2L9+W9a+d3h9zd5jTZszDKBX9muTKDe0pj+eTtJzsqB8QeyPaUdjDWoJgSDWgM8LIID6j459jHAhBH2UDgmWq3RNwm/qV8zGDqbVH3T/TTIVHhRxDRoj+ICHubWj/XCQDExg1zTw2KtEHs2HSiajHJ+txyL/wi688eTa88eajy5e2TM8qZ3PGGa9uz9ZaDPwYykgjEspkyJT4fDX0HsE1VWhTfmuwqH1+DxOJKS7/JZMQMBGl3E26JKlb9f0be1deGs5/4fj+qlscCW3yOGRfriFLzpnqpAyfr4LOrmI+qhvxh3fXh6yMnAlWpGNytxCgYH0XdwZANAaEjCw1wxH2hC5kv0sdTWkb1QSQnRkS/Qxuq5YLwB22lj9se/OyhXkPK8qP3ceu2RsklpiHoLkSpiRaNUEiudRNlAwag0nvRB7dP1qvx9/6tVeZ6Xvf+egTr15aVP6QJaU6kUAdTVFN5bMqGEd3rpOnOjGMgEhZFUIqt2I4p74roMqANHLW8Czmkht0LecioCUPkpKk/nyxfP3g6qubk28e3jvrlscjDXkc6oxFWJ3NVT/UIwLVUWsMPp4rHSYGcAuMTeNihYeybEsQEjUOZGeuz82KUCaaop9BFKeXgguGr1Uq/dgYzfDvGBvFCWgAXaAiE0kgw4dG/WLpTFytrnWubJfY6zKqXRHJBQA66ySRCLFkEU6dEyHJJFmePTl9/Xt3f/2XXmbiP/v2B5949dJWxyKJUyap7y7xe6xmTKunTJAxGzwvDXNfC1NdHbr2l+eHPP1sD+w9wGUtSre+oC6VGlk6LJVKh1LidrZYvrV/+UunT75w/PisWx5nGnIeKushFwAKtEcoMP4a+0SsKFkMSo5noP+8DUMta9TNmJIagfLQSqgsOcCNHDVWYFolar3ZGldRw+2S7JCLUXMPAqqaYlMAFGUAFXqNBoUFOMOag1D9ASoGj69fgmVi/UcZnBgfKMZAg6RZiDpmsclJIkJHh2evf//eL3/zxavXtv/g3/7klTt72z1TZk5JKJMk4ly9JyLKWirlSjsOfNPVjTCj6DNRXRdIpGQHmYEWNKtz2JrE5bxmfkkLRoiC/vcIUPV6zxfLtw6ufPno0WeOHp8ud04ybaq7K858rIoZfF2jkljVaRZLQEP5SOPzssK3QLZYbRRZ5DPugzqOLasSTMdE2Td2w8NtZL51GJupdvbKfE71sTBzwS0KfeCbN7ZQQ/xst0RGp1hw9NsZbHLhhFNdgCh/p5a6TlK88bK6birCkFkSdbkE96spEDmW89e/f+9nvnR7uUj/87/68asv7i1TYs7MiYopYDuz9SmsWOXvGpiTBI6zMhX/ZU9vpR1u/bX2Kb7FBk4H/CsWrGiwFFK/kpKkbt0v3rh87YtPH37m2cOT7d3TLJssg9b12Ou0ptCPtIfU3fXnDZ6WPoJ7MejnuV9IhFA2wAZhsCqdIBjxYys/LdBnJxK4yZ6OlhmveHf+1jh2EFLV+i48c1pfJteZkH4UxGgcoqFoQy2NRAtYL0eqcyGp7xPIZZ1p7nTtdREROhP63rc/+sKX76zXH/s3//qtT752qeciA0zVH0ABiKXfjEsjRXFlkmyG2MFijXRSfOSa5eF1pPT5vVRXmY8YTtgdX0j9lqktm37xxpVrr5wcfeHxw9OdndNR0S8y5pDj8to2C/KQfoSnCtUNs8Nc3uUDJMfpgrP8husHiLOvsQbWjlE8FJrBQcDZutZBEScRNqpJfDAD6ClKBxFIMmp9VnIsRGweclsQHyfiSysSF6N/ds1ym7zQkCbr4YoVdqKSpHAhocSSuSvPqaIn9P3vfPT5z7/w+PH5d/7sw0+8eqlnppS4oN/d4uJ5UzVEHBCga1RDd4PSMCJtY9JrBHFCewoTxkAx6hhU+eJ5AGBCFf1D37957dpLp8ff/Oi9s+2dk0wbyUMp61QLkHXylqAAKPt3CdUgXvN8kwmKE/av4tzSHlMq9WnsEFuV1mWjwI41V8DQwPZE9De0x6VDCNrYqOFHrIJAcRJdW67ep9gLGk31KvOxRdeigtBLhIiZUyN0DLRlECN232DiYBjKDDxSKiYS06joT+UsmaS+upKhgu5M6M0f3v/lb74kWb733bsff+WgK2molKi8oCapw2O3o9RLjJuZrAeiGNWKC4Dd8VQGwhDYOw7ACmHBD6p/n93S/+TKtTsnJ998/+3z3b1j4s04DiKjC4B7vRl0P6EMgLqCpWURFTrkJuMM+HaoTWgPWfIbxQNNQbQVugSayYOLE84KaF8uYgCyAyd4DB8YwGmqVc9siPNIl25FNS1q9wNGjWTVNjbcUSQMyK4xZyShVTf4PAwvycoiTJzBS6n+QC0ZYk0YE9HpM3njB/d/5ZdeEZHXf3j/tZf2M2mVTemZUn2k3hXrynrFjbXwgL3HleY0gegj1mK4YBmgU3A4vWhUnAugfdA0cLJCt7evXdtdbb751o9XB/vHxJshDyLV8XXaY+rfdD/E+MPKTq4ZBSbu+FRadcNgIKKLOgW32HqxpEZO04HWfsp82qKJcBHN3aIWma1hMcCbA0Ggw0CtcsRvGQQRt/4VjezZA2wOtBDpAfJGcWSgEQDLIN7dF0lvoOWkIqNUoSxOWhxiEWFJVFwC7T6TguPDszd/cP/Xf/W1Z89W7354+OqL+zLmYAdQDbtuuWBJXbxPJHFCRNT97S9/IY01E6y3GpW6rctfeT1ZsbMW+SetfUip60p9P/Xdh1euSpd+483XZWv7qO/Xo5R4vy5YSxD11/ygvofK/HQL7ftEXgbQFMFkRKfXzyhvIzRVRtwsua0N/OkpwbZnw21PIuKyuGkhgNx8632ZvOINT1IDxHHWi3/l6sTvLeSn26cTgqdDgbREm1d5mNIyfe/CCkZATaj5TrBhp5jzZyZyMbPaNbQw1hi90PVmPDsbvvK1l95599nTw/P9vSVGQthOrTvhGozXD2jn4O5yWRXiv/5SEQAAvckAN0On89fLywiLtmfmVP+Wgh/pO+76B5cvP9nd/cvf+e5i0R0ut9ajzWaxoGeZzl6hr+w/uLyihEGsu3X0PdENLHyK+3K7YtvEE2HAxhSBHjaYk82GcW/HJKHwUyx/8DoLrAhKcFoKXlNQay4VuN3eM4GQEOgF7ZyQ0g5uBnSgfidhw7ZBJERHAUcixIZgCw23OVXhoug5AH1V1rtaDcz0ta+/9O1v319vxt2dhdl6mP1RT6CzAO1beAQnakYHXQB6/Q6XO3dOp7RLi+REFEdUd+rXSn46Tt3T3d2HBwe/+oMfbjM9WW6vxnGQEvQUn9ZCVfHnhvNE3LsDUA0qPFoI0qqDXIJVRp6bAVYMtQyOKcrJDFlSDVq3NSkGhsiHmIGj2g0jjUE4cqPWvE0xf0oQwsiInhA6QV9LatdBghT6zf2EpidrrVoEpwdxQl5sfnVH9J9LUyF/bw0J51rUQFILAtEnpvIWAe2xex8+Wyy63/3dz/2Df/D9Zb852O2zZHaFYhqjBuDMITbjMvPM8MoaqnlqofCX6ga7WJWPniUyHgDoZ0pJunS2XL5368bXfvTm9WdHh3t7q3EcxjyMOY+2eqfgb5WGjKsKiM16t5lf5hxoxIAyUX2NeYkv11+9WZ2yIe2qbFVI9IFwf9G+bN/GemZU3skPn9AbUY9J+U8C9Z+CQYB8efn1l3jjFcuxzq/c1IRJBQRGxivwkt+kzcak8GuPKVatDc6dak2bWsDWz9pYe97kwDw2e6depjChTz/msgJ7qf+tf3MexnEzDqshb4YP3nmy7OS3futT9x6erYY664YSCyd9TxwZFzXN1VQGTKoh/Ta7v/3FL6QxE8fB9BVMqs22Ob2shZ6F+ydm7jilRF0ni37sFz9++c6n33n/cx9+dHTt6lku9f2Ucanmslpz1poQch/AGR1T87E+ianPAlZTAKrd63MkEmNwyDFqCNnoUHAMOMDIUcVI9C/6G/ovhW2+uDEHBIfZj86L6u2JkS585GimWrpfADrDG9VkRX9AxQBRohTIqTzQFTO8ZgEmtgy+CfwkRMOaKKrtFmLmw6erj3386mJ7+YPvP7hyecsfA3xEZ0TS+BXcXKTKsxAzryoFEk1pWA64+eEaViKBCQOm/otG7Dri9M4Lt248fvozP3777MbVs5wHoZHKaxZ8wUL7q26uUyCN+ZSQhgXj7fZII99l+KUyMm1cljejVCOJQCz8rtVfYmAhhr8KIHVqFU/KdoA9QYAVThM4LnZk26d2e5E/N80gvOjIUF5TNszaNyHKub8WRQV3EerhaoiIOcARwum+4QgDyhWOCpgHOJPWoYhV9fjoUWIikpz1rkW9jjd/eP/LX7z98OHpe28/euXOfh6mRKhGtIX9UQJHC4TI77GUQmBImQgcgjqmQP2DKqsecaIuMae7164wyTf/9Pubg70TTsMoA8lQ0C80wjIO1QGwiLDZrBr6rH1UItnRpYGPWvVgWDQbzZq21qdx9ensv/L+mdCurlyIIRrS/U79OXxLrSTM4H76ogck7E0Mz4Bl5DX4FKH+hdUrqMH6GnCsZ3Wg+/na0okWxuFK7gYITcTAdgbfQhQ5QRbMa2Eqa8xVsFa8Z5IkQomy1PnATJuRmM6I3n7z4a/88qv/6PHZw8fnN65uycDsgVFdv0j7UmKKhKqLEDuBiIj7En9hKAbUwdVJI/ZcAVNuAcpizkd7u4+uXP71f/vHi757vL21HseBCuipvGtHtb6+i8hTXWoHOAyPoEaBoddVPRh61YqSrJeBs5Kq9bjTgpsmG4ZvdXP0SCSXzklITATMJpvcOM5ZD4rQN8CAyXAd4Da3jElCeIrBGvHbrL84/UsR940AlkaqORt5gIQAqTWaEQOQHDaoz1gGnWBQXBXJhZeWtpmJMyWmnGNw8+mj093d5V/6y5/8//wP39s+G/e2utoJiX2JVUaVIjPP6/CoHZ1qp5u/C7yk+sEk4CWBwdEfSWmzWLz74gtf/vYPrx2fHl46WA95zBb1V8e3vqsreMChBEjKYkpQMg4ur92OGNWb+l7MjUMMN67BJeU2El092xmC7vGhWxIf/WDRuIDgyj/VDbWo/9RhAGVC7viKObI4JRITC2w3AD4xzXu9cSWi+C35tcL8uHZdI5tXyRppcCYp4iEHM+u16L9odh/Zul5Qcf6UE0v0kotDLHmoPvGwHvJm/Oj9w5Tzr/zqx+7ePx0y1Xe1Gl+NoaEYf3M+HBgaScgE1wge1s2wmRfbsA5W6p/S+3duvfjBvU+/+c7Jq7fPx3EgKurfyQ/pi7mIhOorlssrTIS4hpnE1L/qP9WG04kg4IGRkM6cUJ2q3WDi3loA84+DVXMdjzkBKhBhNt+JHCXol0cuZDwZXz6LjzD90UHR9CajgifUsoG3GP9xPu/zBQI7QjMTKRB2uJaisKtr1P3FG1aSLv6BwuLaxNVDwMhsYek1oF3X5sU6+2puhLiIDqVc6RAPPBDT228+/OyX7nzhL9x+8/X7L9/ey7lOytWUIhQAFZFonCcnM/V5ek9AW+chwzD0w7BVNVXYP6cH164MzD/7h9/e3Lp6SrzJouTHxLu+mMtC/tldnNof+q7EaXG/WuSAEef9ur+kbyvQMRxhFB8dAGf8GrVUQmdiAFkqBLpNxyA7n5Mi+AieSQruLPSiYk2HzPEfBT0QGHteFncDOLRs0Y+y13jSk6+gCKbGHPQunAJpsAUK5kAMZlYZiq6+2EHaibV9DkNaVGXZKv+MzGvavP3Gw5/7+Zfef//w8eHq6qWtXF/aZUYgQp+jtLdPqxNiyFWWNq8SpcEUtXZJY4NlOf+zne0Ht67/8r/49/1y8WRrazPmkWkUGVUGxoJ+1fpVBjTKKVCg4pTPPCvT4j4q+gA+3pYFxd2qszVSXt0uIna2QG4rgBepCXEpUvcCiCbpdOig+MEtQRuKg8oRmJyii99Ehhz6fqyWfyLKYx2o9YZNIouahRWjLi1cF1pys+kSEoI46CWzzdVQCx7EgKgpvZyj48VrL1RaElPGyoz6LjG2TuSRmI+enD26d/Sbv/XJ//EffH9nu9/qSiRGi6OgUlr96+qlo1dpGa+k9QfBJzXWzFRUs6AM1PhPSrlL779655PfffPmvcdHN66UjG95QWPJa4wx4aUcj3JWXljzX2VbN1rqH7Yp3iMp13dKqjmRmooSo7llpFlgCaqwwI6SIjHEczIRMssHpJ/F+LclBp2MGolHZ0AtTHFXWi8Asl0N0Y/pNs9ntX+TTNv8tI3iS7aOULyziH51Hny1FZOJMl6MrEL9AXDtxAuAizNQX/NQKsRySY1p2XBJlg05b8ZxPeRhvPv+4e5W+to3Xrp7/1RKUhKTjERw/8BIpwLIXg1aYodePl/kujp0yqCTer+UEnO6f+vG8vTsZ/74u6tXb59l2RANrDdMhLq/sP9sgGZzUq2LWPWIUs/IGVT7c1YXJWT7dPSA8tW7trXFlNwDkyGNw6kYsKHHA0e1+3CxGDAIjVdAypesPXR25TaemZo8n4AZEdDThUkHG2dHBH4YSbhbRe0+DQ/WOCWYk7oqeQgUWmguWqYahnDTwLrXjYAOBJOfAGfwxuARTKDhkFsrcSGy4SHmgUdifvvNR5///Atv/+TJoyfnN65siYzM5Hl0k1l0P5hC4oKJSimER3709ku0xWW/ipi6h8yc+Gx3+9HNq1//l39MB7vHWwtdwj/Xdd1GgaqHDIv8kL7NKFSDeuSHKOoJDtt6i2rFPJhjYR8krLrdhINQsRFqREHQe5VlVZPCeP4QS7GqCvHAC0Ebi+QQXIGCucAAUTHOLplRYTeJZMI2FGyCB3Z48pgJ7xlOQp6TVvsZO3Dy0TWRFkpUl84HzkNDJqsYKYoLn8WiiTp1UMach5yHMQ/jsBlPj1b3Pzz8xV9+7fR8PFtnsfgYENr4+JMfIZIyP0dnJLADcIIg1GQpSeo+eO3FT/2nH9548OTZjSvrYbRS53G06KfUoKcA/3E7KEZ+YvQz5gfcULCHZ5XGgE4yaBLVr4L8KvQbeSiNkfMEg1C/bQsZkpcxc0BVbJnquDv4EnESSrUoqGzUn2RP4ZdA+lQ0dMBxQnCLSZqxmkm8NcRzDSLq5ZPfqiOEQjyxiSGqeyiVCxlwCDUqGda5wj2DgvPIIEEwtBKkbFHRskps4dXDOK7HPIz3Pzxa9umrX3/pwcOzzJyhMkondQR1E/lPvc+eiCjr1IqgJdACFFVQS4CY+eGta2m9+dIf/Onq4y+eZxmYR5HByhyc+VAWj/lkWE1VRaywnRJwmLfk5DFBuH0hHWky84jEZrJdbZdUf7jmBIznQGOqKXvQ0vUOTDZwYmRkRMg7zfKC0QjPpCOhAYsIL28AM5RCBrd+i3NohJjNP4ajjAOVPFqmcHEd++zXD3+drEwbmFAo2wHyFLKvKBL2iKylzEps6xeZjTDVqCilzMJjZiKicWQm5vfeevy5z9368ZuPnh6url5aljWJpA50EsqkxqaiprIg9yeT8jsjQh4CmFEazJTSenv54MWbX/n//RHv7pxsLzdZhixlaTczAtOEl7/MLodsV3B8LUI6/TVj2ux0++Chd3xCUaxj5isadOA5QAZgLgvFrwjbTFxGp6vU6GyXYbb7MeaGTCYujQiBWiQ/eh5nLJikmVX8XtGb1OmCixKcipuHQtJ4ARHyEKmmySr02EgGWISKbF36z8hPCZCIVQ2ItESocKFxGMfNeHp0/uje0c9/85Wj02E9iJcsY8gOTXr8EaJE7pyKjomEkcEAaErMfPe1F2//6O0XX3//+M6Nla7nXN/hVRFPLfoL6S/xH4M++ZO7GOgvCVAzzO8KOiZeUwZi0Ix38/ANOabJIWkWOuYVTBO6UYqSUJrGbcJ2SBW3BdLStIxodhJ/cfa3pb88extprpfCPcDfNuSA29PQHBAhL+tt/TqTBYgLWWlkllk3wKNDeRjzZszDeO+DZ1cubX36szcfPjqjxJkI/AGa4l7izj5oy9rA6pRCTxcGdHzl4Gxn+cv//I/Gl26eMQ2ZBpaRKBON+usln6xV+0wixTWqi8FQCRKz9YWFJ1yJ6myOYqhrAMdiGuwPU9mLKFnxuDmEV7RNoT4Q6gH3N1CgajdKcyfNdpOe+K05aK8nNVLhap/jGLhbJvidBkesN/TYJp6jLKgGv535KO9hoEO1pd+G1KaJKJcEsFOdDCXGfldwMxhqawJEnjbTcjRRdhfuY1IiR1V7edSeWZIQMcGr9ISEKRNRJkpMI4/ETDy8//aTL3/59js/eXx8NuwtO+GRSc2+Qtln4Wh2wilQ9C5t+gsY+4K+xNKlux978bP/y3/aOVsfXT1Yj2WSu830FQ/7iMZ5soV91DK4iOusgMB2ag/pGkFEkDlGZxcUj0u2ONUJG6AsyXU2Vr+UJMAE5RP30c2rV6GgHo10pcaOkFkhU2Jq1H8gOdwqfuQqwQ5AY4ltWhsVCn5QDpHcRfUf7cOMcQhEyANlbrEdXB7VaKy9RYIKQwYLoFNnmojQKHnI45DzZnz2+HR9tv7q1196/GSVi0lnHJpI51lFnZi4lkOLZYxU4wrVNI+NETPxoxdudOfnn/2DP1t99rVVzkPiMcvINEpU/+YHF69XSLi8hKBEs6umtgC2Fa8GNVP63RLC4MUzVJBwA1Dbo0OsxRwVRaq80SaoxTEcqwfs6l+3K2q0uZuCaBLAGdAxCKZ4ho+6i9gURqtRC+nwaAeoaW/pnPL0MjltTB4LxW0KuYXWJ1ajou0ZFbrWCCn58Uh/G0Ei+BhKSUtPl+rQkijPrBmLeqHEQmMmoszjyEyJP3r36cc/f+uH13YOn62vHCwlC5Ot9+EdFC7OJGWFCvAxiSEkWpyBVDI9KQ3LxcNXbn35H/8B7+6c7G6Z7zuOjfo3xm/Rz6rO62uNTLs3GYAaA8WCVI8wSFT24gMwS0YJLABJ1Gqo2KRRYKb+m1gyKP5G9ba6v9XZKex081IipPgL7gr6325eCjBA9kzD+beR07cOA81meafeTrkhm4QtAT2NBYgfhW0KsEdCve6i4i74eyHIYe5fLRq1abI5ky8iq5MnRedPnp2sntw/+frPvXJ8Ogy5vM2etbsI4tr6UVFiTrDnAdjQ70qVE9HDV1649OGDl77949OXb63GPAiNsMzJjAzUDAChI+/C4Ljn2BFAisR8cotOuRlV/wplA4ZE2rGBDRcqIxs6NKCzG9zo2EfJqYJhObLaf/56JTMIE0ROgVgd0IR7JBIYr1t2FzzhyakRBhRalRkx1hTrLESNJ2kGTOJXRnvaqOg0SOq+r8YqAPGmqCwVMEV/yI5pfiBHz7hKwjDmId//6NmVS1t3Xrr05OmKUqKoDkzFqGnicttJ78LSGJMcMDMxb7aXT1+88fl/9od0/crpst9kquq/ymGc9SsQDirUXwhNgf16loAm+kD7MQZ/qnFSBFdCZyMnqFxd40QdBhOoQ0ZMOa751lquA2wesTiNjTZxmBh7pQng5jSxs3AdoHBCkATI+JAGRhlA3Ch4BpGIwhzogUnIRM0b+5HmzFNTELQPWmxj/6FYKLqAtkB+DYnamgmgSfW90XUSfR434+Z88/Cjoy988fb5Oq8HidEzU/4om0Rl9nhVwhktADhrzIno/sdfuv3dN25/7yfHL98qi/wMM74vol/xrbXQEfdWFC1AgaSIoXE97JkgDGwdirqffCGn54zNjEoLWCn4wzgakA1wKANkUQGTnwcuLRhv5Zlfq7t14dE1GqIRj06wcyqgTCFCGu4WngK5TZSotjea1ZlqjZjJkgc0owVwyyDKSNU9aCkQcmAoniPf2UZFsWaulkiM+dH9o4O95ac+c+PxkzPilN0zQb/cJIGozAeou0tYMhOnEiEri8BRYl7t7Zxcv/SNv/8P6fbNsy5tKvqrv+u+L2vql1nqSwHx191fIqqvhbUuK25bCepRdPXIN1j3W7VesVBSAmdckeLHMambS0wwtx6GymOjOsZs2s7WQ/KcCkFslJyOq22p/3gntzlsJ+6+S7ClwP/1poQ1fAcb1dkVsgmtHoGEztLYoi/rMF0jWuOuwQ+uu9WAMiCddcV9mLENRCh4yaqb3FH2W20cYvbL271bFxC1xdL135EyE43Mm3HgdO+Dw8987uZbbz4634xLX+HP1bn1fTlXQv4R2H/ZYGaihx9/8dYP3rj87sOj2zfWYx6FBq/5qa82GsU4D3naq4Y+i5dhCS8MfE2Kn6vvbaFP5dZCIpxD6hS8XvUHdIwtTRb4zNQlQDUZjYO5B2TURRzrjWNAkdWYJxCpCDvFikPfMopoPVL0cW0DeZG5xW7xPUZp62i4+OGDB9qGt2VhzZIZwhhok2Gc2hNwxtSYQ4AJWMhcXVDIDYfVhMii55Ud5VoyPcg45DyMh49OOuaPf/L606crSim4ATpWGEkveYCsMR9j07VSJjGv97ZPrl/6/D/7A7p147znQWjI6P5KHslJP9ytVzWFYk9pXP4qCUrulQeqv+t5Mg537wY3eLeQjAxDotUQeIhVSRQRAsFgkmmuQJU0MqJQChEYCAEPqcnjlgI1guFXdIl1vu7zDdCpiN453K0tzkWqDhofAJ3+C+GrPLDaB2jgtkWiZpFwCYnK3nJOiHsUOGq5kLGgqi9rJQFMIIbp5jUi9ODDZ5/+zA1hXq2zyyp6wOy2Opl4ehCLpJCfsn7rw4+/+MIP3rj8zr3jOzdK5svXN1fxGyP7ByOAYZ9mQ4LtCcJQxh7KQrFSCag/xkxJpUKdgejUqikIWXrU96CLVWtiG1MbqAJJFyCai//Y6SyB3ehayHy5AwoON2hru2FAfFxIyyQf7IMasSIDAsie/Mr8X1ANNq/I08bqDAgHERKiqJXA5LrBryJ0oTNAJDUtjTWk5BVlxQewFeay1BfOjc8en3bMH/vEtcNnK0rcEgS2/iSlQLAUJ9d4kTATJ97sbp/cuPyZf/4HdOv62aLbEGn0U8M+Bese7YnFz858pI3/kLrI9uSE4SgrfQvQ9yCtjbcTzZCJRO95qt5MJUf04B4KMRN0iJVJYCQ+IJ48Kgo72VrJ5Ddg0R2Ixp0l0+iG9XIDAhTOSFcwDub3GHabua6MgmqdBq6waWgUD/PHcERQ8WuExdQThbF20AdhICGC8jAroW8Xj9ASgzJlrBiBTR42w8O7R5/89I1RaL0RMLxoaepPsuCh8dWqmDpKLE9efeHg7v2r7909uX1znSH2L4h+cfRDsUMxYRkK3bK/HXCSBzEihJIAvoFFDyjIQ7QDFOIVhulWpbV2P3JWQJ6v8qk0RsHtOtjpPjU62zgSqT8QfI+pDpYgbyZLoPs9Hgrob+0DMjFV/xCBxZZtV2A9RWgQDA4GQ4MkEM3KgIHeZICMC9lsMrD4rUgQ1EnUBJntAHmoxRFjHvOzJ6dd4hduHzw7WknyhVzRjJfb61Uj6ONTKfshTjxuL569ePPrf///TQf7Z1vLjdBINJR57kyZaOQSAuLMkokzU2aLb7KICDMlcetj/eHFUeLrITIMBUOwRsfATZcHc1gg082q0nT9vXp6JgsHWTCndgceC6EmU+zo6rFeubJqFipLUWADIogBYaWNW4P2B5JI3kDiM8HrImPgpcTvBD5WRIpqawIS7lMFmpvCM8Tqf/QZsNZNx5NJSsULi76MEWQAihx05qQIwQXw4b0s0o/SR7RQnlQEZ2hA2R2TkfMmb3h4+vDk05+7dfeDZ8MoXehdjlEgW/qSiEkSS2LhxB3L4Ys3dx4+ufPd189eemEteWAayEvfxmn4X2M++sZTEpjthbo/C2p6SAnrM6HCMI4W1T87WbLRha6fI7VwOPrHUQHDwAcCZmhwmmTavXStGlD3B+yKkBETdb79zNz4A5BbCLqf3Pcgf0uxqjSC9i7GU3XeNGhkAbMl0nZdOImWS5B6TNFDAMnT4dCNmO5EOx8+FjsAS2ipMxDcALFVF3yh6VHG/PThycH+8trNvePjdVnNGx7Z2WnNBBf0+0Akkj49ffn2x//oT2h762xneyM0iK11VfkPvOK38h/kPIZ4dQY8LwYZbkuBqZmj2Bc06ZpGLQW7736Cqipnoj6ioaTRzoBjjHxpyv4NoGrBGSRHTG3rUWAHZiKPHMVPYR1935beuKOvtqrJbTvoIyekeUw3cGcQsHA/c5JTCojVCrFuR0kgDfiYaiPzhm1/6wwIkU0aIa2fQcdAAv+xiNCY8zBuVptnj84+/snrZ6tRF2KD6IXeVV86jbX6i4k5UWI5vX6Zc371j7+9uXNrJTIwjSSD0ChluQcqRGgkziKZqfyq7+45L6kmr1gvAUiSKXXtz+TumjgRYq4dqnWNasaqZSxvIyztrbqTtA2zroBrlEr0VKwIYKNY/m4N2+NLYltj5RJV67M/A9b/ewKOYG/4uWCiKlV4IIHhuMGVFxUqwrW8U5rG1T0t0ERSFJV0S8MU2fCV9TxcAih97RN1YD1ULeFUzpzgnuKt4Kv0aLJRzUdZCLCuG2QjWU2vjJJTpjE/eXj80idv7O4vT8+Hva0EDoiOINW3TqpZVv6TEj159cXb3/lBf35+evlgI7SRyv7rLxb8CBiBVvG7yCrtEQsBFQWgIq4uLyRJYGqafzQtgr4vxZak4SCyx9MeRN8XuJOqQyFQn2BMIN3bch7c4+B3IxujUtz8RjcjMDoNGblnDFEgsu1pwNHuszWVWiOuKz15GmRCF903bXoyllE0NKmNN5CmNV31Ay8Uf2B4TySof8gJeBbJiZAHiMwalBqhsn5EPj9dr043L7969eRkA6NgNpyE61r6EP1MlJJs9nbOL+1//H/7U7p5/TylDZdl/kkXKar8Z8wK+lqbEXPAgPuMT4EiYWi2IlCBMKjSHu8/9wSsi10SyM5wAdePBJcojByh3QdyH0gIMu+IexY8qhIhEInw0X8a2VBS5MJD4T790qBZsX1zYAQlE6HU+boagdV4j1m0VH0qkpBPmHcqmgGCwy1ZJor+4O8FT4Ah/1UXE1fSDEniSY2Q1ckVGXj68OTOnUuUuMwYpnCH1QKQlaMnIk7UET27c+vgo/tX3v/o9Ma1Tc6q+GVUve6v+oqgL9LZeMCQ/9Lyz7b8wT/mZr+QVHPBIBWN++u9NusezIyu+FHBIIjJSYuMRqOr5lQ4VkAGKwEqvz0DzViA4Cqg+KGkBZFjlIdWpKfWoO0cJk2QNX0FCsXgDhN50UGStnsVYQD6mrqJjkGIcyCXAtzPpAiwRtpkAHLD2cUg5zGfHJ71Xbr5wsHJSXGFSZ3AOhZqAVQGmFn6/tmdW6/+b39K28uz5XJDtLHoJ8hAjfY4+fENkVL/U3LXoPhb0EsAvXccKHIBeW1sAlXrnCddqQm1KO5GT4WwMGHiEDvsABkI/VYNOxpU8bsv66jGWusZxt3gKWr05opuZ4JghJQzqobm0YgE3IOQsyM4A0Z4m51mEKK+L8NnNVQGZR9bPGQiA97OygTAQgpWRgjYgTY0VDNio8iQN5vh+On5S69eWa3zWIsMHAZC1BOiP1HHfH71UhrGl7/9g+GFG2uRDbG95mgUykKjcIF76wGXMKo+uPav9gCxu5+NNyzu1YrpH3UeGysPbq5HTMCXJUsORJwxHKuT2O3K5m+DmnTPWNkzAyjZcYBI13sTZ1NM7lgTXHHCiBCE6h0GX7PeaeNZqoyzbbg+hYWn4SVf9lfPJkFmgKjXUZG40wM5zAZWfwu3ew5CBno/M1Nl+KSeqN5CZFQ4/PE7rmdK+nWuzqxk0qpzkTHnlNOYDh+f3vn49d39rfPzcWeZECdE3LO7v+Vlv3R454Wrb727ODt7dulgLTIyDx4DJZUBXfeKONeX1JRViKqgi+VWvLN1cQgiEmbLUWmXMQR/WDWGRwQMOHHDU10gFfhxKg98QT/Ho1wq9JwcvmUXPw8KQQNSSfNApPmgNPvjgL4A+iStDCCtksmGAa6SNeS+VQWVmdqs5c1qPPUQw6btdBmLQjLZdn4oZKPp1Khq+nJ5DxfFvFi4fX9ehUWWsngEk6/0ZXY0s9CYecyrs/VwPtx4Yf/9tx7vLLfqQGhHpdK9TFTgn5fLkxtXX/z2D+jy/qpLlfyQ8X7St31R4EJihMfokCWutQqaYuVPkw2xQND02/a1NaETgXu0keZgZM28Gin34EbIkZGPpVNh/VYJACxv2/AHDB8B9YezORLC9oTtBCthz0hOtJCb+SVwT+OJ6h93Rr1ITrWqExsIAYHdAJYlWBOBPoBZfheD8KTBEzAb4G/ltZAPmcxZ8KecIoMnACuNU6gU8uVEj56e3bx1MI55zKRLWJceoJ5JEkl5KWpHdHb9ytbRyYs/+vH65TvrLPVdL7mAno0FqTvLWSizSKacqlaQzJKovPm4PgDXPASiTC2FcqGqX+p2Q4So2Y4brFp2Tv2bCvXQXrM2BAOSoH0dZq437lxIZ+zUgKJ/BCPAfntILQKMmv2uN4VA5eMDNWqevXPR2AJFgZ0o5/HbYgcczRKVusmM0h5R2oP7Jep+YWtiHw3KNvrab/Um4LYoPq/tsF6ZQCHXVQ65KFozAjnzmI8Oz166fuPgys7Z+WZ3q1deTuRhUOKUODEfvXDj5g/fTOv1+d7OWmSo4f8aAwVnl1rfVwuhIf4jMRWg3stsJBSyBBMLYMrDsugWkQBFC+sbNWmB4PqgujU952rMtGNQmRFALAFYeH5XwLjf7wTmpkwtAHqr02DURAGjVgn3phfCLkKnOf6VGgckvM8mG0CumKGv9N5EryhYrdi4HGAHBDbA/lMTLIHx0SEutELd32oBzBQIWbmovpq3zJlcn2/W58MLdy6fnQ8hE0LUW/CHmWVrcXb54HPff4MuXzrnVKFPrA4Aj57tMgtQorQ1jW8gtjEwhAF9UYfSMM7Q/aZDRRhcSfvW1UIZPS1zw4WAXIFwTeSqwjRn25mJ02pzu0Wrr0QvWK2GLjcERgCVvaknPRPqqRj/EdiGhlASWE0B5krFb9B7KdA2zbsHW4G4lzlQViAK3qEJUj1DNYUt3W/sQ+semIscZKCiW7siPqOOn76rgPFm0RNg0sXwcq1KlBITLI0rX8855ZTy0dOzy1d2s9AwSjKNJtzX2p8S/7l8Ka03N967u7l9Yy0ySHnbF2cRi/zkKgYk9RVgxf0V4HZG5rxz3W1V2S8gqzct1UNm71chmxIeBEO7tr7NwyfyAtT8J9jMcvIiLxXI9QUR9pLOKgwqHuygrCJRb48V0TAna+r4AknzwCjQF5DtwIYQ4npCE96WIBmAWMGTG2AB7hs7EEhH1NlKeFjxna2NcRtVeFEGolCB4Lk+B8QbhStYLhwQKFAthFWvywolqtJinTGciRJxId7ClEVYeJTEksfMKZ8end+6uru9t1ytxp1lIo3SJOby2i9OREe3rl9/693+7Oxsb2eT81A84GwZgJACG40F+Syw6g1jhg4yF2bXJvMBIHjvb5AnjfhCD2qAn6yjIkdymqQijioN07flhJj3abL6DgsJ+hsCXJH8RM4TwucqRW0gkmYOtKcAG+l6w42FFm7AGugFeOqgt+oc52012ZWATsPo5KNf191fGCzL3fK0f5oH0RIJhhE0KuXDSiJ1KVCCm8yOCoMWiRVHxBkzY82Orc834ybfuHlwvhq0jJeEONX4DzP13dnVSy9873Xa312lrsZ/MpY/AOiB3ysnM9CTmDNAwVtoJCGbJHgviPajFUTAWhqkR1nnWiZIexckB/ilQscSMdkUnkxARiTENiXfLDapi2UED8hMMHoGR4MdprEpAiJo+olUhFPFY72Ndg6EfYDb1PM0ul+jQDrnHd0AFLb2Qhz0ujcLioZCAC2s1tTwK1P2kC3TvhWgT6AxY/xHYL6YeGI463aWXOtDx3z67Pza9b1hlJy9D/vS8Yl5s79HIjfe/XC8cmldX3VKFvjPQmPWt50qCyoIrtNfivXJJAkWiMSu0kVHlUmYSuHKgoyq175h9A7K/NOiYEJCQAeGra+pkBgmzw/UgAlycyeY1oLhY32lJBItoz3hxgC85gNYuKlJdZGzo4kdmO5VuyEqunrLNqcEqJJ9cPJZOzKEdAIvCkB0dwIEDGP/JMyU0U/QVUH9EuowgALS8xjUwbC4CeJ6eWBgFhfE53F3rvYOO3Milc6sd2YRjTFLJ6fHq2t3Li+3F+v1uOxrnKpPTIm5Ezq8fmXv/uOdp89Obt9cSx6ItfyBR13drXoC5E5wUdvZ7SM8eX0eUABZyjIUps9FlzwXN0vgzwZtCZlYhJGBkXQEmPytKWJ+s/vKOpjte/gqNNjZtH4UKUVTUt8mrU5CQbnej4BsYW4OH+dC1OPtNwQJtC4gvrKRcqfVGSTdMIhDkNQOmsjADExje6q01QyOWKATxMzbFAA7ECovEjwzUZCEHBgSPHEmC0mQx1cwQcKSdYVIYo2HCpel1Es8NAuPeX22JqGDSzvPHh4v+4VoJri88ppPr11++Vvfpb4/7/tNljr5SywDYEymyECpwCmvv1a2qv0qlpq24RCykLlr9wB3eyYTGFFHHyZDaitWRmKKuZnooBXybapYUS5kEwmiS+rBIqr3DCbCokaeBEBJK+rfg1HipsHPObEKExlQeERCRW4EGsWPexgwB4hyLqQABsZIiGNk1QW4lIPAlDmQmsgJoCRDv52ZBc2PEaGGEUWxgyOqrZc87Tf1jVO1AwXunEpBhDLH4miMkpPQkM9P1lev7z26+yxLfUNwz0SJKW8thq2tm2+8TZf21iKl+HnIJfRpfrAVQXBd7VAL0Wp/Fv6D0U/xOo2yByMpAejeQJxyNGQZk2JREgIpUhISvkL1j5URbeQH5aGiHzNf1QiYjOkGpPN0/C3OFJff8QdpxhPlUAVF9Te6IsAIQLU7BF2DRo0u5W3YCPeJ7xsRrJ2tLMRSORYAFec/3t70vRgRUZ4SfQDHSXMKZ2NgC2Gb8enr28TqWAHeircXSoPOjlf7V3cp8ThW7dWXZNhqf687X12+/2j94q2S/xotyZVLAJSDDBj7r39tlVEgqBWRQdlXvdFw8nlJwMSutbFov7aEtQtrLzGsixslASiQIt271C8WfiDqhoezpavV1NiImjw0wdAA9rkfufj7oPINOqR60F0F6wSHlHMhRaEiG4SBcCcWLyiOG24T0Wwi1HrDxp1MEqJ74JI8ETuU9miigygweER+xokRyFlSltXp+uD6/vbOcr0e+q1OiPsSAD27evng3oNutTrZ3tqUCoj6ju5S/sCY/xJl/17GbOgt/2heWvvGKH5prV6vkkt/B7U9tGgiTIQl1RixLVMm7LgXwJ/q3YAWSd6FymOiGLRlpCYd5UpeNzFBv7TIZuaZ+3E93ojVxUIhk11B5atZaNR/IBUFczJD+hsURvRHNMvMt6DXbYSjRF1w/uCfIBHCm29Ek4gEwv/BKMwpLCqupjoGZgSySJbNesibvHdp+/FHhztbvQj1JQx6fnn/tT/6Ni0Xq64bxjyQ1n5mJf3CUAFByv6jAJSEnNZ7uhEgtWlCBDFYQhkoWDflbbxaZdjFiWFN3UiKNBZUz6OOKShvCcGF6hhPuxD94MZJUIjrV5BkJnc8AvTRoXdJaaE/SY1NJGHKfJDzNBTIQGb0aQ7NQbuLKuw5++DonwrJlPngsbEQKKbPWv42YwpQBi6MJWgaswxMsjeLKRXhTJnzmCnl1dnm0qWd++8/rVEgZpbFYrO1deX9u7S3uxLZSJkAWUFv08FyxuXcOJO+8UVdEHHHt2BalT1P+7IcNmH52kceEQrrLMPAxxCpDmaMkIpOqG86zvLHhtrW94XrxR4vgdGJ78tAwLReAtj7RWdrdswoM8cpIM/3ea/ityAD7u+6SEyJChmzj+ifOAnhKjikM8znIiNA7jrDyV2olIFhwFVB4x0DboB3LsSGywLlanUUuDLK+el6a3+biMeRiKhPIpvd7W69vvzg8fr6lU2WkaTyn6xxz0y5DYD6u1V1oWz3eoWIEluX1uB9Jurqo3NmSnFCjMGvaoh52bBe93k3rDUhjmKEpjAn18oRkRBjD2CFYDM4BtMF3EnDTyVfbwGfSUiUmrEKwtBUU0fwItb9y1DaH4MwhjKvxwzfTnhOIUi1U1U3/RSC5Co/itOF0tXGf5q0g13AqZEhORhomWzokAoZgS0rx6s3XBZVF8mSskiW1dlm98recrvfDJmI+0S0OtjbfXK4OD199tILde3/+lvQzxAAJZQBUxpCNfQJAZki4lGX64ajIgt1bDFNUOco2YH9hzbarZWWqPFxU8D+rQLUwzikLrrDxFiNXj8IjlhWwZkV1WSZ6i2Gh208AVdlFC5AU6QbuiNksSnqfmTWBJmp5vAZIsRUklsKO5EWu0GdO/rBVhRhk4uPAndlao4oJBRmLBvjRtWRjbUUDU+LpgLUCBQXKAuz5FEo5WE9UJbt3a2zp6d94p5JVgd7l+49pJRWXTdknfZV1/pknQejfjDMa0EfAB4beIh2gYf8fcNgKrhUmuhbhWdMgfEMCa4Cch6FeysDAFzfADxW4hK40JSR6PsoStSoetTFClm524ROsa2XNpsBkIv3SbvdmAKQAcE9hk3fuADW5HFMrsmoWc4D3az7ncYIyuZzj4Jbwlm/9dKGJAlH+iO3SwZpRqbqI3S2MlMSyVWDMYtkoZQlp3EYN+fjzu7y6OFxv0g9cdrsbl/+6D5tLdZMWgEasmDBAiD/gQ0CgS5PhaA3MdANUYcpJoAvpD0XgF73SNXIYCLEyqGh+pnreBMnDZ9Ft7iBO9ClGhHyU4l6XY2HHcVowpp8CDlaszDaqCZF4HsXgwn/CfDylh74bLQ4ZM1YJMevQK8ZrBXBM0AH91dlDH3fYL3aBzJGZE8REmxB+kP4zo33VPdYAkpEmLNwMXVZKMv6fLOzvVXA3OdFn1O6dO9B3tlZZ9HVr0SNgE8AGE0SAPcTC8A12ZJESx5q6LPBsaK/BumasoSqY2OKuD6Mi4FDLOh7PMZD4tZAdO6Qdh7wjpCsFWrPaPTGxoAD6Wd1SlDqjDxhrk1xwHOGRq/X6PtWBlTvC6BK3D1w2ZgLuVTFb2NBzTjOUnyRGaDj+ZW0y/yp/Fqwxy2I7ifSlyG1zk+VdQ8xiCWEjYGy3S9LnSZfp3VoNmB9vtm+sssdj1n6YXsrDcP+48PVtSubrFq/LP1Zkl8l+JNJ6rvu2PNfKgOuJ0oIlozzkCj02bJgtW8Yh7NyUeZIllpNP/+V7WccRrWPls1FhdaAMWr/mu9R98AEx/q+hIIA35MsWxSVkkMuaggfmmbsjqM9K9IRAQof59SNNbDvAzqrxkEdH+qOp/ZB4Eyo+1tkm8kR1fogLX7+9maM/7TQN1lUOVatFbSRXoXhhowhJ+W5OtOZS4GoGoHNatgh7rpuXG369e72paOTxWp1vFxsJNsKuGPxfXPMABCN4swHa+BItS2J1GnBkfoDuSfJXCJClCuxUJU5xTcaEMzLGssq+6GB2QfdH51g96FCbgvZxywpaoL9ZAGoGm1VkRAMrFraupY1TvAuk212AAMgGuGY4T9cMT1V/I42afHXqGdTHWICEjlPkCIjOVoN4acSPCoIXiPRjTCAkKFVsqdqzGW0x2ClS0fmUhrElWornxmGQbIsthYnJ+t+s7O9/fgZCa26bihFEFmTAHkyEV51fwZ9IAqpGu70kWF7No1alhAVeUgnusvsGyo2RnaQ/zjuxfPKtVzCzEh0RmMYdJIMhg21ruBjgfRQAHdtqIYYiJYWZ3pMVo8NYhYlIKhCAAso/obfq7IFkAS8gCKtwWJpETmv18WLglTD43Q9JzMoVH4etrIhvEq4RJQ6gpOAVM8qiaCp9ASm/9lbFqpbdGypDM2Ss9CQx01eLhfPcu7XO9v7D35CzGvmcdQ5NNnq3iwE5O5vKwBUFHk0apkoiaa6FLv1KdmsAZRIeBLVV+Bp4p4y98uxjakFV0HsFSMOdPHiH4uCtGU90dMgqZEfB3isOAVBUtmINMlUlI9lC/25/ch7APqIkhA6dIy6PATITveHv+IhClT2UxKlvoRkidxGtIuFiGa9YTjJRUagji3JTJ/M9JQPk88VLiwl6QotWhORcx7X43K5GLP0uUuX7z3KW8u1h/9lFB4zFD7Yqv+4tk+gQGyqgpgocy2HrhOi6hwOjQJhoHNe/RfJ0dIG3c8uJ0IE/EexaH6FGQTUbwocZqpZ68KPFPTuLPxUJ3iSO1OUSy0hlXmPOWq8NkPdiIPgl6jKo4KEEBAwhYZtG7oUizOOqUJajxNCqSBnNi4MwQ6RHdKaGt/Dfjn41nvFDIrfsX3VdB3MEZpqEi1yYSr5YFVPiun1atjaXhBxL323PDvfLPpBU2AwBZ7L5LH6V2ain37/9XmUBxf9WlcH0jkqzew4i4ca+OIkU0gFNKZAhaOecIL1kASI6tnTvwnLo403Al4rYTOjpOYi5nvDHhsfaTkWGAcYwzldhp8DQ1Bo4NRx8R0IQQSrA8vpjcDxJhiiE1Aj+yc/bfsRsCt+F3a+8K0qdPRDVJLKfpNVnHatjbX/onYqI0maAKUQZnB77hag4ngcxtT3zNQvT8/2Hz09vbS30VffjZlybviPjFQ96VICpALgU8JVpoUyUcdlQ5JN+CJLyyHnEWHWAJHOA8VXz11Ae1z3g8NQjFApy9E9qtJLHMzfqK6kCJDYFiwoZQqArIQnnMr1vJ4WvGFPG+vpmto4GCKspIMxdFnARU4imzHou3i4WLQl0Kj4g4ZmfbGzqXlFZmBT/nGWR7X1cHUWQWVKBlU3XeLnMktjAkzxWaeUyDrbR80CCZkpCRFRLmEKY0G0WQ37l/b6Rd8nESZZpaT1z1D+2bAg4okDUIP+enUFZRZOqqtzRSS6sAKzuL0vg4kwz1rpk27DbDKiLNTF9DCZb610R0EldrkGY1FphGSKg16Bji01uqS1QHBp5UuiQ8RGFScl1NkvBEOLgy7+eY78RHsAX2H8R4HoQ9D+nXieBl9qhAF5joopXjFQLJcT1hnsqPeDmVILUZRjM505boCKCFY1jB1Zz0uudUIpC2XJY96sRmLuL9990J2dr25eG3KG5W8R/bEKSLU8KmJyFqRrddQn1ACha3cJUVGOgI5iUBDHnvwyLDPgW8mGil+AvjoD/o/6BkIK58hVhEyfgw2d9vCcLPlcZBsGTNO4K6ynt0x0g3zHeO1bW0kHwE4RgPjRBAAOE+U5E2lDTRwVv0teUMrA8tv9yE1av9nkOZ4Wrg7gYSLKJYSJGiEw/yANUAIj7tRlewcGkQhnySxJZBzGLvHO7nZfXou3Jh5FhkyF/2S0AyKiAlAeJ4MAkBIh7Xch0ZxnNopiPq5ACAitQZUWtQwK9oBpkArCY7G/zRlQ0KtNMPrOQH1I1+pBCFcXFgTO7AeEREEwGBySkI22YSjjZqYaUA8KMuq09lOG3eLdHdwBFwl0UQGhIBUKcFfDEnDfKH6Fb6D1rRhUjOmxEg5BukVQ+ACCBwJgF/DOMTfAEDEbx/YOt14uAcms1LQiWDarcVhLf/nD+8S8YR5ztpKHMVOcBFOfxhbERfVfb5IR0zr2gPhWEggdXDUdoiq5ZUTRPlhM3c7AaFWMQXlvSS1RiAbTepe1syR0Kbu4tGVBXuDQjgF0fQiPghWfIUIzyHcV6ShAmBPCHyogwoYxJzEwtbC2bwJNaphPoD1qSQzi3szMTHCC0fGdp2FgINSS1BHM8KSo9nVPs1rm7E/5WqcHZC4vtpD9y9v98ux8ZN7YFLDKkepKb1UMQgWo1GqIYARsYICuhKmPpUeYtTRMZQOjn1PV7vLDIimQJWXkJhheK0peY2OmwJSGkAfjHZOm75HzlP6qVW/TMqM206YVFBVOjJG6mFuY6PzpaMGYCnwArEbCIbY/sCDAtFmMCV+PItHsDIaiIijIA/l1psoebQvFPYoYME0BUhhUMlsSHGJSJQN6B/xgUj+S0J+0bMC4ycOGelr0Q2KtgeOcydY5hBnA6gwQCXF2H6bobk0CFEkFR1YVPxbGTcmPleSbe9CU0FVJyE0CATFhzKoiE8NBVgRqvSQTxymkgtufiUtQw0AWDJ1OBAb5Ie+dMGH5OfrKRTUgP/IDCTtN05MrYTfIaAfI1rud0/RzOYFGKlyyXAzUrqmQOE0Kl3BBME3PPrOwDTCVA9nf3hGxj3VBpKRZGq1Uvsoi9YWqugRXlnHIeZD+8kcP1n0/ZBmLAyDhV3QFOCuDq04wIFPHRDEcKT6oc+8VjXXqBlmzquwn0wOc7YhwMiLUZADU5Y2DQK7CqymsLwZR9Lf4069w2l2Ts+IL/uoZMfITvIVZ6UIh0Tto6l5ch1sDAD4eIGEDDIKD19FW/xr1R5IT3WI9owledJr1kCBaLkIuli3/sWE10IMMla/xLLUjox8cI3YUVJxA9xbXtKyIJeMw7u5v9f35akgJ3v7Co7DOAjMHgMVCQEUGMmXVeiDZTalz2GBfYIwj/5nxjBXopnwsuFTMl2WLK1P0w0nPjITEx68NudTDYxJLYVzCN5B48SnGk3rSAHRQ+eWri0h/Q4e0J9mXeMZvgxcsDkNQ/P4FQDDwkDndj140AXx9NM02qKxNKE30s8s2m6y5qEYBsEIJNw32KCa6ugPjF0ALoSPriFq4W7R+iblMExNRSiIy5mFFPXHaEHn0swl9QhmcVYDW5WkzBGD8ptw0SJ32XjeUyrtdNgRL4DZmH+oa13WGm+jEW7cP2p4IhSFwJFF2T0iBnF5wQKrjj+yQ5phQrRTIj/iiKCZFIFmtgzuVB6AIILM44Egi0AA01sAwWpu3PFsBCzsD1u0CM/bBjIhJTrAbjfMwZUrgQzu79WdF3R/NuMoedErbpUEO0Bmo+t+qMzMRU84kQ+656zbMo+t+XfRBZwJADFQ8kCOU2TqgyB34oAr0cj2zAEKV4ahsRAWvit/9ZvdkiKjOc9O632ofBFzn+pjmQpDqXae1FwWC2rSXsiZqwpfC+iDe3043RTPSel6Ujzb/RXM/UitWJN5eIwJIp8EbEPjWgBmQKgY8UYIR6RB+hTqeoS1Yn4bZGymy+wnndIElP7MLXjAC4o/baFk73outvCm3tLO017d1URYmERbKlLNQpp4X/aa+BYPr6g+w2L8o+1cK5C+ENBEG+bSElKt/G3jB8rUA97Bu3NQB4Co2CnSqkd2sZRQqeEaBCPNxTLpQF1nVtGDvQEa3ERh0fuPKo/OBIBSJ0FLRMZdTg9N6ZxpGwsADsEE8MFriTiw6vi3tmdX9M381rBlwbPsA8RjncdoV60ApbqMAiG+YAOjNQ78gJYLez5bhb0ohQqqFictsLbUAksecFtJvNpuRUxWAhvYE8iMW/bS/freqMsVeneLq36shkOEoIxIrB2Ln8S4bphKJSl3HhPNIWZeRhSQVFmLsCNCkhsKnXwI2W9VSHgkEuuFC2iysgwXoLxdD0yExedNct/2J/q+bLyRBiDgQD0S8a2PHJep+JS3mJLTOMcAasQ44VgFsFbwJD4LEHgV1v/ZbIEhwjOh7CqpJBRLE0C8z+gQ1kQ1EpspJskiWcZP7zWYYqcu51j9bHYT4InAkvhw0oQwg+h1ownqvSkjI0SwQ/Km2yqmg+gmZOBEXzlNwphBiTxcoTRKm4hZnyslnxkh9/adC2VDi/QQZQ0C+WgyThhDYxxV2i2GYWRCiWBIzzyQ+vRIv3UaWZjAPRqAhQKaBo2EQQBLp4LkFCGwjMpDnWgOgS24cLggcuXcSzU50f8ETiORHAeNC0wq+sgmZ9Fs5AN7o3JQtKgayVB9glH4gHimNHvc0I9BOgjHOk+FWzQu12zK+UPkMY7YLCz/LE10wDVLFp+IsW9ATVHuQAanPLlREEPK+7tSKmPeK8mnWAMSjTGmougUmQc4kgcElEHiNKohay0rLTWRpTEyQxJb5+PacD4BAFz/B1AIE3qJYblR+3Ame75yzG8XJUU0N1gkR7z4OjLuB3pwQtx1R5EOvWLhhIgpew1LyAGSQq28Uzln6Dfch/lN1P+sLT9mg75JAIuXNkDWjUgu+cA4kob88YT7RW53EggqScl2NnwuITQaySKKEpUF1aDXiZOHesjAYKlWJSYBGg7i7UkqxiJipriunnga+4d4tixmKas3t3W3w1gLxYckwOEXcIEkW1L+YgfXxD5qw0fyB+tsGWACDcw5KN0J/xg6APzBHh9xETLxe32a/MWovAZwOdL9Az0nbkQTVYtYvkJC3hoX8CLFwMohKFpFM/YZ6oexhH8x/4SwwK9cnEuJsJTyGHFFVKGYsLK0b/prZZWiArnBFf1LZyEydPohUDGZ3G2gyIUZJvFiUs4K6KQcCANcRhJSVYjwzKZcClKs0WP/iZPuLikUhFCsaoIZ50YBplMps+XzBW21UZUOE4oaSH2uVA++Rebyasp9KRUOHaL4BCN6EMkUB8OdCVIn1EpBV34ACq8AsyX3SSfJdSN2AksuSfjWkhdd+uimQUAfBZgGEqx0gCjJgA9wgG2TAc2Gsa5cyW1JMWLhkKrigH6o51FEmdsEgtRuUVGBKg/p+BONXxm4yVXUetL4h2oJFOGWlWemhxbT3MFThTqaDlXbtgnTKFDHRjyeGLfQu0foj9iMRChbA5AShaQISADoDVodppokwuBsNRCsSpDmhsr/AmYKjEp/cjYNqWiF/ZaoYFYpZzbn8o/k05ZXaRP35QF3qcgb2n4M/UG7J3pqItdATA1VKQlM1E0WCA8tX9zeLEHPnmoCrVWL3FEUJT6eZAc2IgYUREs5F2EUtUXWkuGQrqjtrNsHuVYNoZbl1MVfBlwt16FffFuZ32UqKlfbDTDB0vXxSmZ/UVsuWCfCbHVVcM8FNR1DAfwInbS2AAUvFZFbfNwpeAN9yAfQbWNPMHnhUJF1g9eKeYMyrSDMKA9hCOwGqpaCi9EOlsDB1RLJkon415N2t3iyAiSVWwpmm91/bA3UWZB1dQ7GN+ieFiK2M4pzHlXpmSRr4r1UbYkEV5EtQOFQvV2aisSr7qt2rMJD2I+plW7ZTzVd5q0JAaqU6eueC1XAmR74WgbJ7YbQFbcBnqvOnYqDoh7aq7VEOQOujJIBXEFSsnmBOH89xG5AKwmaN52CXnRMGMDfA3WBDENMKDBcDf9EYWD/vqOdUGELSh4nghV2a7OqHTJI6yQyvua7qv7IgCIBmCIBmOL3gdeyRrCypKk8selOG5+F/oUCclGylSnL0owlfnDNg11N5EKyvtm8LycnEXBS/FPeozl12lY9ArDEglT90H8wO2D5k/3rdxui0pHF+7KRJCRvJ8CciVbBAjsRVrviGbzprmoF+KxLGUkCCgkjMmoULCE/Q/W6tlHf58zm7QIMV+QZsTN0sXWWh+Qp6P4skSUJZpCemnFLOyln0fd+CeYAwD1gzwXpW5R0qcRQYv4dPnAJJMw1SGo1Omq4rjLyQHNXu4ChTcSE4EyfmLJzI5IFNqRSVXb51JoKuMHN5fyuhGADjsTkB8QVIoJeZuebFxCrmVB4EeL8ZjnYY220ir4cDQuySgKQ/2gRTtA31d3WrtuAi0jLrpwbEixqDSJnyzNlm5SGKBAotk2TDltG5OegLBZKv3FQ7myFwAUeLqlGSTJmoT12XEwtzDq4wYRhU5wHrTHTQv6SEHJ07we25xR1sp0HfnQRizpKoECF1IaprK14iKoaR+lV9ag0dlIRaPQrysF4YV+OhxiOM0ECySywK2yx1Wyfpwwy0kDp2alTNAGu4U1gDSxcpflVdccCj+kf2Y8bBKZBumLqfwT3pznnGr4I0g/iLTMeMyjcS1rTEQ7za2YUBhlj82dkf1lSPjRMAL5Y7GonFXpZMSWgYqBdmSkmYhXOtfA4OetX6MA1AfL6KeyyqVUsdfBUDeEtSfXivfbCPymfEW5LNfdGrJv+2lgAV5xUcYiGqkaLKdkQSFX+gLlFRZUZjQaS+sulbVoKYUHNbeF7Vv4q9vg2y+jyREXEYDvW+DOI4VPCvKO+PNgHcv6j+/TMIg8FfRcaUrvkI4MA2CDYxacAaCP2McaD2/A790LI5pDyAiahLOUqCyqtmDh34NKmRdqpTtRkoEGBBQpQzEXE/dCypy6xVbs10eJgGICSSOTPagRIgqflgtgmP9qhhaTeOqTEjM06N9J26EkSCJFQKmcUREpGSERPkP5XPUKgsguinK3tNiqniL5JX9lfUajGGWhilOjUjps6uTUFgNL9Cvih6YE7KpHxOgRome5dvUPsUh1H58qz6dyokUQCMV4sJgBuHqPsvcBKC9Zi0JDs43E70HKyZ2xkzLnXdlIj7wH9Ewkft40gfMQVmpSna7URJ32eXWYT6vFhKx8IkDDPXqyegc3/NE6jbnMkdX51vaXNFYHlacwIVeD6jN6yVohGUQGlYyh0kU/N2H1zeP6AZMYWSlDdDWbhT7IWtJbNbnF32ZHAdzpnAf4ZXvhsCVdMTzoxxc1AAVlbOIqtK9GiR94WRXMIfwcs1qr8VByD1jTA4tIHkqBg4RxKTGvRin/P3AmEI30J7ao8K7Aj0uGLOwJx1+IARkWk9gS4SRDfFosUoEfpF0l7OJInGkfrD7eWNxJKycNHuko0FUQBe6wPUWxLzBOpig/CKUvVZKb7YoqDBHAAVlVIDV9JkRJyFu5DwYi+VgwCoer31bKTpYWM4NSpaLmr40ZQV5gGkriHjD1REooi0rSFa/rHgJygsjB85HRKdNl0G7CL6P5UBHEnj/6ZdyYyh4Ru1vyt82DANGuFLs+BuHYCW8Dz/WxCtxgiISqaZILVVRgqytdd0L8PBoEZg1qpXbJmu0h6rIerkhTBCRJlXq9znzTktDyRtiiIuLD8TZ5gJIOABSyDepMWqUOCIfw1t4DpImSDGVsUQ2H89IDMliOsj/yFnTalslCiQgN0syr5kA6IRqJJgG1SXtmZmJT/eg8rV3ZEqBsNXYrFEWOFqlljwAJgWOjT0dc4PVgsKfsec7jchMEA45Xby4bofGD/agch8FIazAjBR4WB+piKBd6cqM5gC9w2Y61pxwZfBifBZLAumsRW0CcgPTTSsEhkNbhncEmTisjhyIt703dZS+o7SKAnWcyCyPADG/s0b9mZEsF6g6OBpMZhWX1prwblgri8FOAwTkeXC0E8w8qN9J6XAiU0XAv9hdxM9IlSgX1V+Jk6muIFU5iIMwoyegG7UlJivhghYr8oequKYa69jAQbm712hsSl0HNBqK10EACne5cD1fVcUALAc7hq0mJ6Sn4tU/nPpEPAybwyMz/0Bkwi4YeBy0eCxWFN0gk3jCGourIar6NIlchTeI4tw/3h/9zXuKLFw+bV8VAv0+AvTTqR+tPfHgTYzVVnNEPJ+U+Rc1j3rmDOlZN8G6Ov6EZYkVhtUXN5aJkRc3QYjVMykESGFfvGBmIgy17Kk1NAe95KrenfqgmWc5vVqpV11oCxlBt63EHEMSaPmb/eCINj0eAGZnqAfuP+U/BBJIw9uC1wkooau3+eIbyI8BB2AKEtBJEA4g5CUVpCxMRnXZ0TtaXeg6GJ4eKun1e9MSKxo3XuunGwUWq1ynw6f8rWb0nWUchUA5Sxa8unkJ082zNyLsXdLT5hi1Kf1BK1bA50zQBYAhcWCYDEsRv/Y7jJLRbnWPoRZv0Jk7yyrdIjNDggLJ73BTFwTYcbDYnRf6Y3Euggqs+BYFTUuAxSyxkTNmKCKj0rftBoSIMS/ggUbgadrVEcNI9AbZOfNV5O/ZEsCIpoR3zMOwCwpsks3B04oGQoYGDr7iJUNOfQe9AzG2rAPCyK0BCdzJu66Tb/e2R52tvh4I1xLZmo4yMKdbgfYWZAJgAknOIPKDTSoxOoDwHIVcbFoSxvX41nNVraCZxtOqwwVMn+gfJl0tkD9qrJ/z2oJiduB2kC1viUWqqEhtrkI1q/ikhCzYFpApw9r6l+DShzWlYahcraLUiEgEWjvxbrYTAEoeSAPkReJNYkMPqB5yn/m0NzsnxeepjHcaZQTU4/GN0hps1B8TMJTcOiFpvpNlJTHyi/V1NVaMA8Dj6P0Z6cncuUqLxeUBtG5J8JhcktdEnSWBTVjxkSUyEg4qkBwACzg36wORMUB78QKgVxC9PUZQH604k2d4FymQWaikkgmCiGgwP6N5LAWBWmNEJT2e0Wn1HywilEslKsHsNbcQVYYNpRD4bmB/rTMSKBjw5ZKRGD8KBLgA5AxiqniD+qZ6KfheNYnnhcY4NDQmPwQF4CmPeFXrv7FE162UDbSRJpsomik0IPCxJyJxywim56Yh90tPhVJiVKWksllS1sB4tXPRBmoQHb271QL3g83pUOmGHw9rGIHmHXKQnJD4TnwAn0JhZ+c4OaSp4SrsCeveXb2bm5AlQcmgWKhZDJgtCfSfQIKNI38wMGQKiYvUxECn3hu7MjuFofXDIP4R4UzO/jNgzTigXagYSNRkUfuHik+SZCE59mBaZvJ2eCM1pJIr9EQDCbxxR9CJzQ9F/Ne4M+F/EsmIuFhYEq5P19vNutV2lpSOpPiCidq5u6qgrawPgMUG31FUkrUsO7RlKKQU371jwPKC/unttq5gtPlRLVyrfZR01HTCMVsMUH1W/22SkLxNkIklJjrO1u5ftQlWSwDgAuO6ntRYZo8igdVBihkFXR63gBq57BzwzmHfWWcpmYk7phR/7DhwuCeM6hz9VnnXIK2mW5lNzNTuMPGRCQIp2Xa7dsDij2pq9SJMaSgcRvUG/q1Ph+KEHLuRhlZxl4yrXpmWVCfJCUpRoDx/Y5AePR4/K3XildsUgHRAqi2FJMNP2+l7HHOF6sCqLFRc3nJEmTm9bIGfCrdZ4/5aBqcmUudaSbm8q25vyH8D9h2Qs/qJ1StDy+MVDrEyu24Ak41U6idfh7iFelo5p01BzJk3GDOBwDqr1JAyoCgQUtyosNKohUBE6w3pqOxAI2/i6QIdJOpWHtExxZ81K8dWWYBTRgil4TUGMOZSkgljWNeJOk3wpvTk3TpCnUdpZE4URprKQRZ9Zqh0eyVGYGQawDdBhNoDR/2eFY6I0qXHeumS0mnSoJ4lZhgIvGUMOh7JQPB+EyqgNQgqHRmIhZnRKRugFCZky9MKiKsFUutuOA7s93fF9E2NRdpTDF4RxeqfBAGM/wS9rjqDIzZFKfCSqE/Cf4QTeDrLKh8GSKhsXE2+JrlmGc+7YaKIMpDObGGaQiewqQkEiAgQk0kzSIqLdHU+oEhJ6FBRHrh7nS12l72tOioKxaAhUmSSI4LMxOFFWzFKBDD2gd2SShrY4CjxU3EuZBKCFSPGp/xBDB5iNPSxkalylIoheFgHkD3SOK6tITN+lXLYN5w4Tw1AsXA9aNaVg4EZU/6Okl/HzFYPLMmNlDIYMn2t6bAbYUrudYIBB4U6T7aAaU9Zh+iHZiLBT2fBV2g8lWanmsKjH2BJSFz8Fz4gsbE/kAGeaH91Bx909Ololl4HJPIwEL9yP1mtVou+7RcUNpQl2jMlfqwLuvfkJ8yR16n71bS3dS4iJdj2Fo5qqIMdAprIRP98NilRzIxsfF79R/qMlUW5zEbJJYEBzvLJaZEYrpfihugul8VeqBvIiYPmhu2nWJmweL9ukRWcILd4hGh6xsL42YGUi4YaXQAHObz20ZyzOUlACIVi9oofgltZi2DRPiCULkUZe//iQXQz/q2CjNTPu4FrKSZU+c8sbts+q3rXVWVUKRjRKjWMXDaDExpkMz92C1W5yc7iXh7i/pzSiwpSSZKWVmJ3pVRII4zwvy6cwbdFpNtuBD7wbZHLMrJqN2DuQELQLggigDvr9pdjQA10c8S7jT2n7XGwXJh4oifyIM5w6qlXBiKKSDyHFnVAvVua5IwjGLZJzaWs5rNBx6FApkPbJtqJ8Ol86JI/ZHxTxQ/+ACA4HnZcHmgylSnF3IZcKmYmA4Dt6BIe4/47JmQeQIqFGyp229DkxBnSkOm1I2UqR9Tvx7zRjZpb4e6I+oSpUyJRUo4iIgI5NxqdqraFxUy/2EFsKeBKC6koICuyhKYj0lFMIJQEEHufNRxRaoDsx8nYVAG2qM3lR30pIKh6expEmCyRoq9A7OG//W1wN6sbGWLF/kYQh0UkJ1GdyD2zfZrP1gfOdFBI2Bc33nF5CuE71Txgx9xIR26yCAg1oHegFSEKLtaBfJ4LvQImDVSk94oCQ32SAg/VjiyLlBQAyijpGGUrcUowv3I3bCR1clxt3+T+o66kbokWR2AVKYomGfSiAFGQhkvrWNWgiZJu97sAMiHIkZ1vzGcMLOMve6NBIsgFOVV8STNTZjir3Wgleqw+QMqA2UBulIZgczHPGCuy0YrqYQluF3IIfxlkwHK5BZ7aYDRIy0SIuy8iHscXUSES4TNl0cjQKhOXY+gNxzV/xTihkXDugkPGIS2zUWM381OFA8/p+lnqXrSJAQeoTwa1AsG+DOiTs1uq0kcrjzkXmgoyYV+EB7SYnX0bPvmK7zoqRsljZRYkkYzON68reFQs7oa8odgaLitQoA4wX1acdxMbFSslpO9LAnbCJJ+g7XeB0PxcxMGxZRweS6tBoXQUA38k/muNp+regKYCXbRnYRBrf6iMir3SQD1SozCcEZ3WMK2C0EA/wUOAGh98wfQDgQnIQRwGv5jUnSRj2v7ZyxAFB4xCJeiL3PmoaWC1YsZIuZhY9Jf5K6nfeVF+5yFM/MwdEKrcp/9KDT2y/Ojo52dZdpe0umGuk7Gst5aqlNwSSbReavmdNA7ieVGq0V9bxxC36FtGHIy5yqBYU+xB/4R+o680E209M18Yoe+KNcvZsHKninUNCBz5GKAvBLu+WFQnSwW1wMSJ4o6g8jcZEVAIKtBfwkOuOhNmlmAaE+LftX6z9tQsYkUH/lPy4LAo0A7QBPBEKIoFXqHfndul9rRd/EPpMKVQhP1R8RZ3Rp0XHFcWSitx0TdpsxS6Mcsw/Z2fvZkkCEd7PLhGXWJElNKkrMkJiqLVZUJMpgPJpuALhrsRtTrmKqGFdEpY8aCNNfEhng2SQD312HNiX2CC/i4laWHMCi7T2xEiCwQBIq/2oTiGYNIVJx6NTlU+s/WAmlEAup9TGn7UtLq+6ie9KqglgfZxUDxl30Zfd+oG4ERTeM/BKAMdMiYjf3rOj9wGPRlLwhxqv0AvW5iA/h21wNYvrvSuJO07xRUCH3khzHzCh1HFi8cJQ0j9f2mBET7UWjol/xsvTk/7S4f0N2n5gZQUsJT3vTRVOlX0o7BUBtqVXEmEqjhBFbcEayqVHmw5zdJcDxJrdHUUWZX+eoW1zCoTpU0OSlYTsy6k4hEvBgOrkmczaNlLb1QM6ZJsar2GWeEqXkTdAZstDRDbKMVHTbjNaj9pyPtQAKt73IAPi60ucgDbnAMXAcjSBepeRRkkBwUsGgBlAI1Cq615zLd5poFnah99ZujMQ26v8A1U6mB60eRLR5FEov0I9HAXaL+/OhZf/M1Xva8HmkzUsqUqgus3rDZSVvKjeHO0eRPfuJaIvVOoUCIhCx9qvGiSp619sHdf5r/qyc1nFjwR11WDQQxU1mal5jrFDB9E1N1katsYElrJW4+RZgk0CGy7BjUBVXgaziIqObOXVgnfRYIkIR/TB58bgGinAzQKhLuGbt+BQ9YAe04dlc4kCLSuQEoOXq1qUsQMe3fNnvqw6igsfhzaA2JFshL7B3vIevjoDdM40oNv1nGlTfjIsvA+oD9SLQh7hbbZx99dPkTn+OdJZ2XdFgSFuFEKQuVuZlAqkSzyh7HDh4wQB9ux24dCwEEdpqaV/sQDCIkvESzv+Zmsu9RdkRhLUTSGk/O1RQYmHSjThjwSjhQ+dRQNiF0DJzwwBK6tgyEOgU2szKosNhvjQNg2sK3MRLiWt+RD+zI9X1Ef+BFc2bBtTXGeQB/MaZJbgEoSAIF+2DMXmeBAcPBPUiFGtk3SgnqwKEmsF17nhU7xQKkzdB13Zmt9txnoiETb++dP3py0Em6tM9H59R39a3ZMtagJzuUKyd3LqS0x1iXFjUbxBromyUAzgHq3MKMaNi0cAqADqsGkYIO5j2642uJMFZHmUTnwlNdPyuFO3XCY5C2QiCLAlkbtwBK8Yg8A6hMEMh6WE6irYyeSAJumQx4vxj0CVSsgiiGcYzS4IYzFhcVD4nKDLJnRSWjeSGTNGypWDfpc2kO9oEs0RkxbhjwnpjpNs8+1a61UmPO1K3HtFisJdeYaj8SD1l4a1sePticn/TXL9P9p9yPNIw0lim62QiECjPUaAjHO6kDmz3VP6POHPS2R0A2sI1Cz2aWVbjBHWjelzlpqJ3UNyCQE1IxqGufqObNXEL2puxDOqxaDfxYFb+VQhjdd5+YdHWgyuzMffPBE1AHptNIK4na4Z24wq4h40fQlNH9Vf7tRHyi/qMdQK0c97iSnm1s+3WMwDfQPc673A4AoRUcX8Ius2/FRaLVXGzUUlQZFh9gyIsx5+00yFjVWj8SDUKcFkTd6UcfLV/9LC8/oNVAXamOFi4hIBVRUYgCFIMKQ/Tqbdg/XusJWYEq8La6uNSan8oDdYYze/lD+VwF3KaXiGaCzQgILILCKsVWCsElK6y6Wy/vCl2Xb6lSJDVGRAB0jlGgepZKPIXAMuBQWrh42nFFoOMeH/yo+GW6p+E/pt0NsGoQpurfvnVhmHF2jc1jMyBFgGazFdgGaE8gVGYcHP7wfkjG9hPlAKKhJ3QNafVinInXQy9pzSJlXRTJ0meisQzG9t7pO+9uf+mraW+HzzbUddzlkmmqr+lJdc0SEgzV2EupIXRetKqG/AwGIKtm+62gniw6VA+sps6dWq+esBiwcf0q6YKl/0L1hZOipf9UQV/72END8a+nwxjSXugDIN1niBcJxL18Zgy5s4tGr9UR3kdTmSAfepsTCHBwd2DiB5tKvsAOANenyFjk4q8gADWNgYajsI1/BLYj5C5B7QEXDJfuYBQtOxn7BnpTMVnuqLB/oW69WfTL01rTxkJEfRYaiWWUfu/g/P79cXPeXb/Mhyfcd4UFSapFobpiii6FAkkxCjLA2X0ACw1F6FeZQE4AdN8kAmr97OV0IpF1qZHTyjZdVD3MAHa9rh6wiWMEc+01AQugAI5ZMKT7Ves37/8wjgX5AR9CzJlA/CJu+UOi5hMECDAgB2ZAvwpE6xzDRtxWcmT7iWQqCRRBb/bBUE5oENTCoynAA+Eo3N/q9jI8oTfwWw64qNlfswBD7jdZdrqVjGzy3GeiUUiExq2d8Wyzevpoefs6v3efF8UN0JWxUq7Kh3xuh4WAMEDk9x/JD/xFMVCiYI5v4HTiwPE1HcAOAAyMOGvUvspP9XfhFRhEuiJQuzCWTfxltlfUlzi/Lg8xsQCaODPRJZMemIgDaTINYEgYQDikMQ9Tq69xJAQH8B9V+Q5esAwtiJHtILKpsQMKUydLkRRNzuO0Bz/6dYMdwGbI6NAIwKwmiPgDnSSQLCBNVNBfA6A0djzS2DGXpIJSIBHacOq2do/feOvyr/0m727zeqB1R102IyBVofqCJka28ML1qk1dqt5puxN0PwAaOHWl+1hxZiAAZwBDYKoEtRBag5ta7+B1yloKYRAvX3voFt/2pRMk1AJUY2Resl4JlkihItC52hHybAB7kCDqwqZrgpJzOGTvKD0OUU6mjAWlwp0BJD9G/UW9qyZMFPiPQXnGAszQHhUe9IAFdyLKAe72OKYtgi6Y6H4AGcNZjf2nTGm1WaTutK5uUgstqc/ERcunLOng8umP377062N//TIfn3M/8DBy12nQNFOdLix2wyKVUJEaAXX5LCTa4B2JkJjuL1AR4w0Y6iFlQSoYFY7KjHTIK3RrySYAo4I2K/yTB8qiX0IU+E8gPDA7eEqb9BUyeHzNE2SLAnnymlGJAABAmklEQVRGJIREfQC5+WxnanguPHLUlzr0EredGjVKHSyFCNcJ7q77TTZ0px7eqPx5C4AugcFdJXZG/eNH58BBFQDx47YzUE8UMahrCGZhER6p34xpe/s859T5bVQfgFhoyNLt7A+P7q4PHy9evEkfPeJ1T5tRuvL6bK5ZfBZKLPD6HhGcgFNcUC2HCCPbSoM9AfqLblbcWDgmazjIcVGRKNZlpgGKKGYrcvZ4fayIxgktApO/QsDHbq0uEgEzISG6RMEHqObJK0PFrbjFxmbMoY9jbYhcSG2X50YdQD6qdnQTGpp8xGbZIzxgL4JjgEeBmnflLS53QeuHNtrA6hrrhZQ8uF1rZAB9P/CbkDdSpcBSE7VZp8puhuUgueOBxsS2uI/6AFze0Tt0PS+2T995Z+8bv8g/WPJ64M3AY6Yx1eKw8vYGXe/VfoPixrFskN9agwStY2W9khzwQsPcYkemrcVf3v1E+vYAYyW6FArEqWK61yg+g2a3oCe+CIODBfAAqAW0LHDlFkCIrI3xJPOPpyQxmL0A/LAt8VOgUM493C9QZLkr7NrdzIKIVuQHXzl4C1Hro2PgElcomtSZ325PAC5BZoFW2XOAP62GV3ulJYfaHwwyUgvVygIQmdL5Zpm6c51zIqpmpc8683IUGrL0l64+++7r+7/0y/31K3yyor7X2rhSDVHqI+x1q2AHTG1PM5vgp2T8pGUE7vI2q8eaU2rOsQ88ROdVbox7wyx9IwIwCcaD/XZS/bZQeI8RGf+B5RDNBOj12GK5OLlRG4BVc17nfTSJC7QhnzDUYPgaQmyurjOKJinmTIlMjUdSVEUEPQRnLOBUNCo/+AnGdhDWdl/2TPHhXN7wieoDctitHAm5KOQ5Le9Lhf0LZ+JB+tXQ7eydSubyFuv6EkWhXnRiNAvxKOng0uYnH569++72x+6c3n3Ei5E2A42ZRoHaOGVBNjWMTBe2IdHpgsgt51XfEZ856HvUbYTFbeoYGMY0PwsrnWjdm735QoTCOrjNlJdKnDTdC6+CkXkLQGgiXIRrVJQ0yoW0FeLYMHWmEfrwI83wA0kAx5cQ4qjswzb6uA7uYnJL2h+MgHIe2NaNCxDvxgEdXzNLVRvZXUfFr6qh6hZ8StMa9pEqI1HDrkagqGOdOp4ypfWwJbxZdGsZurIWOdXQJXWv7b+07HtJTClxl3i54PNT6vL+175y+u69YT2MQ865vMbAnldLLKDe3SOhZUPx7+ynqnrd0MmFZT1OIEmspoxrM+b2o6OFyXoGI+sVbxYcQvZoATKMwpBnliOLEzLyXmS7MPAaZpUWhPXVUsZfrYGOOw68e6uRTzqtMAY+NQ6APaUpYAM8jBPQ74oemQ/o76jLCS8/E+h0+WksgD08tMRDxGY8kkT2D1ovyoaOVswm1XGxoUzV/aUklDKlLF2m/nS1x8vTrW5NOXWcSygnkeQ89lnXimChMRNnWVy5fvLG29f/Bi1uXz8/PudFX+uCcjUCVXMVfao7wgAVAJizOvsjqHuTa301JRpU0TMW3RsnbKHuJtENYxxkCySaK1svI3Z6JC/1ucij+dPkF5wLXAoCC8D1jZM438siRTiIopsS+wWAHrtVP0CUFQixuQYufIKYavZE1iEirH4A+1eo1/XihsvGDWhNR7g3lW8NWegR5OojsqYoAO4DoKozVSUqCVWOSgU9Z0mjpCEvVmO335/nUeM/Hkyn6gOI0FgOHXK3fzC+9cHxG2/ufOrl4/fuuytc3x5c36RNdY6YV/x61cJ0ZLlxADA9PM2O1cdidCeAiIiiSTW/EOlq0iBA1XFVB2CSolX023Ls1R6ZtmWbn6agV2Jjl8ElIYyEES4MRyBNni6wPNlUQTBgPPYLMB2UCol7jHeDbcLtYGWMq5T3chn9V8vBTvovdogtDiPqRjvPQSqFIiRRQsBuEOr7wPWgf6K6UMFQosRCqbxKNxOvNluUVn3ayKbnNKrkVbvTvbL38rLvJDGnxClRx7ToedisDx9f+eW/ePbBg/FsMw55HPFdIX7PuqxtWB9FjMYU9qJEpUADSJHt0f3KdoAw206CA0klB+WH4UJ+iQnzabDkHUfYEr4SiTsFmEwdI1vBAAbO9aBPGwIuVHVuYD9KLgDHgAM7hZERVetIr/986EdQKscHij9P+qeOLOaVfaffM3QabiDu3U9ALm9dbaMVFGqwiDZ89t6ISv0zdVkWx6u95c6zBQ8snCjXdyERcaFAxViIVkxTJhry8tqN0zd/vHn6aPtjL54/PuZlz5uRxkxjp6/ay/WJ9EV0NsENzLPjnnUBZhfimcCoHR+/apSke4lOaUgNAlAdm/poZgECBXUGjdf/GLXBsI9ZDSHNCofl3yzpa96yXsazeV4pZXfQYjw+sWGYwAIqPyDTM5gJMAOgYVc3BU19BEiHE5GWwxgX8j1GYMRWLikiaCbCo0axvQkei42Ri4HSIfEnmhiEyH+eIwPkAlCyv5LWw3KUvNef5SH19v4jPUKIupd2X170PTFRSqR2gLeX+fCQt/jg6z9z8vbdcZPzMOYsOYvqHi8CFQnyKVRC7G0KwEqDmAAjWntQo6FspoDgvQY2y1gLCoLH3BgECjahyUSEKK1ZzKbDQZiNgkLAmlzrAyC1E3xwbT/oLfMYBVQe0Amzz/VS8El8yMEpjuzaNDTo6qj+xShNax/qtyzRCsTqoCrs0ZCoJJgzEE1W5GX40YsWwhiE4QkNZoTBoiCsUx9TVf+SMvWnq31enm33Z5S7jnMiexUeMVHOY/fS3suLRVffj5QSpUQpScfdsj9//93rv/mLq6enm8OTccx5zLbiXYl1hFGsURQrRaNyzlp9wJ4b1pobRXwIDZFHhwD5kQWxC0/YibeBO3nSpZ4u8f3CeCpQT+zkXXzUQCQY0Oi+nVjLhsKUaxn9Bh4bxltx3ZAfwLjhPxIyExIXYo/gRUaOMU1X2GKa3iwAiIqHnNxUoCWJOkBivwg+RaN1UPcESZhwJIIfzUlREiEI/qQs3ZC3TtY7u7tPUqaOJJE4/2Filiy5F++BWjlBIjTm7uDy5scfHn73u/uf++TJ+/d5PdBm4CFTJ/piRp2proEgwSdiHFiG+4fXiIYxV/wZ7bDdLQWiSlfC8R6JMU2h4BaILmG8voxnSQMz6VpcUufkYxKu3pRxnmZt0DKmsFRWnTxvXQEhbVsuPYxl6CrBboEfiR1mn0Eiy/Ub0u9CEukQmAuHYFY0ZMW7ch5nScExUHEqqZfgIiOUWx0fxABBb7JMjREAMVcaaHdtqsqSXylLOl/vcLfqeSNDRynbkwpr0pSoe3Hvlb7vhYhS4lSIUOLEtOg559X9j27+lV89/eDRcLoaxyxjliwWOGpMFjXSq4LmyGVNjDn/odYCNC6ykZxCq6Z2IF7dHOiWKRHFv0AcbRSM1LnsuXEAXabhNjQIygmDH2zSiU5Rq/sDxttd0jQN1gJiEkC3o92J0VK5YD9odvhIXh9aL2fqnmf0vT9a1IV2Ht/ZqvnI/jUKGHaiJHBjpYU1A1AsQDfmbpTF8Wp/e+9JLyMLK/+pax0WKOWc+8pnmLKUtdOpusKbcXH9xslPfnTyk58cfP5j5w+eptWC1jUhwFmoY4u2E5WcnNiyoSCdlXmDagvANQUa0VwhGGJe+l3Vc+2pQBuDv6vQ9UUeROcseqUzmA43FBlakB3QxGJ1HUQGcwFzINXxrUF2sjLooPvx8S7IDISdqptNIOomyhxiyP9O96BiR64SBEp3ZvVlVR5QvsNH0WBZ7V/kP8qYGny3iV6Y+sY0fTg7kI2Nl9rPLEkkrTY7OW2W3XnedD1n0jhPuSGraO3u7L7c912FYvlNSVKixLRc8vnq/P7dm7/1SyfvPxzPVyUrrD/xwTW6LeJyoYXyrUPsWeAqz7MuAUVNzyGKZMFTbxIshgfcW+rvFgBA1XzlR1nSN4h0xbSfh8AJDs3UWYKPF6l/a+CesP6CalYFzUZ6DDK+YQwpQF+sjSF1KhhNpKiN5eP+YEDowo9w6/ix9rhmTmY0PcaP4Vu3seyep7BUx7fL0o3SH6/2t3af9DRwTh1JYklV95sPQOoDqPJMJdOVJWXhTMMwLm+9cPL6m8PJ0/3Pvrp6cpy2Rh5GKp6AP5JO4i7/JhItF1Ue7mI8Ge6KXiB1pkMxBqhhRX0ndT0thE09CVwyYkb7YSU6b0x1xXI9u6W6KPgSnotj9Q1Eo6f1lk2EWFFpCWMVcoVLq/61vd3XrOIH0QCU60oT1lLsiwkR8o8QpoTtRvfbX6yRA9kVqstEqQwgF6K5j3arXgVUdUwUUn8anz/ZdAYw7ObEtfJZUhZeDdsDyX53loeuD+uZtH3a3d59ue96ISJmSlz/1nAQp+1lPjranB/f/PVfOP7JR+N6k0tpULZwAelEJ7LVVwQdPdflMxtNSNQiRZ4vm+a2wl+GU5HFkVyv148NrahIn3Cr9m8kpVgRZMMW+EzYSZGVuCCArtOB9DKccJ8TIxEsC+DBI/NuLpA0uG9qJ0Ggo2C0+QFAecAfkCVjAnYe5/FBGLg9iZMHgY6euxboOYWclm8xCeca/Szqf3GyOlhsP1umFZfoZ1H/Hp6skcgsuXth9+W+78W9TGYXAxbmxf7us+/94PovfZWXu2f3Ho855zEHFlRH0RQ4+KDMRH5l0I+O/gj6iQAQeNJsR2Dsn5ooUwtlobYN7JkcG8JxANwpJGMgB4GOA0/GjpSuW5hxhgN5jNvJj51NVbwxE/G4+ATZYcMlor3dmKsKf5sGc26DnVNoVseHNtTcg/VXkK6Jfxw2St/6yFrVg/GfUdJ62D3P/f7uQxp7Jz81AOqRFKYiADuvdF0nRFX9M1ULoAaBt7fys2ebs6MXfvMXj3/y0bge8jDmUXK2ZAnYVZcBnxJZy8ssw8Wq7GOAKAC3fj8JEwV5CM5AiC9Rc2BEPFzLlHrMBthYMw6TdToaAXJ958bQvwQVrf8zfgvg9iuHTUeTZmAUhgweqSN+Rv23Kj+IIpmCjxBXoyHTBjJtaVyrxojw5qdcqKEv7d/5j6DLTP3Xws/CfLpRukyLk9WlxfbhMq1orOrfIoigS6VagFu7r/R9V/2CVNJh7g2XPcuD3cPv/uDmr36Nl7tndx+Po0CFdF2zN/oqXpYEmV2jKmADXGBiIywQcnmAw1EIgmw0MkAudVEGpG0W4A49PuO6wBiBB6yqGOi3ranih/DceYxBuM5vtCaaIccvYKRV/yAH0u53mXB9P3ESoksgMrmKa3cQ+osbQDodzAURqARkdareKqO2EVHNJZ79zZREuixdpm69qepfhr5j6aDyJxgBoECvdCoA7h4n8wTcCKzPjl787V8+eutD9wSmbhLptJiATgUScxx/tAM82UMO7hn176dC8lMuxMigEPeG8uCgtC0BeIwjGMYxRocg1hFGM6IR2JGXMwQxiJRhkjQN9qXR/VMPwTRTMAtCjTqPkuB/8cwqNQjT0Ew7qLYkPLZlNc//O3uIY8gptwgTpWz8pwR/1lX9c+56Zf9JJ1wpwOu5qgXo+k4oQF+YmJOJgTBtXd5//Cd/duUrn966eevkg4c5Sx6zZHCWGg3lrieTLzkCNiAUiiJTaSqFUAy0MfuZ8cQB06wP7bcRT2iTaWbUfLOkBfAivIpDiAl7ADViEBAkMlF+Jgewm4HgUBia3VQIbDcbCHGCz0FDy9zf6bdTVSfO/0Di5u2APj23V7eHBcY5w/4JTEhV/NX3Jc5F/Ut3PuxvSPZ2HsqwqLUPZO6tJHbcuRN8c/eVrutd96MdABbEyyWvVkcffvDa3/it4/ceDGer7DkBjI8FHIs5xy0FgrgNYQvHZYC1anTm+BDBUQ5CMuNY/5Q9YBaAa14Uv5K4M+petRuN8DQ6wnbO7Y07XXpcrRuTDvsQcxHEijyQCpOjhqxftMdtgkB2I1bXBaMBiG+VvZKfSfDLes30BLmgkcUYJdWy5+r7doMsTtaXtnYf9TJwTl2C4h+mZCzIXFQmEeluqQAIJce9RoTUK0hCsry0/+yHb1z+0sf3Xnn5+N37OUuZJSDm4dWnxiI5ICfgDIAP6xCm58SFfB0pFDAOJ1DqA1fhiFpMpFkzWMWo8R8CqY41cGKDiD/wUUWoxTfQikYMCH/jWbyRciLLH5lmDu2lgbjD1hDrMjVjB2b3YMsJ4lsPQVE+I0vx4S4iS+2GG+q6dLJHflKWLkt/vjkYOO9uP6bNomNDf4llKiQDdSAh6W7uvNL1vVSxYGUs7hMTpxpjWfSJ5OF3vveJv/WXzx48Wx+d5THnLCYDVMNS5CoQQ6Lq2DBBLAqhw1E9O2OKE2JiZkBtAhw2DSi1gSDsSjuEojBSa0zmvGGz6nP4nhKnChKWGcRLHHFpzhghPqf6XSFjC4isOhD1sOfbAZoBekv6Z9poklAuBLfvQXlwpcNwHf/KfTBP/Yq6v0Nenmz2d/fupSxJUoehT65vzyrzgF2VMovk7sbOq13XmWFAIxDsQGIiWl7aP3n73cWN/Ztf//LhTz6UoXgCZTads6Da+Y6qgn4lP6CI2Z2B4AZwRCSGONmofwNVtks0qI1+NV5lCu450E8Utg9VCJuG4YvqXOufDYfs2GSCxh7dn/CeCb6NjEy/anm/N5DJcfOMP/4N1L+yFxemqfWwpVrneL/OjAkyHuQk7HTHl6imWZ3/UDdKN0p3urnMi7Pt/hkNC8t8Qfg/BBSVLHOW3N3YeaXrOoc+IfpjUIiZurTc2b73H/7ktb/+K3lD5w+f5ZzzWF8gFaNbFSsBFpG/XMCCgh2o/ASZDYaGGqNBOgOBXK78Wwd5628g9KUVId8ZOH1gX/Bsrq1D/UWgNigaFH8UjWH1RFKhQE3smyZVM0mA5/sD5Aw+orwhTh7ab0QLuBacJJYxR1hMmA/s5KAOypfGNisRKvwnCXHJ+2bpN+PO2bi9u3uXh64jSkl04ovWxLAQpAJstISkCkDlPDPop5oUq2SK+r2d9YPHZ88ef/x3f+Pwxx+N62EsieHcJkYazoC5YTUFqKaxKqKFYJvkMgGwjxzV+TxlQpmaoFzix9ZQULiB8DNZCGwy0A3Cf+oPLAWFscdJKsD+Fcs1BzUcIThHjWLJ0JzuxydpWM3UYXB1bVDg9lhT5s3JTfdUlHMIKGvUX6d9Yd3b6frKYvvJgs9o7LtU455Q/qCBf6PeCgER6a6bAJAtkeyIlAou8wdYmLavXHrwrT+79uVP7b/y8tF796WGRMEITMId1fQZ7gFFGB2NLH6GlsR2oTpU7Zy2vEgGmp0MG9SIyvRAigIz4xXgjcNpgylofqLnWD94KbDRpYbrI3AR2YQD0Ch+JSUNKC/U/c1OWBpgOtKVC8XJE8qaamdErRBKgC5ygIz3VzGohQ/Kf/rVsD+kvLv1gIZFz9R51SdqclT//jdL7q5vv9L6AETF8dVfcIgTE3FaLpLIvT/7zmf/q985e3i0PjodRy+TNiIbBgsIj1RJI6UrDV4amKJX67cfmBIHqZgAMZ5zRjCmJ8VCOY7CEKA9/ahW3YA7A/fnGgGZ2xKQIviy5TlwUGTkvmeeC80yftPWk1Rx2OPHTvS6eYRxT9OsYKIRcPCAoRix8H62urchb50NB9u7d3mUjroUMl+W9xUEMkF+SCR313deSV2JAs2VLbgtYjYiJLJ15eD47fdoIa/+5jefvPmhbHKNCNndT42AR4SiusXYfcPZZ8QDgMgc/4H9LZxtp502WqLWEyGevTSMVxs4IsM+txhHRmshSP/liyQidOFU/c86x822jgeSCWqTwYSwZtxJF5D+ANPKzRtPIJTyq+8bnkAqOY87m6Nswlc7532UPlN/trmSlkfL9IzHpZX9JIKCHjJNrmNgrjCLCHXXdl7tuk6RgYUG3DT3kyUW5u1LB+//uz9+6Ve/unPjxvEHDysRkuIQa39yeDwTPaGWCBnVQgJmLRpM8kSKzFeYNxtQaxTc4RbfFwZMafI1fsXTLzk2a8VELryRegDAeUbNB7h7ERKeXuHLzSGND3CRQYjMR2VbwOWNNCUspBEkhJs9zU5qQQ++DOsTVP6Ty4xHSZn6TN162N9Qt7P1EQ3LjsgjP1TQH2vgovovQC4+wKup63SunkGziYfSZJu67W0ahrt/9t3P/1e/c3r/2fr4TOq6KVBHbirfhwuL9YPbfSGw5pEUk150AfQbZLdWAmuPWvmaXH5iKyY3PAflVmrkpx+EzZRDT1lQkJFp2Ad1ObWApgap824xz3xL8S+WwspkD+GB85EBMYiI0n1tripb69606rP6vtvn48HW9kcpj0n6xDmRlDqeBOVu7gOQq0AbQyHprlUBsJB8xYWny1B28MQiW1cvH77+Fi3l47/9S0/e/DBvch517ZRyeivemGDIg0IGQYaLtYwEFTnBFrjLQKmqPaE5N6PNIVDbKw02o0MOzGqi94EYTek6Hg6qj71RS428jm1eggo5UByGGXhTOuRfXugfg4M7/VZmd7LfYa0E4FY2ZsSGw9XtPhlcLwu6AvmRVFc9kT5Tfz5cpcWzZfeUhu2Oc+eRH6Xt5Z1ewfdtxIBdAOpYsCMy6mZ2y2GnTEzEO1cvv/fv/vilX/rS3ou3j95/IFlkxHCQEOSG3VPEoCWAL+TKFPTQFlNo/o8ELPL0tCYVzeGNHDUxJr9esC0oFqjO0ZFp/APxcSWYuqm/lS6jaKB8zHnFwOYrUfBzzFiDqNp1u0W8Y3SOR0XSPxP3bMlSQHmwCbq/WfUETmwzNMqZUg19VvR36/Fgw7y9/JCGZc9kQc/q+2oRBEEYNIBOIZxJuqs7r3apn2C04Sc6ripc5axC1G1tJZF3/+CPvvh3/trqeLV6cpxFZNQV5MJgxYC62wGXrMkPX7jdwq0J71BjWeC5I5WZUi+enC0QH0e6TGzJjJsA3xaBce/wQgeg9lnkMA7e2pvauSA+AKgGalN8T53d8HEK4mAKWPDiFAAdTEq46AW6v/nr811IaLLWeTfKzvm4v9x6P42UpO8U8TbnHYwAkS4CZxoUeLFkku7azmvVCY45gwJ9JrQDkEhQIyAi21cunXxw9+TRg8//H3776Tv38mqjBUJWrDvzM0m4OtUBnh6A6R+RgszuRMYfoI5kKVwn1N3BCSf+bHuR5lYbHE+sAUJj5kA2QJuJIDUEEs5sOTJGNLXxnygYbZ12kJOZlo0/MBEJ1+t2b3PgjpQsdsBF6FcLYLpfpMvUZVqeDVfT8sGCTnjcqlUPWvWZqKlhEEfBRADKut7d1W13gpUuRRakm5g5grwBZaLdG9fe+4NvXXrt+ou/8NUnP/5QxhIRovouvVlFFsw7IrzKmxdvGDLtTkB4UEXPSMjEv41KfWqUZmDZMKm2xTReNVHurXgg85G2GXgGIU7C4XjSKBsoZnR/o4fcbgT4zpuCmXhogO+ECFF0gh3iKIrhsVAYnPnoas/K/pOGPnuhbjVezelsq79H43bHBOud1MJl1eFO9xsBwL8gAHCTAYhuOVxCgliV/V23c/ngzX/xbz/1V35++9aNo/cekHCVASOrVkDexkEQ4TOcIly9kQdHMoCP4wmaiGoL/OCNoHpo7mOWBcHxMhWv8rTeYOolABBYxWFiTHBdoQBrrvjX6QGANkTeDP1ACQlGQOcsx/2Eg9c6uwDlQG/ACcYT2rLJQfc74SmPomuLMMY9N/nSmvqt5bs0LDvijoL6h3L/lqnQ3N9ibbur26+m1NXPMWpqkULRLBiDEdAr1MxPv7tDm+HdP/yPX/qvf3uzymePjkQo28z5uspXdOo8LaCosftDqkER7AhYgCZuNxra2zR+UPPtFJlBECbaPfrV4fZi8MuazOF71heISkKDOwC1CsY5FhSQ6jc0UcmR2Fy8v+U8LYln4Es8e/VWTkJlG4ezsu0nTXsJdULdKLvneX+xfC9lSVQmfFnQE8ofEJUgAEHB6l8h6a5sv5rqukAO/YqlEBHS0VB4htMzi8j2tSuHP/ng6bvvfvn3/urhh4+H05WISLbEo2qoiKB26kzje8yghJsDWpY+UcQNXW/h3tKqC1MM/tUEuNMIUzwXIhstQzgFtpqaiAimaBQwLyYRbsGvnRhiiUI1JyQRwbienqM8GgQL3bpgBiPmcR69K7ADIkQ17FPYf5epG2lrNV7lxd2eTli2dKnnXGY8YtKXwI1t4E6ND0BOgXrFAc5gZARlhUtgR6BKC+3KtH/7xvt/9O1umz77u7/2+M0PZciSRd8tU9EvAkqeEHzsa2eCzoeQKLXf60NPtLmhu00ZtFaEQ7NA9+N5A0QB1k0Y6eK8F7Sa0/nVPljQQJX8zOmA3+tRzZUE1bPrnEn8h4NmQuw2fF1at9UYTuP+giafsKyJGxBuOaxqXKk/JaE+U78er+f+6SI94HG3Z53sWyY6YsGPJ3ptbYa2AtT/EomAAECO2MGFKt9yAjE64lZHmIjS/q3rb/zzf3f7i6+++M2vPH7zQ8mwhgqRRBNAxn99HnpFeisjCDAXBmrONs/P9Z8Ictvrh0CmhBrQzya/QkFqcyszEdFJhRF2wNzP3OpZMaiM0J9GPGN0aN45LpIw5Ug4B4AoHN5Ii9+DTNhOg3I0FyCVlQUxoJ+llPtTv8nXNmm96N5P405Xov7kIf+w0gkYAQK4t0pRN6oF4E7zANUIRC4UiLkHmcpedVoqkIQoLRZb+3uv//P/5ZO/9fX9l28/e++BCBWHWHtAZIoCtDmIPw4EBMAWUTVR0w1Bwj88wXFsGxtMBWbm8CZsJBc0a38u9gfkgsbzFUF+FOKb5lJdZIjXOelwwbnUWAwW2Z6g+BsJhHvAPa0wG0Gq6Ffeb4H/LnM3yKUVpb5/J43LjlJHwvaqC3LHF4BpMZpWDAJAWCnQlWoB1HKQ6VeNo1LLWBhdDD2r3UXOstzfy8P4o3/yr77xd/8ab+0c331S/DVYGm1GBqK3QgJ7mJ10NViM6A8EKeKdKB7vghAlZC4hEL+i0D6cP8IdgNIwqACFaDxC2IQnexA4Ye+s+o9kqQmD6r20h3C0GzOmYCInQSSoxfqEDun6Vu4MGPQB/dSNcrCS3a5/K43cyaLjnIiSvuU3er1iMJyQYFDmcacJwKLGlBULro/9fGAHnAhxOH3ZlThn2bl6eX108pN/98df/f2/stnI2eMjEc45az/yfETERAspztytBwoULcdFXmg9GeN1J/LTOgtNOLTl+NoePdpWVODqFM8128Y8gIk6t/0OYjwP4LiJP8YMQJixjqQfQzcxDzBxAFqvI9qB1r/3Jw4FPz5itsytCkAJ++yt8gF3b3d56GQL0c+Ofi9zAC4y56tO8MNEwtJd2X6Ny7pA5Q4JztQQIcedcyuO9L2+Lz6RZNm9ee3Rm+8++MGP/uL/9W89u/9s/exUhDIEhWRGBpqQN5ASxA2qa7RDDTIb4l/x24CzKY1w0b7AbvilQl9Prz2RlgndR8lsVaY0yIZzBDXPTml0Z0gF6KmmxRGop5swv11oGhudbFvLeP+NALZ77Jbd902G/kzdSDurfI26dzs5SbTbsXRErMyHDP2B6Afw+rhNqsNcAIi6y9uvcYkCORHX8wUTQm4HtMHE3nt7YZZMB3du3fvuG8d3P/za//E/O7z3dH18RkSSYR52hEK4WcS+8R9X9hwvGU4E5XXtx7bKRwEvfn1WQheAHqyB/w/PEUWrZQWTx521AFElePiy2UONeFisxnZOnN02m9YG+2fofhtRndPe7aWlEfKJYwCcEKd6EWuxJ/WZttf5+pg+7OSwk92OBZlPBYeznZlSZ4uuN9C30axOsFB3Zfu1GgXS3e4EK8ymS+saUjBdAJP6NRUhdHD75k/+7bfOHz/46n/z1w7vPh1OVuL+AHSI3iPCK64qB/EpDmibbsB5ZnQ2au1GWTf538ZPwD1zXIjmrgli2t6kfbzI5TXEzEaKkHxH1k6TdEEg69OoDgBzXuXXf0Cq3Xv1e2usBz7OjPrHgp8E1H97LTcG/qijh53s9kwl4aXMh4z/EFKWCyr+LxIApUDUXdl+reu8GjTEATVJF+GIKJqJskB/sBAJp8svvfDmv/njzdGTr/zt33ny4ePxfK0ryTW+EuM4SwO9cl8WJKVAx+w4oNqNfZhBZqRJJtPh6wBjnp574qIQHPC8j4y4+HPofoqIhz3xI/w74/g2TCnKT8uOoonAa8mkWfsT+RuWP7CSfjL0E3GtdeOtjdwY6G5H97u8X6p9uAiAo9/O6FH/MGQccYkDFOlQtQDcLeD2TLLsIkZ4EGPRGlALQ11OonxMl1584Y1/+YdX7uz/hb/1Ww9/ci+vBxHxUqFZHUjNFdsr+xdKjSBUOwUkNVNjXLyiqgjMas6m8KRn23M0tzd9IP/WYO+MvoKypU9T7tG4DZPw/5xv0FiMQHImKa05fU+N7vdbwtP6PTDgUxsG9p8q7+cu83Ijt9b0NMkHnRzUQn9AvxsORoROHN8wkhMfNo5dd2X7Y6nrQf/YuadDHSqF2nFnDrkruKAQUdddun3re//431x78eDzf/M3Hr1zf1yt49KRbHam0eJ6IZ5YgwCyGWQT3h12TjQXMa07VehTxR/0yly3MsK6jY0i4qe6v+xsFUIQg/g2P/+ROVe4iaVK8BNaWXKZmVHtmJV7zg2DVfMuiY4AzzGfrY3cWuXDRO/0stcxa70DIfptjot1ZaP+pwIww390IzrBhtdgYwAXHqAMT0jqC8AQWyzfezj1i93r177zD//VwbXl5373V5/dO9ycrohYsoSB8yfTzgxYnlCROTFoBbdtE03BRbAOfSixHYHcCJ5+zjK02zz9bgoj3x3cRtsTu6xxp6aApvn4D7IsaVV7VPl/PvTjF3o5SFFUIqMRz87QP9D1VX6i6E+dFjtUxt+QEiczQrP4Rv9xzj6UPUUArBSCApqQkYfZlL7XtbVSkHZoXcswCaXFYu/m9W//D/8inz772t/968/uH25Ozksh3aTXuQFblGhuSR5YCMYHZJ41FE21gx+CHeDnwWMmoZ6W8DDihkpIybWid80Fuv+52GqinNhm6ps6pbkoYE9BPCY3wOguz19xqromPwAjqlFcz3YJdZm3B765yh+yfLCg/Yp+lqRVD4B+PZcpZ6RAfvnwkpY4xC036C5vf6yzalAQAJmRpvqtNHCsX2HBXCMJtY0Qcd9ffvnO6//qjzaHj37u7/2No4fP1kenxKwiEN5pZ39aWBqfYTaI++O5M1CEfEKHKJ4j3KlpCqHmIaN0hX6f69xZ3d90SbnI8yAYYGS9o4ITSiGklYEpKCerpMwYB0y0ReSGk0+euLloaxXs7Y5a6lNyvcI7A91cjR/QeG/BB5X5WIzffAhu2AvsaUxBvK0LN/QjUqD4WhQ38C5fmGgWS4Q59cfBjMaQ2X0qTldevvPGv/4Pq0d3v/l/+ZunR+dnT46J2ZeSnEOBL4NeThVwzxdwoaltbLR78IwB5VFw9cPMSbQkrWVB/tyzfEc0D1O+CXkl5jm0CR4bTtUG2stJ2vZTiE8/XmQNlHtwK6IXCXl4UP3SX2rE1euVtDfwzfPhXc73ez7ombtS2zwJd5IJf0x4EcgDDkAYP282HdQqAIvQr+hiwAammyUMK+KHpUmbhrFyGbj80u23//DP7n7r2z9b6oXuPSlzNG00IB/LAWxwY23dTkvEwsYcfCcdwpNHmlwhPNt8Hrq0v0Cjc/wYkTLbcdNA5xRtE+wiyi9Yrzgifo6MyQXb8RIzdV0+anp9X9dEqMvcC18e6NLZ5k0eHy/SQc/k6Ged1ggGy3XcFOsTwjEVAGr5e/23cYJJr6BsZypEHGxC2yezcJqRFhJKl1+8/cGfvfne//rHf/Hv/bXltWuHHz5quhorOiRcyW8AlDwHUWGzGvaw0lD/eE88t7N9eoJ7wVNP4TVhTYibxizIzLHQEfN7YgBZVcuMxzwnZi2ynyM/066gySzN1ky5a1BGIjWVDpKurmn/fP16ykdLR79wzfhSeDsVSELIFU3pTYDG3FhMerm7vP2xKAB+hfm0AF4zVEyQQ2VG4cZBKXY+y+WXbz/58OGf/nf/+Kt/85de+NrnH799T3LBR9AqbF4vhzQHke1t9Lzen0kCkxcOtQFV7yNlJg1RDGLU0pX65cR38Z0qM0puniczDYKwy6j9Qfd3YjSkbTYvVzNB/bm7uihAdNG92as48YUuXaZeuJfuhVXm8/V3OxkW6aBmu/w1XnBX/pJ18iFuRpChu1oNdwEZgIepAtCKVUt+9KkiWFAwY1dwvANuu0gTDXmU/ZvXN6vx2//9P3vtqx/79O/8wpMPHo2rNaU0CZEE0Uaj16SoLiZCohgPnjE8EMEh0qiM4sNfYBYCCKYbz9mv934BCWmSvqTawe+QVGJnnFfC0WuBPuG8M7cnk3vmSZvmtpls2T8v8zTFv5Tu9tlwulr9aEFpkWqVW4ormtSOZdACFoeP1+O52+LwP6BhSkeI1QJwfJzgcUxplJoikxC9UGg6xUhpqwsa1PNk2b16OS23vvXf/pO9/fTV3/+d0+PV2ZOj1CUPksyREvayTcNqsD2q/qWR/5YRXVxPgfLul/WdMc8/LwMSz0GAdY7YbcE3wda0zPgicn+BiYsxGp45cJYvPe+ukAtBzg2hn4Q64Y66PeleOF7f26zfXPL2Im33LF1974qSiXLdyQgisPDBAveZ+wBjx/GQhgJJGNKZ5jFGFCfbzJIvOIEeG0VXfBJQluXe7v7tW9/5h//m+J23f+7//FcXly8/+/ARp4BND/1MCuPwurB0hd8EOxEqhjWohika2o88+ZanzTiCpunq6fA1G89hF7NfQbR7QmMi7WlQG0i/Wffn3urFXEv/9TcONkv6UCfUU3d14CtHZz/Omw+3u0uLbtHVSL+VU/ras7X7ogWc9umEi+Lo8PSrwJx1A30Ajv0Xx5ygYsDJFVipqSfS/lVronVINhzlY+r6Kx97+Z3/8P23/uUffPW/+MVbX/3ck/cfyTBwUixzhT7GXadXDM7pTMVEUNtG+g0rM27ABP0T5P05IT7PLhojAM2mDsO0WTNQgGMOh0RBmg5vOMlPu+j0J6BfS9xSpo7SkvsXznM6Ov1eGo+2+8t94o6oM/Qr9P3GONwtdHprB1rmox857gWQcgAJCMCFAmUqssU6QgPYjoTDGe/ogh6sDytEkunqK3eOHh596+//oxc/d/sv/K1fPzk8XT07TV3C+w82DokWw3eQLvfsGAU9MMFu6E/zXLUZyEmr/qfuQRAqOAIzALPgZrowJDrdH8tgJjGcWUBPH9xPwn8ekZv+qDYkEkmkWl+o47RHi9vHq6cnJ99bMG/3Bz1Tp6+fNpXvqS7vWDU3TC145j+2m7OyAY5h3ewubX8sdYuJcfXPAdCFJjVUgGe/mgu+g5cahsyLTTiPsnfj6nJv/z/9d//f4en9n/u7f7W/fOno7hNV/3Y0O6vBYIwbCh/VGELmSoEsKtSUkULuYZ75qA0DTDf4eL5X0ACn8WjDV38eDU2g0ZtvXSM1jeNGg7nni03cUXvWGD+pv0vcp8W1MV19evLW+uwnO/3+Vr/dsSTmgP5mpfAKzlh0ho8zuxPHB3XURO1OB6a7XKpBm3OGy3ALgWChG2XYUl9YvwNlIAiZrTFcjKGM0m/vXH7lzlv//js/+h//5Zf++s+/9itfe3b/cDhbpT5pHwFUqySEtwmjFphgmv3jZGibhwhUq7G8/3s2AGFcde2EhPC8ZZhpEPeHtGTb/oJSC5QZbr+dCUlNb0aXZrSHSUJJuBPqOO10yztnQ3767Ns0Hu4ur/Sp71hSqm/cTWAErM9xRGYuPPtVS1xARHhmWP0R9Dm7K9sf51AOHWTKPsYumXNGZmQgztFvOxB/1Mey3KIQE19++c750epbf/8f7e7SV3/vt9PuzvGDp8zECVxYXbXRa5GQ5ji7tCxArBcC6WhusYU+X/gtzcARHW41NmF0YFyjFWq6aV5Ph0sHrjxFcMjftN/O0S0EZfzWorBAeyr0ibrCfLrlNeluPDn+4PjoB8uu31lc6hN1iZKTn1DWpt0y5+hPKJDf2LSvJvhuvm0tORExdZc0DIrxtEltSnPeOWLFkZBOoC/h6kDWg/XWbKYQCcuYd65e3rl27fv/9A/e/Xd/9MW//vOv/MJXjh8dbU5Xqe+8Es60f82RcdtxmCloQsIAzZYI4ceAGJ5+9JhMy2Vn1Xk8aoI/EIbZWOSc+vfOlcmFvCy9vaVWTU4Yf6uy7M50JhcXAeiFu9Ttdlt3zkd69OQ74/r+7vLyst/qmLr69lL2SP8s48eLzrEdxNdz7nOW/MxiljAKFBq41Ww1EroHyAzm0wXzo9bysfZxxawBS5auX1x97aXDj5586//xj/Yvpa/+3l9aXL58/OApS+YuKdyZkkZHkzJ8E4Z6OU9W+OqfrM80oT0UERzDRxIeA+RkevhzjoVmjaMM46QU46dxoeaoCY1h4XCfobSYJnibGUMGlVWvUWP8zIvF8oZ01x8fvX/49LvLxDtbV/rEHVOX/FXrjF4WPruN1cW4N5hMv5+jLJNnmdje0tvd5e2Pcd+TcdKmVdvf0yqHOarlQzpnpTQYGgtNtYmvp+7VczLK3s1ru9eu/eB/+l/f+hf/9tO/9sVP/843V6eb86OTlBInpqROgBWowuomHjoF5e96yAb2AupvHdA+90/T9NhtjXmJh18Ug59Y4sKpZmDaJLZiljL2fjCAdnvPhRRofROvRFw4T9f3l/qtOyer8/uPvj2u7u9tXdla7nQsnTIfR389uTRd0fQezV+8eeTwVA1xmhHmC0xEd3nnYzYnOF5hKg+TqzVeJu7ktsHEPvh4+ZYGhTxLkGtjGaVbLK6++tLJk5M//W//yfrx/a/8l792/XMfP3l6MpyvU584JXujvU/PxORK/UiQM/bqIEiyzcE08qILMsclvyY0h/JJY/Js++y1JtmriVkgmgvYRymVi65OmuX3MYi3GsmQdVOq0OeOqEv9znL7zkC79x+//uzwR9tdv7d9ZdGnovg7bl1e6+QZHE/v5PlEKJ4lgDVq6QaquC0qAP0FwV6e2ROyw/5F5ATxHnly9lbG0BSAWbapYlKlImfZvXp1/4Vb7/zh977z3/9PN167+sX/4le3rl89fXyUxzH1HafESjbVOaYAWxUDLxX174EXTTT0BL7YEtM3k2a+MZll0m6AtjZ9P9GRwdsymXlOGIcnoUaEGs2MD3SU6f5EnIgTUS+UOG1tbd+k/sbjZ/cePPxPNJ4c7FzdWm53STqmLjWxzlkczWH9oijQ5GeKcbDsk+/n9TaTCcDc6UNLnj0TNIGBndwXxmYn0J85EYqjJQpMDHLmrrv8yp3UbX3vH/zrn/yrP/jUr3z+07/zzbS1c/rkiETSouPEKgbEKblLkCBymqBWlCB41JTRPcdFJmrcyp+C6edtyE/Zoxp0guZWGALB0AbWATPBlqkYcDTMFciV83C3WG5fX2y98Oz09KN7f3J+9sHe9sHe9kHfpar1I+O3PsQOnFHRswB8bgue7oiiDOUA8bQQJWwEgP3YaFVCzRX2PTf/12aT4EWkro0yiooPLzBnCpiE8pgXu7tXXn3x7Mnpn/4//+nD737vE7/yhU/99jczp/PDEyJJfaJiDcxDSGRmATiSYZq9YyIdMuFEeQCANMC1vzLdH7dnDctP9weqoeQGu9PLBUmY7mnvSTvAzVmFcEfcCSdOi63tq8udF0/OVx/c+87h4Rs7y+X+7tXlojetHzmPaxu8yJ//h6efo02JzGfm5MBxA8Ls3yoAPDlq7kYuoG888xXIGLZE4MxBAq8kNuiIfn0jrpCMJJl2rl0+ePHOox9/+O3/1z/dPL3/2d/+2iu/+GXhbnV0QlSsgZIip0ZM6i0Us2ChesR+q/6hY36KZQDqMuX3qKQnDaRt3wYupzIj7ZnnO3QSvbOzBFQi7lOA/tbVrd0Xzzb8wb0fPnr0vUXKl/euby+2i9Y39GMIOqDf6E0jBLMaooFMeOAWVYjnmXNEYZlR1a9c/bW02K4qFrvc+luPmSk1LAvc6hnbxjNavsmaRUWKCQSbwpKospJEVZcn4o4pMXfll1JH3bIb12cPfvTjvDr6/H/2C1/5P/3n/cHNd//w9bt/9tbqyVHejOP5MK6GvBlkk2UcZRQZM2WhXHwLe5+rlHe0TFcI1PrvmXjLrBZvlPFzTQFZYfO8vo+9btSmnpkxNRXdDF+Ie0ZrTZao5/ibhDilxdbWlX5x9fjs7N6DN46PP9heLPZ3rvRdn+oMxvI3AHWq+ubR+ef4YcRhq5sRcY2S9g9TDRyagAC4qAQS7raz2cnYwO+ojTP7xWd8QDsPagzbTuS6uXCY5H85cZGE1BEVMdjqNqcnj954K69OvvC7v/Az/83f6PZv3P3Oex/+x9fPHh6O6yGvx3E15PWQh1GGLGOmMYuKAef6BgMGSSDy2U0kFFSyEM+qZPzIs/KgLWdmv7W5qnBamZEHuAHYA7c6gwyiMDuICCxUImIh7rqt7e1rXXdwdHJ69+Gbx0fvby36/Z0ry36pryeCwdGXWzHFlGeDNvqpP0wBfe3Rz9Xx8SoX8ZVG6F+5+mtpsaMWIKoR73jGnUj9m45vBQAHsCGDYZAnpsBMhPMB9VxTNQgoBpyYOuKOUsfdVtqcHD9+8+3h/Ojln/3sN/7e37r2uc/d/8HdD771+rN3749n67wZizDkzSjjKINQzjIK5YzWgHXlRoa//tGhFrT1RZWYzwEuKV5/2oHh8NZ6NL2rJ7xABsItMxFRImYRZk6Lxd7O9jXivSfPHn10/4enpw8q1+8WRT5Q5Ud9z5AplwZMfz70O+4u+orndrePyReeNwgME79y9deBAgV6U+6jrQz1wYH9HBtcJANz3kKLftxjvZvUyiWN0xRqZD5u5UXEHXOi1FO37Iaz06fvvHv+5NHtL338i//lb7/yiz93+mT9wZ+89eiH754/PZbNWCVhM8omy5gpjzKK8yIVhoowWD2cUR6gA1A2ni8AE1zqTml6tKVS8fxwKizQiQBC3Ife18x52ZO65fbWpa2ta5uRHzz68N6DN9frp7tbO3s7l5fdgklM5Scg8yzNHTLcwKy+nvyYCZLZL+JxVkNyoWzP2ITQJt5lFICJxE7WoMFRnREA0vkts0QoUiDot3ldB/vVAnCzXdJebg2o+gaJTAzysD5874Pju3cPbh185q/90qd/51e3rt56+Ob9u3/646P3H2xOVzKOeTPm9Yi8iHJjEOyliP52RId+4ELIVbz6fx61U6C31OW5kiAwnGE85jUidihzhT6nbrnc292+mrq9o+Pjjx785NHjd0jW+zv7e9uX+q5nkUTe30RemcGTQYulMhejMP4EA4azB0VmBYp/6pkvkgE8w0UCQKBNJi+zdf4z9RPszLNzkKZniKPafITbRCvLjfVlNwv6t6yuVNlRIu6oWyaifPbo0dN33pVx/fLPfu4Lf/O37nzjK6vjfP+HHzz43tsn956Mq7UMOW/GvBllGGUskiAkOTrKUuZ9kL3V1p3jyukn7rJG4su2NA96weQVnGCL0A5l5fMxH/woysxLbxXQC3HitFju7O5cWS4vrdd0/9GHH91/8+TkwbLvLu1d2V7udpxYJBFEjH2ZS42KeWSjUeONzpuHadTwfw6KdMF5ZnbyBW0CUeQJBZoKwBS72vnNo7U2gaIAkIG+1sQ/Nz/UqLVoCgidrygSNdxZUpY1cKSWQbpFSos0nJ4cvv/h6YMHB7cvvfoLP/OxX/uLN77wufPD4cEP33v0xvsn956MZysZswxZDcKojnJGasSiiLfXfJodcC0+tQ/lOS4yArUO6rkWAMvmvEFrTyGlEZyq1G1t7exsX97aujyO/PDx/Y/uv/3k6YeSV3s7+we7l5bdVhFszRMy4J4g0OrCYP7GjADYLXODGPw8Je2OnIvE4qeSnLYNz/076wOgdp8TAO/8WV8Z735CflrfROJugbET1HITUqQG2KNGbbyIgwxYIp877haJaDx7/OTogw9Xzw6vf+rOp/7Sz9/5xlf2br+YN92jH999/OYH///Krq23bRsK85DUhbK9JGubrCuatOuAodiKXYA9DMNeiv2A/eth73seEPQS32LLlmzrQvHsQRJFUrLTGkGiyLqS33fOdw6PqORuWaZ7LCtU2NGgUkQpVAhaHREkqpb+jTRqY4MuTnCewIKuEdHlgD2V+WAs4XStHVW1yt4ofK0bhXEehuNInPn+uCzVer2aLt4v7m+LIolCMYnOhB8xoASJVjvmhJwtjS3D352RkPbFh59gxq37sEAOxqr+nfY/MLQCAIe3cYCvb6BHADOmci/YqRh1TmX79iHynGLocTmkD274BDftbI7skjZSa0oh2qoHiwxIOVCPYlXu5st0OpNZOr48v/n9p5s/fv3i+ob5o+3HeP3fdPtudlht5CFXsmri45YJ7Y8OEgy34PJB34EdPJj0sHP5Wvb2CABmO4FukM4qND3LOPd9IcREiAmjYXbI7leLu+ntYvVeykMYBJPoLApGnPLmOXYNfdKWfaJFQrCS3wMqw30P0gncftKWAxg5vo0Z5fQ4YMHWpkJNgHYczEW/jXJX3xNX4RA8TgBjDdiHPLE8kDlFo8eb9aYytSresMtzgOaAHlarvQRSj1IOSpbZep1OZ0WyDc/Fk9cvr3/7+asfvw8vHlcFJNN4836Rflju7zfykGEpG+grRRCxUgQRlELV0qDJHaGdMqoVEQL0aGCEDbotTQ2o26I18saftusAKOdeEAohJqEYcx7KotpuNrP5h+nsdpMslSpFbe873GMrcrTVr/1vm80cAL3dRfhZHBjC80NkeIgDDRx627sFNnZzWgQQxkCws2vXwtZXw1tascHA8GMvphu4P1fzwsDKgd9tKxz1DMaQguUc2hIGRigD6gEqWSTpbrHI4jXBanx1/uT1N1//8sP5i5vo0SVlQRYfdvM4ubvfL9f5Jq0OWVWURClQTc0qmHGCSYbmrUDt8ILxDiKwHYJxT4boA51iw0boMca55wdhKCIhxr4fUeB5lm3i+H4xm83exfE8L/aM8ygaj8Uk8AQDVk9T2IBeC5vm2d620VE3ofOsYL/TYADBln+wtP7Rzyka6B1xADp9T9QzvM4wsaUbn1+8bTyAq/WtXdwCzeMse4gAcPpij/uEnnCyadDZAYcDxIkQuuUmKaLLeOpH/CgBBpRTAKzKPN9s9verIt1iVYovJxcvnz169eLRty/Prp8H4zNCPJnJfHvYLzb5Js1WscyyMt0rKVGWWFVEIQU9ptYEzdDWORnjBujkjuoCB0RFAYBSRinl3Pd97vmhiIIgDELBmEcIlFmRbrerxXy5uFstZ0myLoqMe54Io0hMwiDi1AMCRGE7XVsn8VvcE209jMHvtkGPSFu3b11u2FofT6JfH8GNAwZi40ExfwI4Dnw6tNSLDQFsAtpmvmfX7TNYNz5oDo7SAM0d7esdXB4oLXcLG80wQB/bdQv6OQFD9pJGFJlCGCihHIBRIKhkUezSbBPn263MD8yj/igcXz2ePL06v352cXPtR+PJ1aXMFA/CMs1VXlZ5IQ/5YRXLQ4ZSopRYVVhVRKkmjCbYzJkPhNTJWwqUUsYopdQPfDEaccYZZZRRIKzMM5Rqu17tNslqMV0vl0m82qVbWZYEiO8HQoxEOPI9wRknCETVQ3hD9r5V+YTYxQvG88Mm6Ltcpz01vtUfHZ+PSx14WPMM46bhhuafe4qjCHJIYhMUnl+8pX6oY2DzUs3NT9j1E6khfaqHWPEZbkGHfX0ykCNksEgCbZLJdAjEgb61rIs3KQNaT2iGVZXn5WGfJ0meJuUuRSVVJYOzEaXs8vUrJfHpm++CaJIlhzd//Tm+eJLFeywlllKVFZEdB6hSAASa1yESVnOAEI/z+N3833/+9n2eLLfzj7eqrBZ3H1Uli6JgjDHuhaEIxSgMI98LOfOAUKIIQUTVdEyH+wbotax3lzt827OoGA3p1If1u6g13YN+33UHFmiOe4fhnGqXLDx5lu5f50JtLP0PxaDf+v4RkgYAAAAASUVORK5CYII=",ym="data:model/gltf-binary;base64,Z2xURgIAAAA4fAIAMD8AAEpTT057ImFzc2V0Ijp7ImNvcHlyaWdodCI6IkNDLUJZIDQuMCBNb2RlbCBieSBQaXhlbE1hbm5lbiBodHRwczovL29wZW5nYW1lYXJ0Lm9yZy9jb250ZW50L2ZveC1hbmQtc2hpYmEgYW5kIEB0b21rcmFuaXMgaHR0cHM6Ly9za2V0Y2hmYWIuY29tLzNkLW1vZGVscy9sb3ctcG9seS1mb3gtYnktcGl4ZWxtYW5uZW4tYW5pbWF0ZWQtMzcxZGVhODhkN2UwNGE3NmFmNTc2M2YyYTM2ODY2YmMgYW5kIEBBc29ib1N0dWRpbyB3aXRoIEBzY3VyZXN0IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi1TYW1wbGUtTW9kZWxzL3B1bGwvMTUwI2lzc3VlY29tbWVudC00MDYzMDAxMTgiLCJ2ZXJzaW9uIjoiMi4wIn0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE3MjgsInR5cGUiOiJWRUMzIiwiYnl0ZU9mZnNldCI6MCwibWluIjpbLTEyLjU5MjcxODEyNDM4OTY0OCwtMC4xMjE3NDQ3NjY4MzEzOTgwMSwtODguMDk1MDAxMjIwNzAzMTJdLCJtYXgiOlsxMi41OTI3MTgxMjQzODk2NDgsNzguOTA3MTg4NDE1NTI3MzQsNjYuNjI0ODYyNjcwODk4NDRdfSx7ImJ1ZmZlclZpZXciOjEsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxNzI4LCJ0eXBlIjoiVkVDMiIsImJ5dGVPZmZzZXQiOjB9LHsiYnVmZmVyVmlldyI6MSwiY29tcG9uZW50VHlwZSI6NTEyMywiY291bnQiOjE3MjgsInR5cGUiOiJWRUM0IiwiYnl0ZU9mZnNldCI6MTM4MjR9LHsiYnVmZmVyVmlldyI6MiwiYnl0ZU9mZnNldCI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE3MjgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3IjozLCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjQsInR5cGUiOiJNQVQ0In0seyJidWZmZXJWaWV3Ijo0LCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJTQ0FMQVIiLCJtaW4iOlswXSwibWF4IjpbMy40MTY2NjY3NDYxMzk1MjY0XX0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjowLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoxMzI4LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoyNjU2LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozOTg0LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0Ijo1MzEyLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0Ijo2NjQwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0Ijo3OTY4LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0Ijo5Mjk2LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoxMDYyNCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjgzLCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MTE5NTIsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo4MywidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjEzMjgwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoxNDYwOCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjgzLCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MTU5MzYsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo4MywidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjE3MjY0LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoxODU5MiwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjgzLCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MTk5MjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo4MywidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjIxMjQ4LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoyMjU3NiwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjgzLCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MjM5MDQsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo4MywidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjYsImJ5dGVPZmZzZXQiOjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50Ijo4MywidHlwZSI6IlZFQzMifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjI1MjMyLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6ODMsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo0LCJieXRlT2Zmc2V0IjozMzIsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlNDQUxBUiIsIm1pbiI6WzBdLCJtYXgiOlswLjcwODMzMzMxMzQ2NTExODRdfSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjI2NTYwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoyNjg0OCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE4LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MjcxMzYsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjI3NDI0LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoyNzcxMiwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE4LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MjgwMDAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjI4Mjg4LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoyODU3NiwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE4LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6Mjg4NjQsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjI5MTUyLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjoyOTQ0MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE4LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6Mjk3MjgsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjMwMDE2LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozMDMwNCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE4LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MzA1OTIsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjMwODgwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozMTE2OCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE4LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MzE0NTYsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjMxNzQ0LCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo2LCJieXRlT2Zmc2V0Ijo5OTYsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoxOCwidHlwZSI6IlZFQzMifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjMyMDMyLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MTgsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo0LCJieXRlT2Zmc2V0Ijo0MDQsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoyNSwidHlwZSI6IlNDQUxBUiIsIm1pbiI6WzBdLCJtYXgiOlsxLjE1ODMzMzMwMTU0NDE4OTVdfSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjMyMzIwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjUsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozMjcyMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI1LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MzMxMjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoyNSwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjMzNTIwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjUsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozMzkyMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI1LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MzQzMjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoyNSwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjM0NzIwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjUsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozNTEyMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI1LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MzU1MjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoyNSwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjM1OTIwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjUsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozNjMyMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI1LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MzY3MjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoyNSwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjM3MTIwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjUsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozNzUyMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI1LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6Mzc5MjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoyNSwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjM4MzIwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjUsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozODcyMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI1LCJ0eXBlIjoiVkVDNCJ9LHsiYnVmZmVyVmlldyI6NSwiYnl0ZU9mZnNldCI6MzkxMjAsImNvbXBvbmVudFR5cGUiOjUxMjYsImNvdW50IjoyNSwidHlwZSI6IlZFQzQifSx7ImJ1ZmZlclZpZXciOjUsImJ5dGVPZmZzZXQiOjM5NTIwLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjUsInR5cGUiOiJWRUM0In0seyJidWZmZXJWaWV3Ijo2LCJieXRlT2Zmc2V0IjoxMjEyLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjUsInR5cGUiOiJWRUMzIn0seyJidWZmZXJWaWV3Ijo1LCJieXRlT2Zmc2V0IjozOTkyMCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI1LCJ0eXBlIjoiVkVDNCJ9XSwiYW5pbWF0aW9ucyI6W3siY2hhbm5lbHMiOlt7InNhbXBsZXIiOjAsInRhcmdldCI6eyJub2RlIjo4LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoxLCJ0YXJnZXQiOnsibm9kZSI6NywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MiwidGFyZ2V0Ijp7Im5vZGUiOjExLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjozLCJ0YXJnZXQiOnsibm9kZSI6MTAsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjQsInRhcmdldCI6eyJub2RlIjo5LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo1LCJ0YXJnZXQiOnsibm9kZSI6MTQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjYsInRhcmdldCI6eyJub2RlIjoxMywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6NywidGFyZ2V0Ijp7Im5vZGUiOjEyLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo4LCJ0YXJnZXQiOnsibm9kZSI6NiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6OSwidGFyZ2V0Ijp7Im5vZGUiOjUsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEwLCJ0YXJnZXQiOnsibm9kZSI6MTcsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjExLCJ0YXJnZXQiOnsibm9kZSI6MTYsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEyLCJ0YXJnZXQiOnsibm9kZSI6MTUsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEzLCJ0YXJnZXQiOnsibm9kZSI6MjAsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE0LCJ0YXJnZXQiOnsibm9kZSI6MTksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE1LCJ0YXJnZXQiOnsibm9kZSI6MTgsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE2LCJ0YXJnZXQiOnsibm9kZSI6MjQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE3LCJ0YXJnZXQiOnsibm9kZSI6MjMsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE4LCJ0YXJnZXQiOnsibm9kZSI6MjIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE5LCJ0YXJnZXQiOnsibm9kZSI6NCwicGF0aCI6InRyYW5zbGF0aW9uIn19LHsic2FtcGxlciI6MjAsInRhcmdldCI6eyJub2RlIjo0LCJwYXRoIjoicm90YXRpb24ifX1dLCJzYW1wbGVycyI6W3siaW5wdXQiOjUsIm91dHB1dCI6Nn0seyJpbnB1dCI6NSwib3V0cHV0Ijo3fSx7ImlucHV0Ijo1LCJvdXRwdXQiOjh9LHsiaW5wdXQiOjUsIm91dHB1dCI6OX0seyJpbnB1dCI6NSwib3V0cHV0IjoxMH0seyJpbnB1dCI6NSwib3V0cHV0IjoxMX0seyJpbnB1dCI6NSwib3V0cHV0IjoxMn0seyJpbnB1dCI6NSwib3V0cHV0IjoxM30seyJpbnB1dCI6NSwib3V0cHV0IjoxNH0seyJpbnB1dCI6NSwib3V0cHV0IjoxNX0seyJpbnB1dCI6NSwib3V0cHV0IjoxNn0seyJpbnB1dCI6NSwib3V0cHV0IjoxN30seyJpbnB1dCI6NSwib3V0cHV0IjoxOH0seyJpbnB1dCI6NSwib3V0cHV0IjoxOX0seyJpbnB1dCI6NSwib3V0cHV0IjoyMH0seyJpbnB1dCI6NSwib3V0cHV0IjoyMX0seyJpbnB1dCI6NSwib3V0cHV0IjoyMn0seyJpbnB1dCI6NSwib3V0cHV0IjoyM30seyJpbnB1dCI6NSwib3V0cHV0IjoyNH0seyJpbnB1dCI6NSwib3V0cHV0IjoyNX0seyJpbnB1dCI6NSwib3V0cHV0IjoyNn1dLCJuYW1lIjoiU3VydmV5In0seyJjaGFubmVscyI6W3sic2FtcGxlciI6MCwidGFyZ2V0Ijp7Im5vZGUiOjgsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEsInRhcmdldCI6eyJub2RlIjo3LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoyLCJ0YXJnZXQiOnsibm9kZSI6MTEsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjMsInRhcmdldCI6eyJub2RlIjoxMCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6NCwidGFyZ2V0Ijp7Im5vZGUiOjksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjUsInRhcmdldCI6eyJub2RlIjoxNCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6NiwidGFyZ2V0Ijp7Im5vZGUiOjEzLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo3LCJ0YXJnZXQiOnsibm9kZSI6MTIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjgsInRhcmdldCI6eyJub2RlIjo2LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo5LCJ0YXJnZXQiOnsibm9kZSI6NSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTAsInRhcmdldCI6eyJub2RlIjoxNywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTEsInRhcmdldCI6eyJub2RlIjoxNiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTIsInRhcmdldCI6eyJub2RlIjoxNSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTMsInRhcmdldCI6eyJub2RlIjoyMCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTQsInRhcmdldCI6eyJub2RlIjoxOSwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTUsInRhcmdldCI6eyJub2RlIjoxOCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTYsInRhcmdldCI6eyJub2RlIjoyNCwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTcsInRhcmdldCI6eyJub2RlIjoyMywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTgsInRhcmdldCI6eyJub2RlIjoyMiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MTksInRhcmdldCI6eyJub2RlIjo0LCJwYXRoIjoidHJhbnNsYXRpb24ifX0seyJzYW1wbGVyIjoyMCwidGFyZ2V0Ijp7Im5vZGUiOjQsInBhdGgiOiJyb3RhdGlvbiJ9fV0sInNhbXBsZXJzIjpbeyJpbnB1dCI6MjcsIm91dHB1dCI6Mjh9LHsiaW5wdXQiOjI3LCJvdXRwdXQiOjI5fSx7ImlucHV0IjoyNywib3V0cHV0IjozMH0seyJpbnB1dCI6MjcsIm91dHB1dCI6MzF9LHsiaW5wdXQiOjI3LCJvdXRwdXQiOjMyfSx7ImlucHV0IjoyNywib3V0cHV0IjozM30seyJpbnB1dCI6MjcsIm91dHB1dCI6MzR9LHsiaW5wdXQiOjI3LCJvdXRwdXQiOjM1fSx7ImlucHV0IjoyNywib3V0cHV0IjozNn0seyJpbnB1dCI6MjcsIm91dHB1dCI6Mzd9LHsiaW5wdXQiOjI3LCJvdXRwdXQiOjM4fSx7ImlucHV0IjoyNywib3V0cHV0IjozOX0seyJpbnB1dCI6MjcsIm91dHB1dCI6NDB9LHsiaW5wdXQiOjI3LCJvdXRwdXQiOjQxfSx7ImlucHV0IjoyNywib3V0cHV0Ijo0Mn0seyJpbnB1dCI6MjcsIm91dHB1dCI6NDN9LHsiaW5wdXQiOjI3LCJvdXRwdXQiOjQ0fSx7ImlucHV0IjoyNywib3V0cHV0Ijo0NX0seyJpbnB1dCI6MjcsIm91dHB1dCI6NDZ9LHsiaW5wdXQiOjI3LCJvdXRwdXQiOjQ3fSx7ImlucHV0IjoyNywib3V0cHV0Ijo0OH1dLCJuYW1lIjoiV2FsayJ9LHsiY2hhbm5lbHMiOlt7InNhbXBsZXIiOjAsInRhcmdldCI6eyJub2RlIjo4LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjoxLCJ0YXJnZXQiOnsibm9kZSI6NywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6MiwidGFyZ2V0Ijp7Im5vZGUiOjExLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjozLCJ0YXJnZXQiOnsibm9kZSI6MTAsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjQsInRhcmdldCI6eyJub2RlIjo5LCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo1LCJ0YXJnZXQiOnsibm9kZSI6MTQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjYsInRhcmdldCI6eyJub2RlIjoxMywicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6NywidGFyZ2V0Ijp7Im5vZGUiOjEyLCJwYXRoIjoicm90YXRpb24ifX0seyJzYW1wbGVyIjo4LCJ0YXJnZXQiOnsibm9kZSI6NiwicGF0aCI6InJvdGF0aW9uIn19LHsic2FtcGxlciI6OSwidGFyZ2V0Ijp7Im5vZGUiOjUsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEwLCJ0YXJnZXQiOnsibm9kZSI6MTcsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjExLCJ0YXJnZXQiOnsibm9kZSI6MTYsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEyLCJ0YXJnZXQiOnsibm9kZSI6MTUsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjEzLCJ0YXJnZXQiOnsibm9kZSI6MjAsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE0LCJ0YXJnZXQiOnsibm9kZSI6MTksInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE1LCJ0YXJnZXQiOnsibm9kZSI6MTgsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE2LCJ0YXJnZXQiOnsibm9kZSI6MjQsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE3LCJ0YXJnZXQiOnsibm9kZSI6MjMsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE4LCJ0YXJnZXQiOnsibm9kZSI6MjIsInBhdGgiOiJyb3RhdGlvbiJ9fSx7InNhbXBsZXIiOjE5LCJ0YXJnZXQiOnsibm9kZSI6NCwicGF0aCI6InRyYW5zbGF0aW9uIn19LHsic2FtcGxlciI6MjAsInRhcmdldCI6eyJub2RlIjo0LCJwYXRoIjoicm90YXRpb24ifX1dLCJzYW1wbGVycyI6W3siaW5wdXQiOjQ5LCJvdXRwdXQiOjUwfSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo1MX0seyJpbnB1dCI6NDksIm91dHB1dCI6NTJ9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjUzfSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo1NH0seyJpbnB1dCI6NDksIm91dHB1dCI6NTV9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjU2fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo1N30seyJpbnB1dCI6NDksIm91dHB1dCI6NTh9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjU5fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo2MH0seyJpbnB1dCI6NDksIm91dHB1dCI6NjF9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjYyfSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo2M30seyJpbnB1dCI6NDksIm91dHB1dCI6NjR9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjY1fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo2Nn0seyJpbnB1dCI6NDksIm91dHB1dCI6Njd9LHsiaW5wdXQiOjQ5LCJvdXRwdXQiOjY4fSx7ImlucHV0Ijo0OSwib3V0cHV0Ijo2OX0seyJpbnB1dCI6NDksIm91dHB1dCI6NzB9XSwibmFtZSI6IlJ1biJ9XSwiYnVmZmVyVmlld3MiOlt7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6MCwiYnl0ZUxlbmd0aCI6MjA3MzYsImJ5dGVTdHJpZGUiOjEyfSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6MjA3MzYsImJ5dGVMZW5ndGgiOjI3NjQ4LCJieXRlU3RyaWRlIjo4fSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6NDgzODQsImJ5dGVMZW5ndGgiOjI3NjQ4LCJieXRlU3RyaWRlIjoxNn0seyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjc2MDMyLCJieXRlTGVuZ3RoIjoxNTM2LCJieXRlU3RyaWRlIjo2NH0seyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjc3NTY4LCJieXRlTGVuZ3RoIjo1MDQsImJ5dGVTdHJpZGUiOjR9LHsiYnVmZmVyIjowLCJieXRlT2Zmc2V0Ijo3ODA3MiwiYnl0ZUxlbmd0aCI6NDAzMjAsImJ5dGVTdHJpZGUiOjE2fSx7ImJ1ZmZlciI6MCwiYnl0ZU9mZnNldCI6MTE4MzkyLCJieXRlTGVuZ3RoIjoxNTEyLCJieXRlU3RyaWRlIjoxMn0seyJidWZmZXIiOjAsImJ5dGVPZmZzZXQiOjExOTkwNCwiYnl0ZUxlbmd0aCI6MjY3NjR9XSwiYnVmZmVycyI6W3siYnl0ZUxlbmd0aCI6MTQ2NjY4fV0sImltYWdlcyI6W3sibWltZVR5cGUiOiJpbWFnZS9wbmciLCJidWZmZXJWaWV3Ijo3fV0sIm1hdGVyaWFscyI6W3sibmFtZSI6ImZveF9tYXRlcmlhbCIsInBick1ldGFsbGljUm91Z2huZXNzIjp7ImJhc2VDb2xvclRleHR1cmUiOnsiaW5kZXgiOjB9LCJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjU4fX1dLCJtZXNoZXMiOlt7Im5hbWUiOiJmb3gxIiwicHJpbWl0aXZlcyI6W3siYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MCwiVEVYQ09PUkRfMCI6MSwiSk9JTlRTXzAiOjIsIldFSUdIVFNfMCI6M30sIm1hdGVyaWFsIjowfV19XSwibm9kZXMiOlt7ImNoaWxkcmVuIjpbMSwyXSwibmFtZSI6InJvb3QifSx7Im5hbWUiOiJmb3giLCJtZXNoIjowLCJza2luIjowfSx7ImNoaWxkcmVuIjpbM10sIm5hbWUiOiJfcm9vdEpvaW50In0seyJjaGlsZHJlbiI6WzRdLCJuYW1lIjoiYl9Sb290XzAwIiwicm90YXRpb24iOlstMC43MDcxMDgwOTI0ODc1MzkxLDAsMCwwLjcwNzEwNTQ2OTg4MzEyNDJdfSx7ImNoaWxkcmVuIjpbNSwxNSwxOCwyMl0sIm5hbWUiOiJiX0hpcF8wMSIsInJvdGF0aW9uIjpbMC4xMjc2OTA5NDE3NjE3NTU0NywtMC42OTU0ODIwMTkyMzkzNzYyLC0wLjEyNzY5MDIyNjUwNjAxNDQ0LDAuNjk1NDgxODQwNDI1NDQxXSwidHJhbnNsYXRpb24iOlswLDI2Ljc0ODQwMzU0OTE5NDMzNiw0Mi45MzgxNzEzODY3MTg3NV19LHsiY2hpbGRyZW4iOls2XSwibmFtZSI6ImJfU3BpbmUwMV8wMiIsInJvdGF0aW9uIjpbMCwwLC0wLjU5MDQxNTc2MzgyMzgzMTcsMC44MDcwOTkyNjY0MDMwMzc2XSwidHJhbnNsYXRpb24iOlsxMi44NTA2MDExOTYyODkwNjIsMCwwXX0seyJjaGlsZHJlbiI6WzcsOSwxMl0sIm5hbWUiOiJiX1NwaW5lMDJfMDMiLCJyb3RhdGlvbiI6WzAsMCwwLjAxNzQxMTk1MjQwNDI4MTA4MiwwLjk5OTg0ODQwMDQ2NTUyNjFdLCJ0cmFuc2xhdGlvbiI6WzIxLjY1NTc1NDA4OTM1NTQ3LC0wLjAwMDExODI1NTYxNTIzNDM3NSwwXX0seyJjaGlsZHJlbiI6WzhdLCJuYW1lIjoiYl9OZWNrXzA0Iiwicm90YXRpb24iOlswLDAsMC4zMDMzNzkxNDAyODI2NDM0NiwwLjk1Mjg2OTkyNjcxNjg0NDNdLCJ0cmFuc2xhdGlvbiI6WzI1LjY0OTE0MzIxODk5NDE0LDAsMF19LHsibmFtZSI6ImJfSGVhZF8wNSIsInJvdGF0aW9uIjpbMCwwLC0wLjQwMDI4NTQxNTE0ODczNDksMC45MTYzOTA1MjA2OTQ3NTU1XSwidHJhbnNsYXRpb24iOlsxMy4zNzY5NjA3NTQzOTQ1MzEsMCwwXX0seyJjaGlsZHJlbiI6WzEwXSwibmFtZSI6ImJfUmlnaHRVcHBlckFybV8wNiIsInJvdGF0aW9uIjpbMC4wMDA0NjczMjczMjYyMDExNTYyLC0wLjAwMDQ0NjE0ODQ2OTIyNTU5MjgsLTAuNzEyMTc5Mjg4MTExMDY5MSwwLjcwMTk5NzMyNDg4MjU5ODVdLCJ0cmFuc2xhdGlvbiI6WzE4LjY3NzkxMzY2NTc3MTQ4NCwtNC4yOTczNDAzOTMwNjY0MDYsNi45Njc1NzUwNzMyNDIxODc1XX0seyJjaGlsZHJlbiI6WzExXSwibmFtZSI6ImJfUmlnaHRGb3JlQXJtXzA3Iiwicm90YXRpb24iOlswLDAsMC4wMzcxMjU4OTk3NzM0ODc0NCwwLjk5OTMxMDU5NjE0NDE2NjNdLCJ0cmFuc2xhdGlvbiI6WzIzLjA0NTEyNTk2MTMwMzcxLDAsMF19LHsibmFtZSI6ImJfUmlnaHRIYW5kXzA4Iiwicm90YXRpb24iOlstMC4wMTIwMzc0MDY5MTQ3OTcwMTgsLTAuMDA3ODIyMjEwMTI0NjUyNzYsMC40NjA1NjIzMjc3MTg1MTQ4LDAuODg3NTExMjcwOTk4ODc0MV0sInRyYW5zbGF0aW9uIjpbMTkuMzUwMDU1Njk0NTgwMDc4LC0wLjE0NTk4NjU1NzAwNjgzNTk0LDBdfSx7ImNoaWxkcmVuIjpbMTNdLCJuYW1lIjoiYl9MZWZ0VXBwZXJBcm1fMDkiLCJyb3RhdGlvbiI6WzAuMDAwNDk3MjYxOTIyMDk0MDE3NCwtMC4wMDA4ODIxOTIzMTY2NDQyODc1LC0wLjcxMjA4NzQ5Mjk5MTQ2NjMsMC43MDIwOTAwMDYxOTAzOTI3XSwidHJhbnNsYXRpb24iOlsxOC42Nzc5MTc0ODA0Njg3NSwtNC4yOTczNDQyMDc3NjM2NzIsLTYuOTY3OTg3MDYwNTQ2ODc1XX0seyJjaGlsZHJlbiI6WzE0XSwibmFtZSI6ImJfTGVmdEZvcmVBcm1fMDEwIiwicm90YXRpb24iOlswLDAsMC4wMzcxMjU4OTk3NzM0ODc0NCwwLjk5OTMxMDU5NjE0NDE2NjNdLCJ0cmFuc2xhdGlvbiI6WzIzLjA0NTEyNDA1Mzk1NTA3OCwwLDBdfSx7Im5hbWUiOiJiX0xlZnRIYW5kXzAxMSIsInJvdGF0aW9uIjpbMC4wMTY1MTc5MTQ0MDcyMTUwNywwLjAxNDAxMzczOTg3Mzk5Nzc4MSwwLjQ2MDA3NTU3NTIxMjcxLDAuODg3NjE1NDc5MDczNjA5OV0sInRyYW5zbGF0aW9uIjpbMTkuMzUwMDUxODc5ODgyODEyLC0wLjE0NTk5MDM3MTcwNDEwMTU2LDBdfSx7ImNoaWxkcmVuIjpbMTZdLCJuYW1lIjoiYl9UYWlsMDFfMDEyIiwicm90YXRpb24iOlswLDAsMC45ODE4OTI4OTQwNjU2Mjk1LDAuMTg5NDM2OTE0NTIxNDkwNF0sInRyYW5zbGF0aW9uIjpbNC4yNjAzNzU5NzY1NjI1LDE1Ljk1ODc3MDc1MTk1MzEyNSwwXX0seyJjaGlsZHJlbiI6WzE3XSwibmFtZSI6ImJfVGFpbDAyXzAxMyIsInJvdGF0aW9uIjpbMCwwLC0wLjA2OTYxNzE2NjMzODc0NjYsMC45OTc1NzM3ODE4MDgxMjQ0XSwidHJhbnNsYXRpb24iOlsxMi40MTE5MTg2NDAxMzY3MTksMCwwXX0seyJuYW1lIjoiYl9UYWlsMDNfMDE0Iiwicm90YXRpb24iOlswLDAsLTAuMDUzODMyNzQ0ODQyMDc2ODQsMC45OTg1NDk5NjY0OTI3OTc5XSwidHJhbnNsYXRpb24iOlsyNC4yNDAzMjIxMTMwMzcxMSwwLDBdfSx7ImNoaWxkcmVuIjpbMTldLCJuYW1lIjoiYl9MZWZ0TGVnMDFfMDE1Iiwicm90YXRpb24iOlswLC0wLjAwMDE3MTc1MjI1MzY1NTk5MzYsMC45NzAwMTU4ODM0MDIwNjgxLC0wLjI0MzA0MTQ3MDYzNTkxNjFdLCJ0cmFuc2xhdGlvbiI6WzQuODEzNzcwMjk0MTg5NDUzLDUuMTU0MDE4NDAyMDk5NjA5LC02Ljk2ODAwNjEzNDAzMzIwM119LHsiY2hpbGRyZW4iOlsyMF0sIm5hbWUiOiJiX0xlZnRMZWcwMl8wMTYiLCJyb3RhdGlvbiI6WzAsMCwtMC4zNjgwNDM3ODg1NTUxMTY1NSwwLjkyOTgwODQ1ODYxMTc3MDZdLCJ0cmFuc2xhdGlvbiI6WzE4Ljk0NDE3NTcyMDIxNDg0NCwwLDBdfSx7ImNoaWxkcmVuIjpbMjFdLCJuYW1lIjoiYl9MZWZ0Rm9vdDAxXzAxNyIsInJvdGF0aW9uIjpbMC4wMDAyNDg0MTA1OTI5NjY0NjY2LDAsMC40NTg0ODQxMTIyNTg1MDk5LDAuODg4NzAyNTY5NTM1MzMzXSwidHJhbnNsYXRpb24iOlsxNy45NDI4MTE5NjU5NDIzODMsMCwwXX0seyJuYW1lIjoiYl9MZWZ0Rm9vdDAyXzAxOCIsInJvdGF0aW9uIjpbMCwwLDAuNTQ3Mjg4Mjk0OTA5MDI0MywwLjgzNjk0NDE1NzE5MDY1MzNdLCJ0cmFuc2xhdGlvbiI6WzE1Ljc3OTkzODY5NzgxNDk0MSwwLDBdfSx7ImNoaWxkcmVuIjpbMjNdLCJuYW1lIjoiYl9SaWdodExlZzAxXzAxOSIsInJvdGF0aW9uIjpbMCwwLDAuOTY5OTU4NTk0MjA1NDUzNSwtMC4yNDMyNzAwNjcwNTkxODUzM10sInRyYW5zbGF0aW9uIjpbNC44MTM3Nzc5MjM1ODM5ODQsNS4xNTQwMjYwMzE0OTQxNDEsNi45Njc1NjM2MjkxNTAzOTFdfSx7ImNoaWxkcmVuIjpbMjRdLCJuYW1lIjoiYl9SaWdodExlZzAyXzAyMCIsInJvdGF0aW9uIjpbMCwwLC0wLjM2ODA0MzgxNDMyMDUyODg1LDAuOTI5ODA4NDQ4NDEzMTEwNl0sInRyYW5zbGF0aW9uIjpbMTguOTQ0MTgzMzQ5NjA5Mzc1LDAsMF19LHsiY2hpbGRyZW4iOlsyNV0sIm5hbWUiOiJiX1JpZ2h0Rm9vdDAxXzAyMSIsInJvdGF0aW9uIjpbLTAuMDAwMTUzNDU0NTU4NzY4MDMxNjMsMCwwLjQ1NzkwOTM3NDYxNjgzNDYsMC44ODg5OTg4NjQ1MDQxNzhdLCJ0cmFuc2xhdGlvbiI6WzE3Ljk0MjgxMDA1ODU5Mzc1LDAsMF19LHsibmFtZSI6ImJfUmlnaHRGb290MDJfMDIyIiwicm90YXRpb24iOlswLDAsMC41NDcyODgyOTQ5MDkwMjQzLDAuODM2OTQ0MTU3MTkwNjUzM10sInRyYW5zbGF0aW9uIjpbMTUuNzc5OTM1ODM2NzkxOTkyLDAsMF19XSwic2FtcGxlcnMiOlt7Im1hZ0ZpbHRlciI6OTcyOSwibWluRmlsdGVyIjo5OTg3fV0sInNjZW5lIjowLCJzY2VuZXMiOlt7Im5vZGVzIjpbMF19XSwic2tpbnMiOlt7ImludmVyc2VCaW5kTWF0cmljZXMiOjQsImpvaW50cyI6WzIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNV0sInNrZWxldG9uIjoyfV0sInRleHR1cmVzIjpbeyJzYW1wbGVyIjowLCJzb3VyY2UiOjB9XX0gICDsPAIA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AwAQAAIAAgAKAAQAAgACAAIAEAACAAIAAgAQAAIAAgACAA0AAgACAAQABQAHAAoACgAEAAIAAgAKAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAUABAACAAIACgACAAIAAgAFAAQAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAIAEAACAAIAAwACAAIAAgACABAAEQACAAQABQAHAAoABAAKAAcAAgAKAAQAAgACAAIADQACAAIAAgAQAAIAAgACAA0AAgACAAMAAgACAAIAAwACAAIAAgACABAAAgACAAIAEAARAAIAAwACAAIAAgACAAIAAgACAAoAAgACAAIACgAEAAIAAgAKAAIAAgACAA8AAgACAAIADwAOAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAAIAFAACAAIAAgANAAIAAgACABAAFAACAAoAAgACAAIABQAEAAIAAgAFAAQAAgACAAUABAACAAIABAAFAAcACgAKAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAcAAgACAAIABwAIAAIAAgAHAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAIAFAACAAIAAgANAAIAAgACABQAAgACAAMAAgACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIAAgAUAAIAAgADAAIAAgACAAIAEAAUAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAUAAIAAgACABAAFAACAAIAFAACAAIAFQAUAAIAAgACABQAAgACAAcAAgACAAIACAAHAAIAAgAHAAgAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAA8ADgACAAIADwACAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAAMAAgACAAIABwAEAAIAAgADABQAAgACAAIAFAACAAIAAgANAAIAAgACABQAAgACAAQABQAHAAoABwACAAIAAgAHAAQAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAUABAACAAIABQAEAAIAAgAHAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAIAFAACAAIAAgAUABUAAgADAAIAAgACAAQABQAHAAoABwAEAAIAAgAEAAoABwACAAIADQACAAIAAgANAAIAAgACABQAAgACAAMAAgACAAIAAgAUAAIAAgADAAIAAgACAAIAFAAVAAIAAgAUAAIAAgACAAIAAgACAAcAAgACAAIABwACAAIAAgAHAAQAAgACAA8AAgACAAIADwACAAIAAgAPAA4AAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAA8AAgACAAIADwACAAIAAgAPAAIAAgACAAcAAgACAAIABAAFAAcACgAFAAQAAgACAAUABAACAAIABQAEAAIAAgAHAAIAAgACAAoAAgACAAIACgACAAIAAgAKAAIAAgACAAoAAgACAAIACgAEAAIAAgAKAAIAAgACAAoAAgACAAIACwAKAAIAAgAKAAsAAgACAAoACwACAAIACgACAAIAAgAKAAIAAgACAAcAAgACAAIABwAEAAIAAgAHAAIAAgACAAcAAgACAAIABwACAAIAAgAHAAIAAgACAAoACwACAAIACgACAAIAAgAKAAQAAgACAAoABAACAAIABAAKAAcAAgAKAAsAAgACAAcACAACAAIABAAKAAcAAgAHAAQAAgACAAcABAACAAIABwACAAIAAgAHAAgAAgACAAcAAgACAAIABwACAAIAAgAHAAgAAgACAAcACAACAAIACAAHAAIAAgAHAAIAAgACAAMAFAACAAIAAgAUAAIAAgACABQAAgACAAIAFAACAAIAAwACAAIAAgADABQAAgACAAQACgAHAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIABAAKAAcAAgAHAAQAAgACAAcABAACAAIAAwACAAIAAgADAAIAAgACAAMAEAACAAIAAwACAAIAAgACABAAAgACAAIAEAACAAIAAgAQAAIAAgADABAAAgACAAQACgAHAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIAAwACAAIAAgAKAAQAAgACAAoABAACAAIABAAKAAcAAgADAAIAAgACAAMAAgACAAIAAgACAAIAAgACAAIAAgACAAMAAgACAAIAAgACAAIAAgACAAIAAgACAAMAAgACAAIAAgAUABUAAgACAAIAAgACAAIAEAACAAIAAgAQABEAAgACAAIAAgACAAUABAACAAIABQAEAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAFAAQAAgACAAUABAACAAIABQAEAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAFAAQAAgACAAUABAACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABQAEAAIAAgAFAAQAAgACAAUABAACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABQAEAAIAAgAFAAQAAgACAAIADQACAAIAAgANAAIAAgANAA4AAgACAA0ADgACAAIAAgANAAIAAgANAA4AAgACAAoABAACAAIAAwAQAAIAAgADABAAAgACAAMAEAACAAIACgAEAAIAAgAKAAQAAgACAAMAAgACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIAAgACAAIAAgADAAIAAgACAAIADQACAAIAAgAQAAIAAgACAA0AAgACAAIAAgACAAIAAgAQAAIAAgACABAAAgACAAIAEAACAAIAAgAQAAIAAgACAA0AAgACAAoABAACAAIACgAEAAIAAgAKAAsAAgACAAQAAgACAAIABAACAAIAAgAFAAQAAgACAAQAAgACAAIABAACAAIAAgAFAAQAAgACAAYAAgACAAIABQAEAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAUABAACAAIABQAEAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAUABAACAAIABQAEAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAIADQACAAIAAgANAAIAAgANAA4AAgACAAIAEAACAAIAAgAQAAIAAgARABAAAgACAA0ADgACAAIADQAOAAIAAgAPAA4AAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAIAAgACAAIAAgACAAIAAgACAA0AAgACAAIADQACAAIAAgANAAIAAgACAA0AAgACAAIAEAACAAIAAgAQAAIAAgAQABEAAgACAAIAEAACAAIAAgAQAAIAAgARABAAAgACAAIAEAACAAIAAgAQAAIAAgARABAAAgACAAIAEAACAAIAAgAQAAIAAgARABAAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACABEAEAACAAIAAgAQABEAAgARABIAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACABEAEAACAAIAEQAQAAIAAgARAAIAAgACABAAEQACAAIAEQAQAAIAAgARAAIAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACAAoACwACAAIACgALAAIAAgALAAIAAgACAAsACgACAAIACgALAAIAAgALAAIAAgACAAcAAgACAAIABwACAAIAAgAHAAIAAgACAAcAAgACAAIABwACAAIAAgAHAAIAAgACAAQACgAHAAIACgAEAAIAAgAKAAsAAgACAAoACwACAAIACgALAAIAAgALAAIAAgACAA0ADgACAAIAAgANAAIAAgANAA4AAgACAA0ADgACAAIADwAOAAIAAgANAA4AAgACAAIADQACAAIAAgANAAIAAgANAA4AAgACAA0ADgACAAIADQAOAAIAAgACAA0AAgACAA8ADgACAAIADwAOAAIAAgAPAAIAAgACAA8ADgACAAIADwAOAAIAAgAPAAIAAgACAA8ADgACAAIADwAOAAIAAgAPAAIAAgACAA8ADgACAAIADwAOAAIAAgAPAAIAAgACAA8ADgACAAIADwAOAAIAAgAPAAIAAgACABEAEAACAAIAAgAQAAIAAgACABAAEQACAAMAAgACAAIAAgACAAIAAgACAAIAAgACAAIADQACAAIAAgANAAIAAgACAA0AAgACAAIADQACAAIAAgANAAIAAgACAA0AAgACAAIADQACAAIAAgACAAIAAgACABAAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAIADQACAAIAAgAQAAIAAgACAA0AAgACAAUABAACAAIABAACAAIAAgAFAAQAAgACAAUABAACAAIABAACAAIAAgAFAAQAAgACAAoACwACAAIACgAEAAIAAgAKAAsAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABQAEAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAoACwACAAIACgAEAAIAAgAKAAsAAgACAAoAAgACAAIACgACAAIAAgAKAAIAAgACAAMAEAACAAIAAwACAAIAAgAKAAQAAgACAA0ADgACAAIAAgANAAIAAgACAA0AAgACABAAEQACAAIAAgAQAAIAAgARABAAAgACAA8ADgACAAIADQAOAAIAAgAPAA4AAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAIADQACAAIAAgACAAIAAgACAA0AAgACABEAEAACAAIAAgAQAAIAAgAQABEAAgACAAMAAgACAAIAAwACAAIAAgACAAIAAgACABEAEAACAAIAAgAQAAIAAgARABAAAgACABEAEAACAAIAAgAQAAIAAgARABAAAgACABEAEAACAAIAAgAQAAIAAgARABAAAgACABEAEgACAAIAAgAQABEAAgARABIAAgACAAoACwACAAIABAAKAAcAAgAKAAsAAgACAAsAAgACAAIACgALAAIAAgALAAoAAgACAA8ADgACAAIADQAOAAIAAgAPAA4AAgACAA8ADgACAAIADQAOAAIAAgAPAA4AAgACAA8ADgACAAIADQAOAAIAAgAPAA4AAgACAA8ADgACAAIADQAOAAIAAgANAA4AAgACAA8AAgACAAIADwAOAAIAAgAPAAIAAgACAA8AAgACAAIADwAOAAIAAgAPAAIAAgACAA8AAgACAAIADwAOAAIAAgAPAAIAAgACAAIADQACAAIADQAOAAIAAgACAA0AAgACAA0ADgACAAIADQAOAAIAAgACAA0AAgACAAcABAACAAIAAwAUAAIAAgADABQAAgACAAMAFAACAAIABwAEAAIAAgAHAAQAAgACAAIAAgACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIAAwACAAIAAgACAAIAAgACAAQAAgACAAIABwACAAIAAgAHAAIAAgACAAcAAgACAAIABAACAAIAAgAEAAIAAgACAAIADQACAAIAAgANAAIAAgACABQAAgACAAIAAgACAAIAAgAUAAIAAgACABQAAgACAAIAFAACAAIAAgANAAIAAgACABQAAgACAAcABAACAAIABwAIAAIAAgAHAAQAAgACAAQAAgACAAIABQAEAAIAAgAEAAIAAgACAAQAAgACAAIABQAEAAIAAgAEAAIAAgACAAYAAgACAAIABgACAAIAAgAFAAQAAgACAAQAAgACAAIABQAEAAIAAgAFAAQAAgACAAUABAACAAIACgACAAIAAgAEAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAUABAACAAIABgACAAIAAgAFAAQAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAUABAACAAIABgACAAIAAgAFAAQAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAIADQACAAIADQAOAAIAAgACAA0AAgACAAIAFAACAAIAFQAUAAIAAgACABQAAgACAA0ADgACAAIADwAOAAIAAgANAA4AAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAIAAgACAAIAAgANAAIAAgACAAIAAgACAAIADQACAAIAAgANAAIAAgACAA0AAgACAAIAFAACAAIAFAAVAAIAAgACABQAAgACAAIAFAACAAIAFQAUAAIAAgACABQAAgACAAIAFAACAAIAFQAUAAIAAgACABQAAgACAAIAFAACAAIAFQAUAAIAAgACABQAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACABUAFAACAAIAFQAWAAIAAgACABQAFQACABUAFgACAAIAFQAWAAIAAgAVABYAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACABUAFAACAAIAFQACAAIAAgAVABQAAgACABQAFQACAAIAFQACAAIAAgAVABQAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACAAcACAACAAIACAACAAIAAgAHAAgAAgACAAgABwACAAIACAACAAIAAgAHAAgAAgACAAQACgAHAAIABwAIAAIAAgAHAAQAAgACAAcACAACAAIACAACAAIAAgAHAAgAAgACAA0ADgACAAIADwAOAAIAAgANAA4AAgACAA0ADgACAAIADwAOAAIAAgANAA4AAgACAA0ADgACAAIADwAOAAIAAgAPAA4AAgACAA8ADgACAAIADQAOAAIAAgANAA4AAgACAA8ADgACAAIADwACAAIAAgAPAA4AAgACAA8ADgACAAIADwACAAIAAgAPAA4AAgACAA8ADgACAAIADwACAAIAAgAPAA4AAgACAA8ADgACAAIADwACAAIAAgAPAA4AAgACAA8ADgACAAIADwACAAIAAgAPAA4AAgACABUAFAACAAIAAgAUABUAAgACABQAAgACAAMAAgACAAIAAgACAAIAAgACAAIAAgACAAIADQACAAIAAgANAAIAAgACAA0AAgACAAIADQACAAIAAgANAAIAAgACAA0AAgACAAIADQACAAIAAgAUAAIAAgACAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAIADQACAAIAAgANAAIAAgACABQAAgACAAUABAACAAIABQAEAAIAAgAEAAIAAgACAAUABAACAAIABAACAAIAAgAFAAQAAgACAAcACAACAAIABwAIAAIAAgAHAAQAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAFAAQAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAcACAACAAIABwAIAAIAAgAHAAQAAgACAAcAAgACAAIABwACAAIAAgAHAAIAAgACAAMAFAACAAIABwAEAAIAAgADAAIAAgACAA0ADgACAAIAAgANAAIAAgACAA0AAgACABQAFQACAAIAFQAUAAIAAgACABQAAgACAA8ADgACAAIADwAOAAIAAgANAA4AAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAIADQACAAIAAgANAAIAAgACAAIAAgACABUAFAACAAIAFAAVAAIAAgACABQAAgACAAMAAgACAAIAAgACAAIAAgADAAIAAgACABUAFAACAAIAFQAUAAIAAgACABQAAgACABUAFAACAAIAFQAUAAIAAgACABQAAgACABUAFAACAAIAFQAUAAIAAgACABQAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACAAcACAACAAIABAAKAAcAAgAHAAgAAgACAAgAAgACAAIACAAHAAIAAgAHAAgAAgACAA8ADgACAAIADwAOAAIAAgANAA4AAgACAA8ADgACAAIADwAOAAIAAgANAA4AAgACAA8ADgACAAIADwAOAAIAAgANAA4AAgACAA0ADgACAAIADQAOAAIAAgAPAA4AAgACAA8ADgACAAIADwAOAAIAAgANAA4AAgACAA8AAgACAAIADwACAAIAAgAPAA4AAgACAA8AAgACAAIADwACAAIAAgAPAA4AAgACAA8AAgACAAIADwACAAIAAgAPAA4AAgACABEAEgACAAIAEQASAAIAAgACABAAEQACAAIAEAARAAIAAgAQAAIAAgARABIAAgACAAQAAgACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIABAACAAIAAgAEAAIAAgACAAoABAACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIABAACAAIAAgAKAAQAAgACAAcABAACAAIABwAIAAIAAgAHAAIAAgACAAQAAgACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIABwAEAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgADAAIAAgACAAMAAgACAAIAAwACAAIAAgAEAAIAAgACAAoAAgACAAIACgACAAIAAgAKAAIAAgACAAoAAgACAAIACgACAAIAAgAKAAIAAgACAAcACAACAAIACAAHAAIAAgAHAAIAAgACAAcAAgACAAIABwACAAIAAgAHAAgAAgACAAcACAACAAIABwAIAAIAAgAHAAIAAgACAAoAAgACAAIACgALAAIAAgAKAAsAAgACAAoACwACAAIACgACAAIAAgAKAAIAAgACAAoAAgACAAIACgALAAIAAgALAAoAAgACAAsACgACAAIACgACAAIAAgAKAAIAAgACAAcAAgACAAIABwACAAIAAgAIAAcAAgACAAgABwACAAIABwAIAAIAAgAHAAIAAgACAAsACgACAAIACgALAAIAAgAKAAsAAgACAAgABwACAAIABwAIAAIAAgAHAAgAAgACAAoACwACAAIACgACAAIAAgALAAoAAgACAAoAAgACAAIACgALAAIAAgAKAAIAAgACAAoAAgACAAIACgACAAIAAgAKAAIAAgACAAQAAgACAAIABAACAAIAAgAKAAIAAgACAAoAAgACAAIACgACAAIAAgAEAAIAAgACAAoAAgACAAIACgAEAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAKAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAcAAgACAAIABwACAAIAAgAHAAgAAgACAAcACAACAAIABwACAAIAAgAHAAIAAgACAAoABAACAAIACgACAAIAAgAKAAsAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgAHAAQAAgACAAcABAACAAIABwACAAIAAgAEAAIAAgACABEAEgACAAIAEQASAAIAAgARABAAAgACABEAEAACAAIAEQAQAAIAAgARABIAAgACABEAEgACAAIAEQASAAIAAgACABAAAgACAAIAEAACAAIAEQAQAAIAAgARABIAAgACABEAEgACAAIAEQASAAIAAgARABAAAgACABEAEAACAAIAEQAQAAIAAgARABIAAgACABUAFgACAAIAFQAUAAIAAgAVABQAAgACABUAFAACAAIAFQAWAAIAAgAVABYAAgACABUAFgACAAIAFQAUAAIAAgAVABQAAgACABUAFAACAAIAFQAWAAIAAgAVABYAAgACABUAFAACAAIAFQAWAAIAAgAUABUAAgACABEAEAACAAIAEAARAAIAAgARABIAAgACABUAFgACAAIAAgAUAAIAAgACABQAFQACAAIAFAAVAAIAFQAWAAIAAgAVABYAAgACABUAFgACAAIAFQAUAAIAAgACABQAAgACAAIAFAACAAIAFQAWAAIAAgAVABYAAgACAAIAFAAVAAIAFQAWAAIAAgAVABYAAgACAAIADQACAAIADQAOAAIAAgANAA4AAgACAA0ADgACAAIAAgANAAIAAgACAA0AAgACAAIADQACAAIADQAOAAIAAgANAA4AAgACAAIADQACAAIADQAOAAIAAgANAA4AAgACAAIADQACAAIADQAOAAIAAgANAA4AAgACAAQAAgACAAIAAwACAAIAAgADAAIAAgACAAQAAgACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIAAwACAAIAAgAEAAIAAgACAAQAAgACAAIABAACAAIAAgADAAIAAgACAAMAAgACAAIAAwACAAIAAgACABAAAgACAAIAEAACAAIAAgACAAIAAgADAAIAAgACAAMAAgACAAIAAwAQAAIAAgACABAAAgACAAIAEAACAAIAAgAQAAIAAgADAAIAAgACAAIAEAACAAIAAwACAAIAAgADAAIAAgACAAIAEAACAAIAAwAQAAIAAgADABAAAgACAAIAFAACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIABAACAAIAAgAEAAIAAgACAAQAAgACAAIAAwACAAIAAgADAAIAAgACAAMAAgACAAIAAgACAAIAAgACABQAAgACAAIAFAACAAIAAwACAAIAAgADAAIAAgACAAIAFAACAAIAAwAUAAIAAgADABQAAgACAAMAAgACAAIAAgAUAAIAAgACABQAAgACAAIAFAACAAIAAwAUAAIAAgADAAIAAgACAAQAAgACAAIABwACAAIAAgAFAAQAAgACAAUABAACAAIABQAEAAIAAgAEAAIAAgACAAUABAACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABQAEAAIAAgAFAAQAAgACAAUABAACAAIABQAEAAIAAgAKAAIAAgACAAoAAgACAAIACgACAAIAAgAFAAQAAgACAAUABAACAAIABwACAAIAAgAHAAIAAgACAAcAAgACAAIABQAEAAIAAgAFAAQAAgACAAUABAACAAIABQAEAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAFAAQAAgACAAYAAgACAAIABQAEAAIAAgAFAAQAAgACAAYAAgACAAIABQAEAAIAAgAFAAQAAgACABEAEgACAAIAEQACAAIAAgASABEAAgACABEAEgACAAIAEQASAAIAAgATABIAAgACABEAEgACAAIAEgARAAIAAgASABMAAgACABMAEgACAAIAEgATAAIAAgATAAIAAgACABEAEgACAAIAEQASAAIAAgATABIAAgACABIAEQACAAIAEQASAAIAAgASABMAAgACABEAEgACAAIAEQASAAIAAgASABMAAgACABEAEgACAAIAEQASAAIAAgASABMAAgACABMAAgACAAIAEwASAAIAAgATAAIAAgACABMAAgACAAIAEwACAAIAAgATAAIAAgACABMAEgACAAIAEwACAAIAAgATAAIAAgACABMAAgACAAIAEgATAAIAAgATAAIAAgACABIAEwACAAIAEgATAAIAAgATAAIAAgACABIAEwACAAIAEgATAAIAAgATAAIAAgACAAsAAgACAAIACwACAAIAAgAMAAsAAgACAAsAAgACAAIADAALAAIAAgALAAIAAgACAAsAAgACAAIACwACAAIAAgAMAAsAAgACAAsAAgACAAIACwACAAIAAgAMAAsAAgACAAsAAgACAAIACwACAAIAAgAMAAsAAgACAAsAAgACAAIACwAKAAIAAgALAAIAAgACAAwAAgACAAIADAALAAIAAgAMAAIAAgACAAwAAgACAAIADAACAAIAAgAMAAIAAgACAAwACwACAAIADAALAAIAAgAMAAIAAgACAAwACwACAAIADAALAAIAAgAMAAIAAgACAAwACwACAAIADAALAAIAAgAMAAIAAgACAAwACwACAAIADAALAAIAAgAMAAIAAgACAAwACwACAAIADAALAAIAAgAMAAIAAgACABEAEgACAAIAEQAQAAIAAgARABIAAgACABEAAgACAAIAEQAQAAIAAgARABIAAgACABEAEgACAAIAEQAQAAIAAgARABIAAgACABIAEQACAAIAEQACAAIAAgARABIAAgACABEAEgACAAIAEAARAAIAAgARAAIAAgACABIAEwACAAIAEQASAAIAAgATABIAAgACABIAEwACAAIAEgARAAIAAgASABMAAgACABMAEgACAAIAEQASAAIAAgATABIAAgACABIAEwACAAIAEgARAAIAAgASABMAAgACABMAEgACAAIAEQASAAIAAgASABMAAgACABMAAgACAAIAEwASAAIAAgATABIAAgACABMAAgACAAIAEwACAAIAAgATAAIAAgACABMAEgACAAIAEwACAAIAAgATAAIAAgACABMAAgACAAIAEwACAAIAAgATAAIAAgACABMAAgACAAIAEgATAAIAAgATABIAAgACABMAAgACAAIAEgATAAIAAgATAAIAAgACAAsAAgACAAIACgALAAIAAgALAAIAAgACAAwACwACAAIACwACAAIAAgAMAAsAAgACAAsAAgACAAIACwAKAAIAAgALAAIAAgACAAsAAgACAAIACwAKAAIAAgALAAIAAgACAAsAAgACAAIACgALAAIAAgALAAIAAgACAAwACwACAAIACwACAAIAAgAMAAsAAgACAAwACwACAAIACwACAAIAAgAMAAsAAgACAAwAAgACAAIADAALAAIAAgAMAAIAAgACAAwACwACAAIADAALAAIAAgAMAAsAAgACAAwAAgACAAIADAACAAIAAgAMAAIAAgACAAwAAgACAAIADAACAAIAAgAMAAIAAgACAAwAAgACAAIADAALAAIAAgAMAAIAAgACAAwAAgACAAIADAALAAIAAgAMAAIAAgACAAwAAgACAAIADAALAAIAAgAMAAIAAgACABUAFgACAAIAFgAVAAIAAgAVAAIAAgACABUAFgACAAIAFwAWAAIAAgAVABYAAgACABUAFgACAAIAFgAXAAIAAgAWABUAAgACABcAFgACAAIAFwACAAIAAgAWABcAAgACABUAFgACAAIAFwAWAAIAAgAVABYAAgACABYAFQACAAIAFgAXAAIAAgAVABYAAgACABUAFgACAAIAFgAXAAIAAgAVABYAAgACABUAFgACAAIAFgAXAAIAAgAVABYAAgACABcAAgACAAIAFwACAAIAAgAXABYAAgACABcAAgACAAIAFwACAAIAAgAXAAIAAgACABcAFgACAAIAFwACAAIAAgAXAAIAAgACABcAAgACAAIAFwACAAIAAgAWABcAAgACABYAFwACAAIAFwACAAIAAgAWABcAAgACABYAFwACAAIAFwACAAIAAgAWABcAAgACAAgAAgACAAIACQAIAAIAAgAIAAIAAgACAAgAAgACAAIACQAIAAIAAgAIAAIAAgACAAgAAgACAAIACQAIAAIAAgAIAAIAAgACAAgAAgACAAIACQAIAAIAAgAIAAIAAgACAAgAAgACAAIACQAIAAIAAgAIAAIAAgACAAgAAgACAAIACQAIAAIAAgAIAAIAAgACAAkAAgACAAIACQACAAIAAgAJAAgAAgACAAkAAgACAAIACQACAAIAAgAJAAIAAgACAAkACAACAAIACQACAAIAAgAJAAgAAgACAAkACAACAAIACQACAAIAAgAJAAgAAgACAAkACAACAAIACQACAAIAAgAJAAgAAgACAAkACAACAAIACQACAAIAAgAJAAgAAgACAAkACAACAAIACQACAAIAAgAJAAgAAgACABUAFgACAAIAFQAWAAIAAgAVABQAAgACABUAAgACAAIAFQAWAAIAAgAVABQAAgACABUAFgACAAIAFQAWAAIAAgAVABQAAgACABYAFQACAAIAFQAWAAIAAgAVAAIAAgACABUAFgACAAIAFQACAAIAAgAUABUAAgACABYAFwACAAIAFwAWAAIAAgAVABYAAgACABYAFwACAAIAFgAXAAIAAgAWABUAAgACABcAFgACAAIAFwAWAAIAAgAVABYAAgACABYAFwACAAIAFgAXAAIAAgAWABUAAgACABcAFgACAAIAFgAXAAIAAgAVABYAAgACABcAAgACAAIAFwAWAAIAAgAXABYAAgACABcAAgACAAIAFwACAAIAAgAXAAIAAgACABcAFgACAAIAFwACAAIAAgAXAAIAAgACABcAAgACAAIAFwACAAIAAgAXAAIAAgACABcAAgACAAIAFwAWAAIAAgAWABcAAgACABcAAgACAAIAFwACAAIAAgAWABcAAgACAAgAAgACAAIACAACAAIAAgAHAAgAAgACAAkACAACAAIACQAIAAIAAgAIAAIAAgACAAgAAgACAAIACAACAAIAAgAIAAcAAgACAAgAAgACAAIACAACAAIAAgAIAAcAAgACAAgAAgACAAIACAACAAIAAgAHAAgAAgACAAkACAACAAIACQAIAAIAAgAIAAIAAgACAAkACAACAAIACQAIAAIAAgAIAAIAAgACAAkAAgACAAIACQACAAIAAgAJAAgAAgACAAkACAACAAIACQAIAAIAAgAJAAgAAgACAAkAAgACAAIACQACAAIAAgAJAAIAAgACAAkAAgACAAIACQACAAIAAgAJAAIAAgACAAkAAgACAAIACQACAAIAAgAJAAgAAgACAAkAAgACAAIACQACAAIAAgAJAAgAAgACAAkAAgACAAIACQACAAIAAgAJAAgAAgACAAsAAgACAAIADAALAAIAAgAMAAsAAgACAAwACwACAAIACwACAAIAAgALAAIAAgACAAgAAgACAAIACAACAAIAAgAJAAgAAgACAAkACAACAAIACQAIAAIAAgAIAAIAAgACAAgAAgACAAIACAACAAIAAgAJAAgAAgACAAkACAACAAIACQAIAAIAAgAIAAIAAgACAAsAAgACAAIACwACAAIAAgALAAoAAgACAAsACgACAAIACgALAAIAAgALAAIAAgACAAsAAgACAAIADAALAAIAAgAMAAsAAgACAAwACwACAAIACwACAAIAAgALAAIAAgACAAsAAgACAAIADAALAAIAAgAMAAsAAgACAAwACwACAAIACwACAAIAAgALAAIAAgACAAgAAgACAAIABwAIAAIAAgAHAAgAAgACAAcACAACAAIACAACAAIAAgAIAAIAAgACAAgAAgACAAIACAAHAAIAAgAHAAgAAgACAAcACAACAAIACAACAAIAAgAIAAIAAgACAAsAAgACAAIACwACAAIAAgAKAAsAAgACAAoACwACAAIACgALAAIAAgALAAIAAgACAAsAAgACAAIACwACAAIAAgAKAAsAAgACAAoACwACAAIACwAKAAIAAgALAAIAAgACAAgAAgACAAIABwAIAAIAAgAIAAcAAgACAAgABwACAAIACAACAAIAAgAIAAIAAgACAAgAAgACAAIACAACAAIAAgAJAAgAAgACAAkACAACAAIACQAIAAIAAgAIAAIAAgACAAwACwACAAIACwACAAIAAgALAAIAAgACAAsACgACAAIACwACAAIAAgALAAIAAgACAAgABwACAAIACAACAAIAAgAIAAIAAgACAAgABwACAAIACAACAAIAAgAIAAIAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACABUAFgACAAIAFQAWAAIAAgAVABQAAgACABUAFgACAAIAFQAWAAIAAgAVABYAAgACABEAEgACAAIAEQAQAAIAAgARABIAAgACABEAEgACAAIAEQASAAIAAgARABIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAAYAAgACAAIABgACAAIAAgAGAAIAAgACAJqZGT/NzMw+AAAAAAAAAADaPzM/mpkZPgJnGT4AAAAACtdjP65H4T0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAJqZGT/NzMw+AAAAAAAAAACamRk/zczMPgAAAAAAAAAACtdjP65H4T0AAAAAAAAAAChcDz+wR+E+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zMxMPgAAAAAAAAAAKFwPP7BH4T4AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADaPzM/mpkZPgJnGT4AAAAAmpkZP83MzD4AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAACamRk/zczMPgAAAAAAAAAAGIVrP0HXoz0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAACkcD0/uB6FPgAAAAAAAAAAFK5HP7BHYT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAACamRk/zczMPgAAAAAAAAAACtdjP65H4T0AAAAAAAAAAJvCFz+4HoU+Uo2XPfvilT1mZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAChcDz+wR+E+AAAAAAAAAADNzEw/zMxMPgAAAAAAAAAAgW4UPwE0pj72u8M9AAAAAJvCFz+4HoU+Uo2XPfvilT3K1Ew/zczMPdyMzD0AAAAAZmZmP83MzD0AAAAAAAAAAArXYz+uR+E9AAAAAAAAAACamRk/zczMPgAAAAAAAAAACtdjP65H4T0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAKFwPP7BH4T4AAAAAAAAAAIFuFD8BNKY+9rvDPQAAAADNzEw/zMxMPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAA2j8zP5qZGT4CZxk+AAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAACbwhc/uB6FPlKNlz374pU9AACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAM3MTD/MzEw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAoXA8/sEfhPgAAAAAAAAAAzcxMP8zMTD4AAAAAAAAAANo/Mz+amRk+AmcZPgAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAACamRk/zczMPgAAAAAAAAAA2j8zP5qZGT4CZxk+AAAAAJqZGT/NzMw+AAAAAAAAAAAYhWs/QdejPQAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAUrkc/sEdhPgAAAAAAAAAApHA9P7gehT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAJvCFz+4HoU+Uo2XPfvilT0AAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAChcDz+wR+E+AAAAAAAAAACBbhQ/ATSmPva7wz0AAAAAzcxMP8zMTD4AAAAAAAAAAJvCFz+4HoU+Uo2XPfvilT1mZmY/zczMPQAAAAAAAAAAytRMP83MzD3cjMw9AAAAAArXYz+uR+E9AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAoXA8/sEfhPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAIFuFD8BNKY+9rvDPQAAAACamRk/zczMPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAACbwhc/uB6FPlKNlz374pU9MzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAUrkc/sEdhPgAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAKRwPT+4HoU+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAADK1Ew/zczMPdyMzD0AAAAApHA9P7gehT4AAAAAAAAAAKRwPT+4HoU+AAAAAAAAAADK1Ew/zczMPdyMzD0AAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAApHA9P7gehT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAAAUrkc/sEdhPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAKFwPP7BH4T4AAAAAAAAAAChcDz+wR+E+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAMrUTD/NzMw93IzMPQAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADK1Ew/zczMPdyMzD0AAAAAzcxMP83MTD4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAKFwPP7BH4T4AAAAAAAAAAChcDz+wR+E+AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAMrUTD/NzMw93IzMPQAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAADK1Ew/zczMPdyMzD0AAAAAAACAPwAAAAAAAAAAAAAAAM3MTD/MzEw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAM3MTD/MzEw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAM3MTD/MzEw+AAAAAAAAAACBbhQ/ATSmPva7wz0AAAAAAACAPwAAAAAAAAAAAAAAAJqZGT/NzMw+AAAAAAAAAACBbhQ/ATSmPva7wz0AAAAAAACAPwAAAAAAAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAArXYz+uR+E9AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAHsULj8K16M+AAAAAAAAAABcj0I/j8J1PgAAAAAAAAAAXI9CP4/CdT4AAAAAAAAAAFyPQj+PwnU+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAArXYz+uR+E9AAAAAAAAAAAAAEA/AACAPgAAAAAAAAAACtdjP65H4T0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAEA/AACAPgAAAAAAAAAAAABAPwAAgD4AAAAAAAAAAAAAQD8AAIA+AAAAAAAAAACamRk/zczMPgAAAAAAAAAACtdjP65H4T0AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAADNzEw/zcxMPgAAAAAAAAAApHA9P7gehT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAArXYz+uR+E9AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAAAAQD8AAIA+AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAmZkZP87MzD4AAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/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AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAArXYz+uR+E9AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAAAABAPwAAgD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAEA/AACAPgAAAAAAAAAAAABAPwAAgD4AAAAAAAAAAAAAQD8AAIA+AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAACkcD0/uB6FPgAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADMzcz/NzEw9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AAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAFK5HP7BHYT4AAAAAAAAAABSuRz+wR2E+AAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAABSuRz+wR2E+AAAAAAAAAACkcD0/uB6FPgAAAAAAAAAApHA9P7gehT4AAAAAAAAAABSuRz+wR2E+AAAAAAAAAACkcD0/uB6FPgAAAAAAAAAApHA9P7gehT4AAAAAAAAAAKRwPT+4HoU+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAFK5HP7BHYT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAACkcD0/uB6FPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAApHA9P7gehT4AAAAAAAAAAKRwPT+4HoU+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAM3MTD/NzEw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAApHA9P7gehT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/MzMw9AAAAAAAAAABmZmY/zMzMPQAAAAAAAAAAGIVrP0HXoz0AAAAAAAAAABiFaz9B16M9AAAAAAAAAACA61E/AVI4PgAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAABmZmY/zMzMPQAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAAYhWs/QdejPQAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAABmZmY/zMzMPQAAAAAAAAAAgOtRPwFSOD4AAAAAAAAAAIDrUT8BUjg+AAAAAAAAAACA61E/AVI4PgAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAACA61E/AVI4PgAAAAAAAAAAgOtRPwFSOD4AAAAAAAAAAIDrUT8BUjg+AAAAAAAAAABmZmY/zMzMPQAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAACA61E/AVI4PgAAAAAAAAAAGIVrP0HXoz0AAAAAAAAAABiFaz9B16M9AAAAAAAAAABmZmY/zMzMPQAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAIDrUT8BUjg+AAAAAAAAAAAfhWs/CtejPQAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAIDrUT8BUjg+AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAH4VrPwrXoz0AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAACamRk/zczMPgAAAAAAAAAAgW4UPwE0pj72u8M9AAAAAIFuFD8BNKY+9rvDPQAAAABmZmY/zMzMPQAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAAAYhWs/QdejPQAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAABmZmY/zMzMPQAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAIFuFD8BNKY+9rvDPQAAAAAfhWs/CtejPQAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAArXYz+uR+E9AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAK12M/rkfhPQAAAAAAAAAACtdjP65H4T0AAAAAAAAAAArXYz+uR+E9AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAArXYz+uR+E9AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAArXYz+uR+E9AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABcj0I/j8J1PgAAAAAAAAAAXI9CP4/CdT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABcj0I/j8J1PgAAAAAAAAAAXI9CP4/CdT4AAAAAAAAAAML1KD97FK4+AAAAAAAAAABcj0I/j8J1PgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAwvUoP3sUrj4AAAAAAAAAAML1KD97FK4+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAABAPwAAgD4AAAAAAAAAAAAAQD8AAIA+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAwvUoP3sUrj4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAEA/AACAPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAQD8AAIA+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAQD8AAIA+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAML1KD97FK4+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABcj0I/j8J1PgAAAAAAAAAAwvUoP3sUrj4AAAAAAAAAAML1KD97FK4+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAABAPwAAgD4AAAAAAAAAAAAAQD8AAIA+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAwvUoP3sUrj4AAAAAAAAAAAAAAD8AAAA/AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAEA/AACAPgAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAAAAAD8AAAA/AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAMzNzP83MTD0AAAAAAAAAADMzcz/NzEw9AAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAzM3M/zcxMPQAAAAAAAAAAMzNzP83MTD0AAAAAAAAAAB+Faz8K16M9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAA4XoUPz4K1z4AAAAAAAAAAB+Faz8K16M9AAAAAAAAAACamRk/zczMPgAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAB+Faz8K16M9AAAAAAAAAADhehQ/PgrXPgAAAAAAAAAAexQuPwrXoz4AAAAAAAAAADQzMz+ZmZk+AAAAAAAAAAB7FC4/CtejPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAJqZGT/NzMw+AAAAAAAAAACamRk/zczMPgAAAAAAAAAANDMzP5mZmT4AAAAAAAAAAOF6FD8+Ctc+AAAAAAAAAAAfhWs/CtejPQAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAAfhWs/CtejPQAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAACamRk/zczMPgAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADQzMz+ZmZk+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAB7FC4/CtejPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAHsULj8K16M+AAAAAAAAAAA9Clc/DNcjPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAD0KVz8M1yM+AAAAAAAAAAB7FC4/CtejPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAUrkc/sEdhPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/MzMw9AAAAAAAAAACA61E/AVI4PgAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAACZmRk/zszMPgAAAAAAAAAAH4VrPwrXoz0AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAAAYhWs/QdejPQAAAAAAAAAAZmZmP8zMzD0AAAAAAAAAAOF6FD8+Ctc+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAH4VrPwrXoz0AAAAAAAAAAB+Faz8K16M9AAAAAAAAAAAAAAA/AAAAPwAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAHsULj8K16M+AAAAAAAAAAAfhWs/CtejPQAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAHsULj8K16M+AAAAAAAAAADhehQ/PgrXPgAAAAAAAAAAPQpXPwzXIz4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAACamRk/zczMPgAAAAAAAAAANDMzP5mZmT4AAAAAAAAAAD0KVz8M1yM+AAAAAAAAAADhehQ/PgrXPgAAAAAAAAAAexQuPwrXoz4AAAAAAAAAADQzMz+ZmZk+AAAAAAAAAACamRk/zczMPgAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zcxMPgAAAAAAAAAANDMzP5mZmT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADQzMz+ZmZk+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAB7FC4/CtejPgAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAA9Clc/DNcjPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAACkcD0/uB6FPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAUrkc/sEdhPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAUrkc/sEdhPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAB+Faz8K16M9AAAAAAAAAADhehQ/PgrXPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAB+Faz8K16M9AAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAB+Faz8K16M9AAAAAAAAAAB7FC4/CtejPgAAAAAAAAAA4XoUPz4K1z4AAAAAAAAAADQzMz+ZmZk+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAA0MzM/mZmZPgAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAOF6FD8+Ctc+AAAAAAAAAAB7FC4/CtejPgAAAAAAAAAAH4VrPwrXoz0AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAB7FC4/CtejPgAAAAAAAAAAH4VrPwrXoz0AAAAAAAAAAJqZGT/NzMw+AAAAAAAAAAB7FC4/CtejPgAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADQzMz+ZmZk+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAHsULj8K16M+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAPQpXPwzXIz4AAAAAAAAAAD0KVz8M1yM+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAABmZmY/zMzMPQAAAAAAAAAAgOtRPwFSOD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAfhWs/CtejPQAAAAAAAAAAmZkZP87MzD4AAAAAAAAAAGZmZj/MzMw9AAAAAAAAAABmZmY/zMzMPQAAAAAAAAAAGIVrP0HXoz0AAAAAAAAAAOF6FD8+Ctc+AAAAAAAAAAAfhWs/CtejPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAB+Faz8K16M9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAPwAAAD8AAAAAAAAAAHsULj8K16M+AAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAH4VrPwrXoz0AAAAAAAAAAHsULj8K16M+AAAAAAAAAAA9Clc/DNcjPgAAAAAAAAAA4XoUPz4K1z4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAAA0MzM/mZmZPgAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAD0KVz8M1yM+AAAAAAAAAAB7FC4/CtejPgAAAAAAAAAA4XoUPz4K1z4AAAAAAAAAADQzMz+ZmZk+AAAAAAAAAAB7FC4/CtejPgAAAAAAAAAAmpkZP83MzD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAA0MzM/mZmZPgAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAADQzMz+ZmZk+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAexQuPwrXoz4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAPQpXPwzXIz4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAApHA9P7gehT4AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAFK5HP7BHYT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAFK5HP7BHYT4AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAABmZmY/zczMPQAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAFK5HP7BHYT4AAAAAAAAAABSuRz+wR2E+AAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAABmZmY/zczMPQAAAAAAAAAAZmZmP83MzD0AAAAAAAAAAGZmZj/NzMw9AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAADNzEw/zcxMPgAAAAAAAAAAzcxMP83MTD4AAAAAAAAAAM3MTD/NzEw+AAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAAAA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acECPhwLMr89wQK+GQsyP2fBAj4cCzK/O8ECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/acECPhwLMr89wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/ZsECPhwLMr86wQK+GQsyP2bBAj4cCzK/OsECvhkLMj9mwQI+HAsyvzrBAr4ZCzI/acECPhwLMr89wQK+GQsyP2fBAj4cCzK/O8ECvhkLMj9mwQI+HAsyvzrBAr4ZCzI/acECPhwLMr89wQK+GQsyP2jBAj4cCzK/PMECvhkLMj9mwQI+HAsyvzrBAr4ZCzI/aMECPhwLMr88wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/acECPhwLMr89wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/acECPhwLMr89wQK+GQsyP2fBAj4cCzK/O8ECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/acECPhwLMr89wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/acECPhwLMr89wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/acECPhwLMr89wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9mwQI+HAsyvzrBAr4ZCzI/acECPhwLMr89wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/ZsECPhwLMr86wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9mwQI+HAsyvzrBAr4ZCzI/Z8ECPhwLMr87wQK+GQsyP2bBAj4cCzK/OsECvhkLMj9mwQI+HAsyvzrBAr4ZCzI/acECPhwLMr89wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9mwQI+HAsyvzrBAr4ZCzI/aMECPhwLMr88wQK+GQsyP2bBAj4cCzK/OsECvhkLMj9mwQI+HAsyvzrBAr4ZCzI/ZsECPhwLMr86wQK+GQsyP2bBAj4cCzK/OsECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/acECPhwLMr89wQK+GQsyP2nBAj4cCzK/PcECvhkLMj9pwQI+HAsyvz3BAr4ZCzI/Z8ECPhwLMr87wQK+GQsyP2fBAj4cCzK/O8ECvhkLMj9pwQI+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jNgiQsR3sTW8acRBxCgjQm6MsDW+acRB/3gjQgqhrzW+acRBPskjQrS1rjW8acRBdhkkQlrKrTW9acRBsWkkQvzerDW9acRB7bkkQqTzqzW7acRBKAolQksIqzW8acRBY1olQvQcqjW8acRBn6olQpQxqTW7acRB2volQjtGqDW7acRBFEsmQuJapzW8acRBUZsmQolvpjW8acRBjOsmQiqEpTW7acRBxzsnQtOYpDW7acRBAownQmCjozW7acRBrt8nQpo0pDW8acRBLa4nQmMYpTW7acRBhmAnQif8pTW8acRB4hInQuDfpjW9acRBQMUmQqXDpzW7acRBmHcmQmenqDW8acRB9SkmQimLqTW9acRBU9wlQu9uqjW8acRBqo4lQq9SqzW8acRBB0ElQno2rDW/acRBY/MkQjgarTW8acRBvKUkQvj9rTW8acRBGFgkQrzhrjW9acRBcwokQn7FrzW9acRB0LwjQkCpsDW8acRBKm8jQgGNsTW+acRBhiEjQsxwsjW+acRB4NMiQoxUszW+acRBO4YiQkk4tDW+acRBmTgiQhActTW9acRB8uohQtD/tTW+acRBT50hQpfjtjW9acRBqE8hQlHZtzW+acRB5PsgQuuktzW9acRBwA0hQuWItjW+acRBk24hQld5tTW+acRBJsshQsRptDW8acRBuSciQjtaszW+acRBS4QiQqtKsjW+acRB4OAiQhk7sTW+acRBcj0jQowrsDW7acRBA5ojQvwbrzW9acRBmPYjQlBQrjW+acRBBzwkQhOOZD6/acRBizQgQiGlJj+/acRBLsUgQnmQhD++acRBRoQhQhfVnT++acRB7moiQqG6jT+9acRBtgskQsyjOj+8acRBsb8nQnkrlj67acRBeMonQqEXJr28acRBJUklQhfRmr68acRBLIgkQm3tD7+8acRBkmQlQrZsSb+8acRBxaEmQuSecr+7acRBs8gnQruvgr+7acRB+WUoQkbmcr+7acRBhncnQi8mQL+9acRBAy0lQr5W9L6+acRBuYUiQktSM76+acRBRoogQhOOZD6/acRBizQgQleywjVJNLhBrBQHQhbyvzUsNrZB5oEGQqRavzVXnrVBEosGQme6vTWOWrVB+zMHQkDvtTX447NB76oIQtL6ojVcr69Bbe4KQlMkiTWr/qlB0N0NQv6uYjXhaKVB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",pc=document.querySelector("canvas.webgl"),Kt=new Ag,Dm=new hc,gc=Dm.load(Tm);gc.colorSpace=Me;const Sm=new lg({matcap:gc}),bm=new gr(.3,.2,32,64);for(let i=0;i<100;i++){const A=new Ee(bm,Sm);A.position.x=(Math.random()-.5)*10,A.position.y=(Math.random()-.5)*10,A.position.z=(Math.random()-.5)*10,A.rotation.x=Math.random()*Math.PI,A.rotation.y=Math.random()*Math.PI;const e=Math.random();A.scale.set(e,e,e),Kt.add(A)}const We={width:window.innerWidth,height:window.innerHeight};window.addEventListener("resize",()=>{We.width=window.innerWidth,We.height=window.innerHeight,zt.aspect=We.width/We.height,zt.updateProjectionMatrix(),Jt.setSize(We.width,We.height),Jt.setPixelRatio(Math.min(window.devicePixelRatio,2))});const zt=new Ie(75,We.width/We.height,.1,100);zt.position.x=1;zt.position.y=1;zt.position.z=2;Kt.add(zt);const Bm=new Gg;let Ki=null;Bm.load(ym,i=>{Ki=new Hg(i.scene),Ki.clipAction(i.animations[1]).play(),i.scene.scale.set(.025,.025,.025),i.scene.traverse(e=>{e.isMesh&&(e.castShadow=!0)}),Kt.add(i.scene)});const Pr=new Ee(new ai(10,10),new ts({color:"#444444",metalness:0,roughness:.5}));Pr.receiveShadow=!0;Pr.rotation.x=-Math.PI*.5;Kt.add(Pr);const Rm=new yg("#b9d5ff",.12);Kt.add(Rm);const dt=new uc(16777215,3);dt.castShadow=!0;dt.shadow.mapSize.set(1024,1024);dt.shadow.camera.far=15;dt.shadow.camera.left=-7;dt.shadow.camera.top=7;dt.shadow.camera.right=7;dt.shadow.camera.bottom=-7;dt.position.set(5,5,5);Kt.add(dt);const wr=new Vg(zt,pc);wr.target.set(0,.75,0);wr.enableDamping=!0;const Jt=new $p({canvas:pc});Jt.setSize(We.width,We.height);Jt.setPixelRatio(Math.min(window.devicePixelRatio,2));Jt.shadowMap.enabled=!0;Jt.shadowMap.type=Ea;const zm=new Sg;let Ia=0;const mc=()=>{const i=zm.getElapsedTime(),A=i-Ia;Ia=i,Ki!==null&&Ki.update(A),wr.update(),Jt.render(Kt,zt),window.requestAnimationFrame(mc)};mc();
</script>
  <style rel="stylesheet" crossorigin>*{margin:0;padding:0}html,body{overflow:hidden}.webgl{position:fixed;top:0;left:0;outline:none}
</style>
</head>
<body>
    <canvas class="webgl"></canvas>
</body>
</html>
